<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.17lai.site</id>
    <title>夜法之书 • Posts by &#34;docker&#34; category</title>
    <link href="https://blog.17lai.site" />
    <updated>2022-03-18T06:33:17.000Z</updated>
    <category term="Github" />
    <category term="Jekyll" />
    <category term="blog" />
    <category term="Gitlab" />
    <category term="Git" />
    <category term="Crack" />
    <category term="Linux" />
    <category term="hardlink" />
    <category term="bt" />
    <category term="pt" />
    <category term="note" />
    <category term="markdown" />
    <category term="picgo" />
    <category term="wiz" />
    <category term="Joplin" />
    <category term="Typora" />
    <category term="QNAP" />
    <category term="硬盘" />
    <category term="nas" />
    <category term="embeded" />
    <category term="3G" />
    <category term="4G" />
    <category term="3531a" />
    <category term="移植" />
    <category term="嵌入式" />
    <category term="hisilicon" />
    <category term="Driver" />
    <category term="3798M" />
    <category term="MPP" />
    <category term="UNF" />
    <category term="Kernel" />
    <category term="宝塔" />
    <category term="VPS" />
    <category term="建站" />
    <category term="Nginx" />
    <category term="Apache" />
    <category term="MySQL" />
    <category term="Docker" />
    <category term="LAMP" />
    <category term="PHP" />
    <category term="Tomcat" />
    <category term="JSP" />
    <category term="教程" />
    <category term="Rigistry" />
    <category term="email" />
    <category term="https" />
    <category term="ssl" />
    <category term="Debian" />
    <category term="Laptop" />
    <category term="ED2K" />
    <category term="ATI" />
    <category term="WIFI" />
    <category term="Hotkey" />
    <category term="SSD" />
    <category term="HDD" />
    <category term="管理" />
    <category term="PDCA" />
    <category term="5W2H" />
    <category term="SMART" />
    <category term="SWOT" />
    <category term="GROW" />
    <category term="OKR" />
    <category term="WBS" />
    <category term="PT" />
    <category term="BT" />
    <category term="qbittorrent" />
    <category term="transmission" />
    <category term="Emby" />
    <category term="Sonarr" />
    <category term="Jeckett" />
    <category term="Portainer" />
    <category term="Watchtower" />
    <category term="DNSMasq" />
    <category term="DNSCrypt" />
    <category term="启动" />
    <category term="优化" />
    <category term="SSL" />
    <category term="TLS" />
    <category term="隐私" />
    <category term="安全" />
    <category term="linux" />
    <category term="GitBook" />
    <category term="MySql" />
    <category term="Mariadb" />
    <category term="技巧" />
    <category term="MarkDown" />
    <category term="Mermaid" />
    <category term="Nas" />
    <category term="群晖" />
    <category term="web" />
    <category term="http" />
    <category term="css" />
    <category term="js" />
    <category term="3a" />
    <category term="ae" />
    <category term="image" />
    <category term="ccs" />
    <category term="vim" />
    <category term="ide" />
    <category term="docker" />
    <category term="ai" />
    <category term="face" />
    <category term="music" />
    <category term="韩红" />
    <category term="hexo" />
    <category term="matery" />
    <category term="cdn" />
    <category term="seo" />
    <category term="thinkpad" />
    <category term="sound" />
    <category term="speaker" />
    <category term="刮削" />
    <category term="MusicBrainz" />
    <category term="mp3tag" />
    <category term="tmm" />
    <category term="字幕" />
    <category term="emby" />
    <category term="plex" />
    <category term="qnap" />
    <category term="ipv6" />
    <category term="cmake" />
    <category term="develop" />
    <category term="traefik" />
    <category term="proxy" />
    <category term="swarm" />
    <category term="ubuntu" />
    <category term="vscode" />
    <category term="插件" />
    <category term="编码" />
    <category term="mermaid" />
    <category term="plantuml" />
    <category term="mathjax" />
    <category term="CI/CD" />
    <category term="Earthly" />
    <category term="git" />
    <category term="mstream" />
    <category term="selfhost" />
    <category term="中岛美嘉" />
    <category term="node" />
    <category term="jenkins" />
    <category term="tools" />
    <category term="winrar" />
    <category term="crack" />
    <category term="emoji" />
    <category term="shell" />
    <category term="isp" />
    <category term="awb" />
    <category term="mywork" />
    <entry>
        <id>https://blog.17lai.site/posts/90e60aac/</id>
        <title>使用 Shell 脚本实现一个简单 Docker</title>
        <link rel="alternate" href="https://blog.17lai.site/posts/90e60aac/"/>
        <content type="html">&lt;link rel=&#34;stylesheet&#34; class=&#34;aplayer-secondary-style-marker&#34; href=&#34;/assets/css/APlayer.min.css&#34;&gt;&lt;script src=&#34;/assets/js/APlayer.min.js&#34; class=&#34;aplayer-secondary-script-marker&#34;&gt;&lt;/script&gt;&lt;blockquote&gt;
&lt;p&gt;《使用 Shell 脚本实现 Docker》旨在通过一系列的实验使用户对 docker 的底层技术，如 Namespace、CGroups、rootfs、联合加载等有一个感性的认识。在此过程中，我们还将通过 Shell 脚本一步一步地实现一个简易的 docker，以期使读者在使用 docker 的过程中知其然知其所以然。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们的实验环境为 Ubuntu 18.04 64bit，简易 docker 工程的名字为 docker.sh，该工程仓库地址如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-html&#34; data-language=&#34;html&#34;&gt;&lt;code class=&#34;language-html&#34;&gt;https://github.com/pandengyang/docker.sh.git
https://github.com/appotry/docker.sh&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;《使用 Shell 脚本实现 Docker》目录如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;1. Namespace
1.1. Namespace简介
1.2. uts namespace
1.2.1. uts namespace简介
1.2.2. docker.sh
1.3. mount namespace
1.3.1. /etc/mtab、/proc/self/mounts
1.3.2. /proc/self/mountinfo
1.3.3. bind mount
1.3.4. mount namespace简介
1.3.5. docker.sh
1.4. pid namespace
1.4.1. unshare的--fork选项
1.4.2. pid namespace简介
1.4.3. pid嵌套
1.4.4. docker.sh
2. CGroups
2.1. CGroups简介
2.2. 限制内存
2.2.1. 用CGroups限制内存
2.2.2. docker.sh
3. 切换根文件系统
3.1. 根文件系统
3.2. pivot_root
3.3. docker.sh
4. 联合加载
4.1. 联合加载简介
4.2. AUFS
4.3. docker.sh
5. 卷
5.1. 卷简介
5.2. docker.sh
6. 后记&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;1-Namespace&#34;&gt;1.Namespace&lt;/h2&gt;
&lt;h3 id=&#34;1-1-Namespace简介&#34;&gt;1.1.Namespace 简介&lt;/h3&gt;
&lt;p&gt;传统上，在 Linux 中，许多资源是全局管理的。例如，系统中的所有进程按照惯例是通过 PID 标识的，这意味着内核必须管理一个全局的 PID 列表。而且，所有调用者通过 uname 系统调用返回的系统相关信息都是相同的。用户 id 的管理方式类似，即各个用户是通过一个全局唯一的 UID 标识。&lt;/p&gt;
&lt;p&gt;Namespace 是 Linux 用来隔离上述全局资源的一种方式。把一个或多个进程加入到同一个 namespace 中后，这些进程只会看到该 namespace 中的资源。namespace 是后来加入到 Linux 中的，为了兼容之前的全局资源管理方式，Linux 为每一种资源准备了一个全局的 namespace。Linux 中的每一个进程都默认加入了这些全局 namespace。&lt;/p&gt;
&lt;p&gt;Linux 中的每个进程都有一个 /proc/[pid]/ns/ 目录，里面包含了该进程所属的 namespace 信息。我们查看一下当前 Shell 的 /proc/[pid]/ns 目录，命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;ls&lt;/span&gt; -l /proc/&lt;span class=&#34;token variable&#34;&gt;$$&lt;/span&gt;/ns
total &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;
lrwxrwxrwx &lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt; phl phl &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt; Jan &lt;span class=&#34;token number&#34;&gt;22&lt;/span&gt; 08:43 cgroup -&lt;span class=&#34;token operator&#34;&gt;&amp;gt;&lt;/span&gt; cgroup:&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;4026531835&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;
lrwxrwxrwx &lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt; phl phl &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt; Jan &lt;span class=&#34;token number&#34;&gt;22&lt;/span&gt; 08:43 ipc -&lt;span class=&#34;token operator&#34;&gt;&amp;gt;&lt;/span&gt; ipc:&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;4026531839&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;
lrwxrwxrwx &lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt; phl phl &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt; Jan &lt;span class=&#34;token number&#34;&gt;22&lt;/span&gt; 08:43 mnt -&lt;span class=&#34;token operator&#34;&gt;&amp;gt;&lt;/span&gt; mnt:&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;4026531840&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;
lrwxrwxrwx &lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt; phl phl &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt; Jan &lt;span class=&#34;token number&#34;&gt;22&lt;/span&gt; 08:43 net -&lt;span class=&#34;token operator&#34;&gt;&amp;gt;&lt;/span&gt; net:&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;4026531993&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;
lrwxrwxrwx &lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt; phl phl &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt; Jan &lt;span class=&#34;token number&#34;&gt;22&lt;/span&gt; 08:43 pid -&lt;span class=&#34;token operator&#34;&gt;&amp;gt;&lt;/span&gt; pid:&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;4026531836&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;
lrwxrwxrwx &lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt; phl phl &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt; Jan &lt;span class=&#34;token number&#34;&gt;22&lt;/span&gt; 08:43 pid_for_children -&lt;span class=&#34;token operator&#34;&gt;&amp;gt;&lt;/span&gt; pid:&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;4026531836&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;
lrwxrwxrwx &lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt; phl phl &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt; Jan &lt;span class=&#34;token number&#34;&gt;22&lt;/span&gt; 08:43 user -&lt;span class=&#34;token operator&#34;&gt;&amp;gt;&lt;/span&gt; user:&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;4026531837&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;
lrwxrwxrwx &lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt; phl phl &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt; Jan &lt;span class=&#34;token number&#34;&gt;22&lt;/span&gt; 08:43 uts -&lt;span class=&#34;token operator&#34;&gt;&amp;gt;&lt;/span&gt; uts:&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;4026531838&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该目录下有很多符号链接，每个符号链接代表一个该进程所属的 namespace。用 readlink 读取这些符号链接可以查看进程所属的 namespace id。我们读一下当前 Shell 所属的 uts namespace id，命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; readlink /proc/&lt;span class=&#34;token variable&#34;&gt;$$&lt;/span&gt;/ns/uts
uts:&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;4026531838&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;后文中我们将介绍 uts namespace、mount namespace、pid namespace 的用法。&lt;/p&gt;
&lt;h3 id=&#34;1-2-uts-namespace&#34;&gt;1.2.uts namespace&lt;/h3&gt;
&lt;h4 id=&#34;1-2-1-uts-namespace简介&#34;&gt;1.2.1.uts namespace 简介&lt;/h4&gt;
&lt;p&gt;uts namespace 用于隔离系统的主机名等信息，我们将通过实验学习其用法。在实验过程中，我们采用如下的步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;查看全局 uts namespace 信息&lt;/li&gt;
&lt;li&gt;新建一个 uts namespace，查看其信息并作出修改&lt;/li&gt;
&lt;li&gt;查看全局 uts namespace，查看其是否被新建的 uts namespace 影响到&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于其他 namespace，我们也采取类似的步骤进行实验学习。&lt;/p&gt;
&lt;p&gt;首先，我们查看一下全局的 hostname 及 uts namespace id。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~$ &lt;span class=&#34;token function&#34;&gt;hostname&lt;/span&gt;
kernelnewbies

phl@kernelnewbies:~$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; readlink /proc/&lt;span class=&#34;token variable&#34;&gt;$$&lt;/span&gt;/ns/uts
uts:&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;4026531838&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，我们创建一个新的 uts namespace，并查看其 namespce id。&lt;/p&gt;
&lt;p&gt;在继续之前，需要介绍一个 namespace 工具 unshare。利用 unshare 我们可以新建一个的 namespace，并在新 namespace 中执行一条命令。unshare 执行时需要 root 权限。unshare 的使用方法如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;unshare &lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;options&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;program &lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;arguments&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行 unshare 时，我们可以指定要新建的 namespace 的类型以及要执行的命令。unshare 提供了一系列选项，当指定某个选项时可新建指定的 namespace。namespace 类型选项如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;--uts 创建新的 uts namespace&lt;/li&gt;
&lt;li&gt;--mount 创建新的 mount namespace&lt;/li&gt;
&lt;li&gt;--pid 创建新的 pid namespace&lt;/li&gt;
&lt;li&gt;--user 创建新的 user namespace&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;介绍完 unshare 之后，我们继续之前的实验。我们用 unshare 创建一个新的 uts namespace，并在新的 uts namespace 中执行 /bin/bash 命令，命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; unshare --uts /bin/bash
root@kernelnewbies:~&lt;span class=&#34;token comment&#34;&gt;#&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们用 unshare 创建了一个新的 uts namespace。在新的 uts namespace 中查看其 hostname 和 namespace id，命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;root@kernelnewbies:~$ &lt;span class=&#34;token function&#34;&gt;hostname&lt;/span&gt;
kernelnewbies

root@kernelnewbies:~&lt;span class=&#34;token comment&#34;&gt;# readlink /proc/$$/ns/uts&lt;/span&gt;
uts:&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;4026532177&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果我们可以看到，新 uts namespace 的 id 与全局 uts namespace 的 id 不一致。这说明 /bin/bash 已运行在一个新的 uts namespace 中了。&lt;/p&gt;
&lt;p&gt;我们将新 uts namespace 的 hostname 改为 dreamland，并强制更新 Shell 提示符。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;root@kernelnewbies:~&lt;span class=&#34;token comment&#34;&gt;# hostname dreamland&lt;/span&gt;
root@kernelnewbies:~&lt;span class=&#34;token comment&#34;&gt;# hostname&lt;/span&gt;
dreamland

root@kernelnewbies:~&lt;span class=&#34;token comment&#34;&gt;# exec /bin/bash&lt;/span&gt;
root@dreamland:~&lt;span class=&#34;token comment&#34;&gt;#&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果我们可以看到，新 uts namespace 的 hostname 的确是被修改了，exec /bin/bash 用于强制更新 Shell 的提示符。&lt;/p&gt;
&lt;p&gt;我们重新打开一个 Shell 窗口，该 Shell 位于全局 uts namespace 中。在新的 Shell 窗口中查看全局 uts namespace id 及 hostname，命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~$ &lt;span class=&#34;token function&#34;&gt;hostname&lt;/span&gt;
kernelnewbies

phl@kernelnewbies:~$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; readlink /proc/&lt;span class=&#34;token variable&#34;&gt;$$&lt;/span&gt;/ns/uts
uts:&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;4026531838&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果我们可以看到，我们在新 uts namespace 中所作的修改并未影响到全局的 uts namespace。&lt;/p&gt;
&lt;p&gt;父进程创建子进程时只有提供创建新 namespace 的标志，才可创建新的 namespace，并使子进程处于新的 namespace 中。默认情况下，子进程与父进程处于相同的 namespace 中。我们在新的 uts namespace 中创建一个子进程，然后查看该子进程的 uts namespace id，命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; unshare --uts /bin/bash
root@kernelnewbies:~&lt;span class=&#34;token comment&#34;&gt;# readlink /proc/$$/ns/uts&lt;/span&gt;
uts:&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;4026532305&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;

root@kernelnewbies:~&lt;span class=&#34;token comment&#34;&gt;# bash&lt;/span&gt;
root@kernelnewbies:~&lt;span class=&#34;token comment&#34;&gt;# readlink /proc/$$/ns/uts&lt;/span&gt;
uts:&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;4026532305&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果我们可以看到，子进程所属 uts namespace 的 id 与其父进程相同。其他 namespae 与 uts namespace 类似，子进程与父进程同属一个 namespace。&lt;/p&gt;
&lt;h4 id=&#34;1-2-2-docker-sh&#34;&gt;1.2.2.docker.sh&lt;/h4&gt;
&lt;p&gt;有了以上关于 uts namespace 的介绍，我们就可以将 uts namespace 加入到 docker.sh 中了。docker.sh 工程分为两个脚本：docker.sh 和 container.sh。&lt;/p&gt;
&lt;p&gt;docker.sh 用于收集用户输入、调用 unshare 创建 namespace 并执行 container.sh 脚本，docker.sh 脚本如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&lt;span class=&#34;token shebang important&#34;&gt;#!/bin/bash&lt;/span&gt;

&lt;span class=&#34;token function-name function&#34;&gt;usage&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;token builtin class-name&#34;&gt;echo&lt;/span&gt; -e &lt;span class=&#34;token string&#34;&gt;&#34;&lt;span class=&#34;token entity&#34; title=&#34;\033&#34;&gt;\033&lt;/span&gt;[31mIMPORTANT: Run As Root&lt;span class=&#34;token entity&#34; title=&#34;\033&#34;&gt;\033&lt;/span&gt;[0m&#34;&lt;/span&gt;
        &lt;span class=&#34;token builtin class-name&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34;&#34;&lt;/span&gt;
        &lt;span class=&#34;token builtin class-name&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34;Usage:    docker.sh [OPTIONS]&#34;&lt;/span&gt;
        &lt;span class=&#34;token builtin class-name&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34;&#34;&lt;/span&gt;
        &lt;span class=&#34;token builtin class-name&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34;A docker written by shell&#34;&lt;/span&gt;
        &lt;span class=&#34;token builtin class-name&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34;&#34;&lt;/span&gt;
        &lt;span class=&#34;token builtin class-name&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34;Options:&#34;&lt;/span&gt;
        &lt;span class=&#34;token builtin class-name&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34;          -c string       docker command&#34;&lt;/span&gt;
        &lt;span class=&#34;token builtin class-name&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34;                          (&lt;span class=&#34;token entity&#34; title=&#34;\&amp;quot;&#34;&gt;\&#34;&lt;/span&gt;run&lt;span class=&#34;token entity&#34; title=&#34;\&amp;quot;&#34;&gt;\&#34;&lt;/span&gt;)&#34;&lt;/span&gt;
        &lt;span class=&#34;token builtin class-name&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34;          -m              memory&#34;&lt;/span&gt;
        &lt;span class=&#34;token builtin class-name&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34;                          (&lt;span class=&#34;token entity&#34; title=&#34;\&amp;quot;&#34;&gt;\&#34;&lt;/span&gt;100M, 200M, 300M...&lt;span class=&#34;token entity&#34; title=&#34;\&amp;quot;&#34;&gt;\&#34;&lt;/span&gt;)&#34;&lt;/span&gt;
        &lt;span class=&#34;token builtin class-name&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34;          -C string       container name&#34;&lt;/span&gt;
        &lt;span class=&#34;token builtin class-name&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34;          -I string       image name&#34;&lt;/span&gt;
        &lt;span class=&#34;token builtin class-name&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34;          -V string       volume&#34;&lt;/span&gt;
        &lt;span class=&#34;token builtin class-name&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34;          -P string       program to run in container&#34;&lt;/span&gt;

        &lt;span class=&#34;token builtin class-name&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;
&lt;span class=&#34;token punctuation&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;token keyword&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;token builtin class-name&#34;&gt;test&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34;&lt;span class=&#34;token variable&#34;&gt;&lt;span class=&#34;token variable&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;whoami&lt;/span&gt;&lt;span class=&#34;token variable&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&#34;&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;!=&lt;/span&gt; root
&lt;span class=&#34;token keyword&#34;&gt;then&lt;/span&gt;
        usage
        &lt;span class=&#34;token builtin class-name&#34;&gt;exit&lt;/span&gt; -1
&lt;span class=&#34;token keyword&#34;&gt;fi&lt;/span&gt;

&lt;span class=&#34;token keyword&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;token builtin class-name&#34;&gt;getopts&lt;/span&gt; c:m:C:I:V:P: option
&lt;span class=&#34;token keyword&#34;&gt;do&lt;/span&gt;
        &lt;span class=&#34;token keyword&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34;&lt;span class=&#34;token variable&#34;&gt;$option&lt;/span&gt;&#34;&lt;/span&gt;
        &lt;span class=&#34;token keyword&#34;&gt;in&lt;/span&gt;
                c&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token assign-left variable&#34;&gt;cmd&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token variable&#34;&gt;$OPTARG&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
                m&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token assign-left variable&#34;&gt;memory&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token variable&#34;&gt;$OPTARG&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
                C&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token assign-left variable&#34;&gt;container&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token variable&#34;&gt;$OPTARG&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
                I&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token assign-left variable&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token variable&#34;&gt;$OPTARG&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
                V&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token assign-left variable&#34;&gt;volume&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token variable&#34;&gt;$OPTARG&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
                P&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token assign-left variable&#34;&gt;program&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token variable&#34;&gt;$OPTARG&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
                &lt;span class=&#34;token punctuation&#34;&gt;\&lt;/span&gt;?&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; usage
                    &lt;span class=&#34;token builtin class-name&#34;&gt;exit&lt;/span&gt; -2&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;token keyword&#34;&gt;esac&lt;/span&gt;
&lt;span class=&#34;token keyword&#34;&gt;done&lt;/span&gt;

&lt;span class=&#34;token builtin class-name&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;token assign-left variable&#34;&gt;cmd&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token variable&#34;&gt;$cmd&lt;/span&gt;
&lt;span class=&#34;token builtin class-name&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;token assign-left variable&#34;&gt;memory&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token variable&#34;&gt;$memory&lt;/span&gt;
&lt;span class=&#34;token builtin class-name&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;token assign-left variable&#34;&gt;container&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;
&lt;span class=&#34;token builtin class-name&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;token assign-left variable&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token variable&#34;&gt;$image&lt;/span&gt;
&lt;span class=&#34;token builtin class-name&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;token assign-left variable&#34;&gt;volume&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token variable&#34;&gt;$volume&lt;/span&gt;
&lt;span class=&#34;token builtin class-name&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;token assign-left variable&#34;&gt;program&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token variable&#34;&gt;$program&lt;/span&gt;

unshare --uts ./container.sh&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;脚本最开始为 usage 函数，该函数为 docker.sh 的使用说明。当用户以非预期的方式使用 docker.sh 时，该函数会被调用。该函数输出如下信息：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;IMPORTANT: Run As Root

Usage:  docker.sh &lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;OPTIONS&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;

A &lt;span class=&#34;token function&#34;&gt;docker&lt;/span&gt; written by shell

Options:
                -c string       &lt;span class=&#34;token function&#34;&gt;docker&lt;/span&gt; &lt;span class=&#34;token builtin class-name&#34;&gt;command&lt;/span&gt;
                                &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#34;run&#34;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;
                -m              memory
                                &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#34;100M, 200M, 300M...&#34;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;
                -C string       container name
                -I string       image name
                -V string       volume
                -P string       program to run &lt;span class=&#34;token keyword&#34;&gt;in&lt;/span&gt; container&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从 usage 函数的输出我们可以看到，执行 docker.sh 时需要 root 权限且需要正确地传递参数。&lt;/p&gt;
&lt;p&gt;docker.sh 首先对当前用户进行检测，如果用户不为 root，则打印使用说明并退出脚本；如果用户为 root，则继续执行。检测用户的脚本如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&lt;span class=&#34;token keyword&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;token builtin class-name&#34;&gt;test&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34;&lt;span class=&#34;token variable&#34;&gt;&lt;span class=&#34;token variable&#34;&gt;$(&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;whoami&lt;/span&gt;&lt;span class=&#34;token variable&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&#34;&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;!=&lt;/span&gt; root
&lt;span class=&#34;token keyword&#34;&gt;then&lt;/span&gt;
        usage
        &lt;span class=&#34;token builtin class-name&#34;&gt;exit&lt;/span&gt; -1
&lt;span class=&#34;token keyword&#34;&gt;fi&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，docker.sh 使用 getopts 从命令行提取参数，然后赋值给合适的变量。从命令行提取参数的脚本如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&lt;span class=&#34;token keyword&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;token builtin class-name&#34;&gt;getopts&lt;/span&gt; c:m:C:I:V:P: option
&lt;span class=&#34;token keyword&#34;&gt;do&lt;/span&gt;
        &lt;span class=&#34;token keyword&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34;&lt;span class=&#34;token variable&#34;&gt;$option&lt;/span&gt;&#34;&lt;/span&gt;
        &lt;span class=&#34;token keyword&#34;&gt;in&lt;/span&gt;
                c&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token assign-left variable&#34;&gt;cmd&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token variable&#34;&gt;$OPTARG&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
                m&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token assign-left variable&#34;&gt;memory&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token variable&#34;&gt;$OPTARG&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
                C&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token assign-left variable&#34;&gt;container&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token variable&#34;&gt;$OPTARG&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
                I&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token assign-left variable&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token variable&#34;&gt;$OPTARG&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
                V&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token assign-left variable&#34;&gt;volume&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token variable&#34;&gt;$OPTARG&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
                P&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token assign-left variable&#34;&gt;program&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token variable&#34;&gt;$OPTARG&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
                &lt;span class=&#34;token punctuation&#34;&gt;\&lt;/span&gt;?&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; usage
                    &lt;span class=&#34;token builtin class-name&#34;&gt;exit&lt;/span&gt; -2&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;token keyword&#34;&gt;esac&lt;/span&gt;
&lt;span class=&#34;token keyword&#34;&gt;done&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果用户的输入不正确，则打印使用说明并退出脚本；如果用户输入正确，则解析命令行参数并赋值给合适的变量。&lt;/p&gt;
&lt;p&gt;为了简化，用户在运行 docker.sh 时需提供完整的参数列表，示例如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; ./docker.sh -c run -m 100M -C dreamland -I ubuntu1604 -V data1 -P /bin/bash&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然，如果当前用户就是 root，就不需要 sudo 了。下表列出了各个参数的含义及示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2022/03/1820220318143125.png&#34; alt=&#34;使用 Shell 脚本实现 Docker&#34;&gt;&lt;/p&gt;
&lt;p&gt;docker.sh 将命令行参数赋值给变量后，需要将这些变量导出，以传递给 container.sh。导出变量的脚本如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&lt;span class=&#34;token builtin class-name&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;token assign-left variable&#34;&gt;cmd&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token variable&#34;&gt;$cmd&lt;/span&gt;
&lt;span class=&#34;token builtin class-name&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;token assign-left variable&#34;&gt;memory&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token variable&#34;&gt;$memory&lt;/span&gt;
&lt;span class=&#34;token builtin class-name&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;token assign-left variable&#34;&gt;container&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;
&lt;span class=&#34;token builtin class-name&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;token assign-left variable&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token variable&#34;&gt;$image&lt;/span&gt;
&lt;span class=&#34;token builtin class-name&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;token assign-left variable&#34;&gt;volume&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token variable&#34;&gt;$volume&lt;/span&gt;
&lt;span class=&#34;token builtin class-name&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;token assign-left variable&#34;&gt;program&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token variable&#34;&gt;$program&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里说明一下为什么要将 docker.sh 工程拆分为 docker.sh 和 container.sh 两个脚本。因为调用 unshare 创建新的 namespace 时，会执行一个命令，该命令在新的 namespace 中运行。该命令一旦结束，unshare 也就结束了，unshare 创建的新 namespace 也就不存在了。&lt;/p&gt;
&lt;p&gt;docker.sh 不会并发地执行 unshare 命令与 unshare 之后的脚本，因此，只有 unshare 结束了，后续脚本才可继续运行。但是当 unshare 结束了，准备执行后续脚本时，新的 namespae 已经不存在了。因此一些加入 cgroups、切换根文件系统等工作必须在 unshare 执行的命令中进行，所以我们采用在 unshare 中执行 container.sh 脚本的方式完成后续的工作。&lt;/p&gt;
&lt;p&gt;最后，docker.sh 调用 unshare 创建新的 uts namespace，并执行 container.sh 脚本。调用 unshare 的脚本如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;unshare --uts ./container.sh&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;container.sh 将容器的 hostname 修改为通过 - C 传递的容器的名字，然后执行通过 - P 传递的程序。container.sh 脚本如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&lt;span class=&#34;token shebang important&#34;&gt;#!/bin/bash&lt;/span&gt;

&lt;span class=&#34;token function&#34;&gt;hostname&lt;/span&gt; &lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;
&lt;span class=&#34;token builtin class-name&#34;&gt;exec&lt;/span&gt; &lt;span class=&#34;token variable&#34;&gt;$program&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在，我们运行 docker.sh，并查看其 hostname。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~/docker.sh$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; ./docker.sh -c run -m 100M -C dreamland -I ubuntu1604 -V data1 -P /bin/bash
root@dreamland:~/docker.sh&lt;span class=&#34;token comment&#34;&gt;# hostname&lt;/span&gt;
dreamland&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果我们可以看到，容器的 hostname 已经改变为我们传递的容器名字 dreamland 了。&lt;/p&gt;
&lt;h3 id=&#34;1-3-mount-namespace&#34;&gt;1.3.mount namespace&lt;/h3&gt;
&lt;h4 id=&#34;1-3-1-etc-mtab、-proc-self-mounts&#34;&gt;1.3.1./etc/mtab、/proc/self/mounts&lt;/h4&gt;
&lt;p&gt;早期的 Linux 使用 /etc/mtab 文件来记录当前的挂载点信息。每次 mount/umount 文件系统时会更新 /etc/mtab 文件中的信息。&lt;/p&gt;
&lt;p&gt;后来，linux 引入了 mount namespace，每个进程都有一份自己的挂载点信息。当然，处于同一个 mount namespace 里面的进程，其挂载点信息是相同的。进程的挂载点信息通过 /proc/[pid]/mounts 文件导出给用户。&lt;/p&gt;
&lt;p&gt;为了兼容以前的 /etc/mtab，/etc/mtab 变成了指向 /proc/self/mounts 的符号链接。通过 readlink 查看 /etc/mtab 指向的文件，命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~$ readlink /etc/mtab
&lt;span class=&#34;token punctuation&#34;&gt;..&lt;/span&gt;/proc/self/mounts&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过读取 /proc/self/mounts 文件，可以查看当前的挂载点信息，命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~$ &lt;span class=&#34;token function&#34;&gt;cat&lt;/span&gt; /proc/self/mounts
sysfs /sys sysfs rw,nosuid,nodev,noexec,relatime &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;
proc /proc proc rw,nosuid,nodev,noexec,relatime &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;
/dev/sda1 / ext4 rw,relatime,errors&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;remount-ro &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;
securityfs /sys/kernel/security securityfs rw,nosuid,nodev,noexec,relatime &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;
&lt;span class=&#34;token punctuation&#34;&gt;..&lt;/span&gt;.&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于该文件中内容太多，我们省略了一部分，只保留了一些比较重要的挂载点信息。每行的信息分为六个字段，各字段的含义及示例如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2022/03/1820220318143143.png&#34; alt=&#34;使用 Shell 脚本实现 Docker&#34;&gt;&lt;/p&gt;
&lt;p&gt;由于该文件有点过时，被后文介绍的 /proc/self/mountinfo 替换掉，所以不做过多介绍。&lt;/p&gt;
&lt;h4 id=&#34;1-3-2-proc-self-mountinfo&#34;&gt;1.3.2./proc/self/mountinfo&lt;/h4&gt;
&lt;p&gt;/proc/self/mountinfo 包含了进程 mount namespace 中的挂载点信息。 它提供了旧的 /proc/[pid]/mounts 文件中缺少的各种信息（传播状态，挂载点 id，父挂载点 id 等），并解决了 /proc/[pid]/mounts 文件的一些其他缺陷。我们查看进程挂载点信息时应优先使用该文件。&lt;/p&gt;
&lt;p&gt;该文件中每一行代表一个挂载点信息，每个挂载点信息分为 11 个字段。挂载点信息的示例如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2022/03/1820220318143124.png&#34; alt=&#34;使用 Shell 脚本实现 Docker&#34;&gt;&lt;/p&gt;
&lt;p&gt;各字段的含义及示例如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2022/03/1820220318143118.png&#34; alt=&#34;使用 Shell 脚本实现 Docker&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们主要关注可选字段中的传播状态选项。首先，我们看一下关于 mount namespace 的问题。问题如下：&lt;/p&gt;
&lt;p&gt;当创建 mount namespace 时，新 mount namespace 会拷贝一份老 mount namespace 里面的挂载点信息。例如，全局 mount namespace 中有一个 /a 挂载点，新建的 mount namespace 中也会有一个 /a 挂载点。那么我们在新 mount namespace 中的 /a 下创建或删除一个挂载点，全局 mount namespace 中的 /a 会同步创建或删除该挂载点吗？或者在全局 mount namespace 中的 /a 下创建或删除一个挂载点，新 mount namespace 中的 /a 会同步创建或删除该挂载点吗？&lt;/p&gt;
&lt;p&gt;mountinfo 文件中可选字段的传播状态就是控制在一个挂载点下进行创建 / 删除挂载点操作时是否会传播到其他挂载点的选项。传播状态有四种可取值，常见的有如下两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;shared 表示创建 / 删除挂载点的操作会传播到其他挂载点&lt;/li&gt;
&lt;li&gt; private 表示创建 / 删除挂载点的操作不会传播到其他挂载点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于在容器技术中要保证主机与容器的挂载点信息互不影响，因此要求容器中的挂载点的传播状态为 private。&lt;/p&gt;
&lt;h4 id=&#34;1-3-3-bind-mount&#34;&gt;1.3.3.bind mount&lt;/h4&gt;
&lt;p&gt;bind mount 可以将一个目录（源目录）挂载到另一个目录（目的目录），在目的目录里面的读写操作将直接作用于源目录。&lt;/p&gt;
&lt;p&gt;下面我们通过实验了解一下 bind mount 的功能，首先，我们准备一下实验所需要的的目录及文件。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~$ &lt;span class=&#34;token function&#34;&gt;mkdir&lt;/span&gt; &lt;span class=&#34;token builtin class-name&#34;&gt;bind&lt;/span&gt;
phl@kernelnewbies:~$ &lt;span class=&#34;token builtin class-name&#34;&gt;cd&lt;/span&gt; bind/
phl@kernelnewbies:~/bind$ &lt;span class=&#34;token function&#34;&gt;mkdir&lt;/span&gt; a
phl@kernelnewbies:~/bind$ &lt;span class=&#34;token function&#34;&gt;mkdir&lt;/span&gt; b
phl@kernelnewbies:~/bind$ &lt;span class=&#34;token builtin class-name&#34;&gt;echo&lt;/span&gt; hello, a &lt;span class=&#34;token operator&#34;&gt;&amp;gt;&lt;/span&gt; a/a.txt
phl@kernelnewbies:~/bind$ &lt;span class=&#34;token builtin class-name&#34;&gt;echo&lt;/span&gt; hello, b &lt;span class=&#34;token operator&#34;&gt;&amp;gt;&lt;/span&gt; b/b.txt&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，我们将 a 目录 bind mount 到 b 目录并查看 b 目录下的内容。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~/bind$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;mount&lt;/span&gt; --bind a b
phl@kernelnewbies:~/bind$ tree b
b
└── a.txt
&lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt; directories, &lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;file&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果我们可以看到，b 目录下原先的内容被隐藏，取而代之的是 a 目录下的内容。&lt;/p&gt;
&lt;p&gt;然后，我们修改 b 目录下的内容，修改完毕后，从 b 目录上卸载掉 a 目录。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~/bind$ &lt;span class=&#34;token builtin class-name&#34;&gt;echo&lt;/span&gt; hello, a from b &lt;span class=&#34;token operator&#34;&gt;&amp;gt;&lt;/span&gt; b/a.txt
phl@kernelnewbies:~/bind$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;umount&lt;/span&gt; b&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们读取一下 a 目录中 a.txt，看看其内容是否被改变。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~/bind$ &lt;span class=&#34;token function&#34;&gt;cat&lt;/span&gt; a/a.txt
hello, a from b&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果我们可以看到，a 目录中的内容确实被当 a 被 bind mount 到 b 时对 b 目录的操作所修改了。&lt;/p&gt;
&lt;p&gt;bind mount 在容器技术中有很重要的用途，后文会有涉及。&lt;/p&gt;
&lt;h4 id=&#34;1-3-4-mount-namespace简介&#34;&gt;1.3.4.mount namespace 简介&lt;/h4&gt;
&lt;p&gt;mount namespace 用来隔离文件系统的挂载点信息，使得不同的 mount namespace 拥有自己独立的挂载点信息。不同的 namespace 之间不会相互影响，其在 unshare 中的选项为 --mount。&lt;/p&gt;
&lt;p&gt;当用 unshare 创建新的 mount namespace 时，新创建的 namespace 将拷贝一份老 namespace 里的挂载点信息，但从这之后，他们就没有关系了。这是 unshare 将新 namespace 里面的所有挂载点的传播状态设置为 private 实现的。通过 mount 和 umount 增加和删除各自 mount namespace 里面的挂载点都不会相互影响。&lt;/p&gt;
&lt;p&gt;下面我们将演示 mount namespace 的用法。首先，我们准备需要的目录和文件，命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~$ &lt;span class=&#34;token function&#34;&gt;mkdir&lt;/span&gt; -p hds/hd1 hds/hd2 &lt;span class=&#34;token operator&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;token builtin class-name&#34;&gt;cd&lt;/span&gt; hds

phl@kernelnewbies:~/hds$ &lt;span class=&#34;token function&#34;&gt;dd&lt;/span&gt; &lt;span class=&#34;token assign-left variable&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;/dev/zero &lt;span class=&#34;token assign-left variable&#34;&gt;bs&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;1M &lt;span class=&#34;token assign-left variable&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;token assign-left variable&#34;&gt;of&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;hd1.img &lt;span class=&#34;token operator&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; mkfs.ext2 hd1.img
phl@kernelnewbies:~/hds$ &lt;span class=&#34;token function&#34;&gt;dd&lt;/span&gt; &lt;span class=&#34;token assign-left variable&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;/dev/zero &lt;span class=&#34;token assign-left variable&#34;&gt;bs&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;1M &lt;span class=&#34;token assign-left variable&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;token assign-left variable&#34;&gt;of&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;hd2.img &lt;span class=&#34;token operator&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; mkfs.ext2 hd2.img

phl@kernelnewbies:~$ tree &lt;span class=&#34;token builtin class-name&#34;&gt;.&lt;/span&gt;
&lt;span class=&#34;token builtin class-name&#34;&gt;.&lt;/span&gt;
├── hd1
├── hd1.img
├── hd2
└── hd2.img
&lt;span class=&#34;token number&#34;&gt;2&lt;/span&gt; directories, &lt;span class=&#34;token number&#34;&gt;2&lt;/span&gt; files&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，我们在全局的 mount namespace 中挂载 hd1.img 到 hd1 目录，然后查看该 mount namespace 中的挂载点信息与 mount namespace id。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~/hds$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;mount&lt;/span&gt; hd1.img hd1
phl@kernelnewbies:~/hds$ &lt;span class=&#34;token function&#34;&gt;cat&lt;/span&gt; /proc/self/mountinfo &lt;span class=&#34;token operator&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;grep&lt;/span&gt; hd
&lt;span class=&#34;token number&#34;&gt;556&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;27&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;7&lt;/span&gt;:18 / /home/phl/hds/hd1 rw,relatime shared:372 - ext2 /dev/loop18 rw

phl@kernelnewbies:~/hds$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; readlink /proc/&lt;span class=&#34;token variable&#34;&gt;$$&lt;/span&gt;/ns/mnt
mnt:&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;4026531840&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，执行 unshare 命令创建一个新的 mount namespace 并查看该 mount namespace id 和挂载点信息。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~/hds$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; unshare --uts --mount /bin/bash
root@kernelnewbies:~/hds&lt;span class=&#34;token comment&#34;&gt;# cat /proc/self/mountinfo | grep hd&lt;/span&gt;
&lt;span class=&#34;token number&#34;&gt;739&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;570&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;7&lt;/span&gt;:18 / /home/phl/hds/hd1 rw,relatime - ext2 /dev/loop18 rw

root@kernelnewbies:~/hds&lt;span class=&#34;token comment&#34;&gt;# readlink /proc/$$/ns/mnt&lt;/span&gt;
mnt:&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;4026532180&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果我们可以看到，新 mount namespace 中的挂载点信息与全局 mountnamespace 中的挂载点信息基本一致，一些挂载选项（如传播状态）变化了。新的 mount namespace id 与全局 mount namespace id 是不一样的。&lt;/p&gt;
&lt;p&gt;然后，我们在新的 mount namespace 中挂载 hd2.img 到 hd2 目录，并查看挂载点信息。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;root@kernelnewbies:~/hds&lt;span class=&#34;token comment&#34;&gt;# mount hd2.img hd2&lt;/span&gt;
root@kernelnewbies:~/hds&lt;span class=&#34;token comment&#34;&gt;# cat /proc/self/mountinfo | grep hd&lt;/span&gt;
&lt;span class=&#34;token number&#34;&gt;739&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;570&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;7&lt;/span&gt;:18 / /home/phl/hds/hd1 rw,relatime - ext2 /dev/loop18 rw
&lt;span class=&#34;token number&#34;&gt;740&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;570&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;7&lt;/span&gt;:19 / /home/phl/hds/hd2 rw,relatime - ext2 /dev/loop19 rw&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果我们可以看到，新 mount namespace 中有 hd1 和 hd2 这两个挂载点。现在启动一个新的 Shell 窗口，查看全局 mount namespace 中的挂载点信息。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~/hds$ &lt;span class=&#34;token function&#34;&gt;cat&lt;/span&gt; /proc/self/mountinfo &lt;span class=&#34;token operator&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;grep&lt;/span&gt; hd
&lt;span class=&#34;token number&#34;&gt;556&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;27&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;7&lt;/span&gt;:18 / /home/phl/hds/hd1 rw,relatime shared:372 - ext2 /dev/loop18 rw&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果我们可以看到，全局 mount namespace 中的挂载点信息只有 hd1，而没有 hd2。这说明在新 mount namespace 中进行挂载 / 卸载操作不会影响其他 mount namespace 中的挂载点信息。&lt;/p&gt;
&lt;p&gt;mount namespace 只隔离挂载点信息，并不隔离挂载点下面的文件信息。对于多个 mount namespace 都能看到的挂载点，如果在一个 namespace 中修改了挂载点下面的文件，其他 namespace 也能感知到。下面，我们在新建的 mount namespace 中创建一个文件，命令如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;root@kernelnewbies:~/hds&lt;span class=&#34;token comment&#34;&gt;# echo hello from new mount namespace &amp;gt; hd1/hello.txt&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在新启动的 Shell 中，查看 hd1 目录并读取 hd1/hello.txt 文件。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~/hds$ tree hd1
hd1
├── hello.txt
└── lost+found &lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;error opening dir&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;
&lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt; directory, &lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;file&lt;/span&gt;

phl@kernelnewbies:~/hds$ &lt;span class=&#34;token function&#34;&gt;cat&lt;/span&gt; hd1/hello.txt
hello from new &lt;span class=&#34;token function&#34;&gt;mount&lt;/span&gt; namespace&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果我们可以看到，在全局 mount namespace 中，我们可以读取到在新建的 mount namespace 中创建的文件。&lt;/p&gt;
&lt;h4 id=&#34;1-3-5-docker-sh&#34;&gt;1.3.5.docker.sh&lt;/h4&gt;
&lt;p&gt;有了以上关于 mount namespace 的知识，我们就可以将 mount namespace 加入到 docker.sh 中了。mount namespace 将放在 docker.sh 中，带下划线的行是我们为实现 mount namespace 而修改的代码。修改后的 docker.sh 脚本如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&lt;span class=&#34;token punctuation&#34;&gt;..&lt;/span&gt;.
unshare --uts --mount ./container.sh&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从上述代码我们可以看到，我们仅仅是在调用 unshare 时加入 --mount 选项，就可为 docker.sh 引入了 mount namespace 功能。&lt;/p&gt;
&lt;h3 id=&#34;1-4-pid-namespace&#34;&gt;1.4.pid namespace&lt;/h3&gt;
&lt;h4 id=&#34;1-4-1-unshare的-fork选项&#34;&gt;1.4.1.unshare 的 --fork 选项&lt;/h4&gt;
&lt;p&gt;unshare 有一个选项 --fork，当执行 unshare 时，如果没有这个选项，unshare 会直接 exec 新命令，也就是说 unshare 变成了新命令。如果带有 --fork 选项，unshare 会 fork 一个子进程，该子进程 exec 新命令，unshare 是该子进程的父进程。我们分别不带 --fork 和带 --fork 来执行 unshare，然后查看进程之间的关系。&lt;/p&gt;
&lt;p&gt;首先，我们不带 --fork 选项执行 unshare，并查看当前 Shell 的进程 id。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; unshare --uts /bin/bash
root@kernelnewbies:~/hds&lt;span class=&#34;token comment&#34;&gt;# echo $$&lt;/span&gt;
&lt;span class=&#34;token number&#34;&gt;11699&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时 unshare 会创建一个新的 uts namespace，然后 exec /bin/bash。我们启动一个新 Shell，然后使用 pstree 查看进程间关系，命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~/hds$ pstree -p &lt;span class=&#34;token operator&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;grep&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;11699&lt;/span&gt;
sudo&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;11698&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;---bash&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;11699&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果我们可以看到，sudo fork 出一个子进程，该子进程执行 unshare。unshare 创建了新 uts namespace 后，exec 了 /bin/bash，也就是说 unshare 变成了 /bin/bash。&lt;/p&gt;
&lt;p&gt;然后，我们带 --fork 选项执行 unshare，并查看当前 Shell 的进程 id。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~/hds$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; unshare --uts --fork /bin/bash
root@kernelnewbies:~/hds&lt;span class=&#34;token comment&#34;&gt;# echo $$&lt;/span&gt;
&lt;span class=&#34;token number&#34;&gt;11866&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时 unshare 会创建一个新的 uts namespace，然后 fork 出一个子进程，该子进程 exec /bin/bash。我们启动一个新 Shell，然后使用 pstree 查看进程间关系，命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~/hds$ pstree -p &lt;span class=&#34;token operator&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;grep&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;11866&lt;/span&gt;
sudo&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;11864&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;---unshare&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;11865&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;---bash&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;11866&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果我们可以看到，sudo fork 出一个子进程，该子进程执行命令 unshare。unshare 创建了新 uts namespace 后，fork 出一个子进程，该子进程 exec /bin/bash，也就是说 unshare 变成了新的 /bin/bash 进程的父进程。&lt;/p&gt;
&lt;h4 id=&#34;1-4-2-pid-namespace简介&#34;&gt;1.4.2.pid namespace 简介&lt;/h4&gt;
&lt;p&gt;pid namespace 用来隔离进程 pid 空间，使得不同 pid namespace 里的进程 pid 可以重复且相互之间不影响。进程所属的 pid namespace 在创建的时候就确定了，无法更改，因此需要 --fork 选项来创建一个新进程，然后将该新进程加入新建的 pid namespace 中。pid namespace 在 unshare 中的选项为 --pid。&lt;/p&gt;
&lt;p&gt;unshare 在创建 pid namespace 时需同时提供 --pid 与 --fork 选项。unshare 本身会加入全局的 pid namespace，其 fork 出的子进程会加入新建的 pid namespace。&lt;/p&gt;
&lt;p&gt;首先，我们查看全局 pid namespace id，命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; readlink /proc/&lt;span class=&#34;token variable&#34;&gt;$$&lt;/span&gt;/ns/pid
pid:&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;4026531836&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，执行 unshare 命令创建一个新的 pid namespace 并查看该 pid namespace id。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; unshare --mount --pid --fork /bin/bash
root@kernelnewbies:~&lt;span class=&#34;token comment&#34;&gt;# readlink /proc/$$/ns/pid&lt;/span&gt;
pid:&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;4026531836&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果我们可以看到，新创建的进程也处于全局 pid namespace 中，而不是新的 pid namespace。&lt;/p&gt;
&lt;p&gt;出现这种情形是因为当前的 /proc 文件系统是老的。我们查看一下 $$ 的值，命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;root@kernelnewbies:~&lt;span class=&#34;token comment&#34;&gt;# echo $$&lt;/span&gt;
&lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果我们可以看到，$$ 的值为 1，但是 /proc 文件系统却是老的，因此我们查看的实际是 init 进程所属的 pid namespace，当然是全局 pid namespace 了。&lt;/p&gt;
&lt;p&gt;重新挂载 /proc 文件系统，这也是 unshare 执行时带 --mount 选项的原因，只有这样，重新挂载 /proc 文件系统时，不会搞乱整个系统。再次查看新进程所属的 pid namespace，命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;root@kernelnewbies:~&lt;span class=&#34;token comment&#34;&gt;# mount -t proc proc /proc&lt;/span&gt;
root@kernelnewbies:~&lt;span class=&#34;token comment&#34;&gt;# readlink /proc/$$/ns/pid&lt;/span&gt;
pid:&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;4026532182&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果我们可以看到，新进程的 pid namespace 与全局 pid namespace 的 id 不同。&lt;/p&gt;
&lt;p&gt;接下来，我们再来查看一下新 pid namespace 中的进程信息。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;root@kernelnewbies:~&lt;span class=&#34;token comment&#34;&gt;# ps -ef&lt;/span&gt;
&lt;span class=&#34;token environment constant&#34;&gt;UID&lt;/span&gt;        PID  &lt;span class=&#34;token environment constant&#34;&gt;PPID&lt;/span&gt;  C STIME TTY          TIME CMD
root         &lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt;     &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;  &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;19&lt;/span&gt;:03 pts/1    00:00:00 /bin/bash
root        &lt;span class=&#34;token number&#34;&gt;10&lt;/span&gt;     &lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt;  &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;19&lt;/span&gt;:03 pts/1    00:00:00 &lt;span class=&#34;token function&#34;&gt;ps&lt;/span&gt; -e&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果我们可以看到，当前 pid namespace 中只有 2 个进程，看不到全局 pid namespace 里面的其他进程。我们通过 unshare 执行的进程 pid 为 1，也就是说该进程成了新 pid namespace 中的 init 进程。&lt;/p&gt;
&lt;h4 id=&#34;1-4-3-pid嵌套&#34;&gt;1.4.3.pid 嵌套&lt;/h4&gt;
&lt;p&gt;pid namespace 可以嵌套，也就是说有父子关系，在当前 pid namespace 里面创建的所有新的 pid namespace 都是当前 pid namespace 的子 pid namespace。&lt;/p&gt;
&lt;p&gt;首先，我们创建 3 个嵌套的 pid namespace，并查看每个 pid namespace id。--mount-proc 选项用于自动挂载 /proc 文件系统，省去了手动挂载 /proc 文件系统的操作。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; readlink /proc/&lt;span class=&#34;token variable&#34;&gt;$$&lt;/span&gt;/ns/pid
pid:&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;4026531836&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;

phl@kernelnewbies:~$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; unshare --uts --mount --pid --mount-proc --fork /bin/bash
root@kernelnewbies:~&lt;span class=&#34;token comment&#34;&gt;# readlink /proc/$$/ns/pid&lt;/span&gt;
pid:&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;4026532182&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;

root@kernelnewbies:~&lt;span class=&#34;token comment&#34;&gt;# unshare --uts --mount --pid --mount-proc --fork /bin/bash&lt;/span&gt;
root@kernelnewbies:~&lt;span class=&#34;token comment&#34;&gt;# readlink /proc/$$/ns/pid&lt;/span&gt;
pid:&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;4026532185&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;

root@kernelnewbies:~&lt;span class=&#34;token comment&#34;&gt;# unshare --uts --mount --pid --mount-proc --fork /bin/bash&lt;/span&gt;
root@kernelnewbies:~&lt;span class=&#34;token comment&#34;&gt;# readlink /proc/$$/ns/pid&lt;/span&gt;
pid:&lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;4026532188&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，我们启动一个新 Shell，然后使用 pstree 查看进程间关系。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~$ pstree -lp &lt;span class=&#34;token operator&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;grep&lt;/span&gt; unshare
sudo&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;12547&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;---unshare&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;12548&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;---bash&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;12549&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;---unshare&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;12579&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;---bash&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;12580&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;---unshare&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;12593&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;---bash&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;12594&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 cat /proc/[pid]/status | grep NSpid 可查看某进程在当前 pid namespace 及子孙 pid namespace 中的 pid。我们在全局 pid namespace 中查看上述各进程在各 pid namespace 中的 pid，命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~$ &lt;span class=&#34;token function&#34;&gt;cat&lt;/span&gt; /proc/12594/status &lt;span class=&#34;token operator&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;grep&lt;/span&gt; NSpid
NSpid: &lt;span class=&#34;token number&#34;&gt;12594&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;21&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;11&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt;

phl@kernelnewbies:~$ &lt;span class=&#34;token function&#34;&gt;cat&lt;/span&gt; /proc/12593/status &lt;span class=&#34;token operator&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;grep&lt;/span&gt; NSpid
NSpid: &lt;span class=&#34;token number&#34;&gt;12593&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;20&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;10&lt;/span&gt;

phl@kernelnewbies:~$ &lt;span class=&#34;token function&#34;&gt;cat&lt;/span&gt; /proc/12580/status &lt;span class=&#34;token operator&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;grep&lt;/span&gt; NSpid
NSpid: &lt;span class=&#34;token number&#34;&gt;12580&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;11&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt;

phl@kernelnewbies:~$ &lt;span class=&#34;token function&#34;&gt;cat&lt;/span&gt; /proc/12579/status &lt;span class=&#34;token operator&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;grep&lt;/span&gt; NSpid
NSpid: &lt;span class=&#34;token number&#34;&gt;12579&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;10&lt;/span&gt;

phl@kernelnewbies:~$ &lt;span class=&#34;token function&#34;&gt;cat&lt;/span&gt; /proc/12549/status &lt;span class=&#34;token operator&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;grep&lt;/span&gt; NSpid
NSpid: &lt;span class=&#34;token number&#34;&gt;12549&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面我们将以上进程在各 pid namespace 中的 pid，整理成表格。表格信息如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2022/03/1820220318143156.png&#34; alt=&#34;使用 Shell 脚本实现 Docker&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们以最后一行为例进行介绍，最后一行有 4 个 pid，这 4 个 pid 其实是同一个进程。这个进程在 4 个 pid namespace 中都可以被看到，且其在 4 个 pid namespace 中的 pid 各不相同。&lt;/p&gt;
&lt;h4 id=&#34;1-4-4-docker-sh&#34;&gt;1.4.4.docker.sh&lt;/h4&gt;
&lt;p&gt;有了以上关于 pid namespace 的知识，我们就可以将 pid namespae 加入到 docker.sh 中了。pid namespace 将放在 docker.sh 中，带下划线的行是我们为实现 pid namespace 而修改的代码。修改后的 docker.sh 脚本如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&lt;span class=&#34;token punctuation&#34;&gt;..&lt;/span&gt;.
unshare --uts --mount --pid --fork ./container.sh&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从上述代码我们可以看到，我们仅仅是在调用 unshare 时加入 --pid 和 --fork 选项，就可为 docker.sh 引入了 pid namespace 功能。&lt;/p&gt;
&lt;p&gt;然后，我们需要重新挂载 /proc 文件系统。重新挂载 /proc 文件系统的功能将放在 container.sh 中，带下划线的行是我们为重新挂载 /proc 文件系统而新添的代码。修改后的 container.sh 脚本如下如下所示：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&lt;span class=&#34;token function&#34;&gt;hostname&lt;/span&gt; &lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;
&lt;span class=&#34;token function&#34;&gt;mount&lt;/span&gt; -t proc proc /proc
&lt;span class=&#34;token builtin class-name&#34;&gt;exec&lt;/span&gt; &lt;span class=&#34;token variable&#34;&gt;$program&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在，我们运行 docker.sh，并查看当前的进程信息。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~/docker.sh$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; ./docker.sh -c run -m 100M -C dreamland -I ubuntu1604 -V data1 -P /bin/bash
root@dreamland:~/docker.sh&lt;span class=&#34;token comment&#34;&gt;# ps -ef&lt;/span&gt;
&lt;span class=&#34;token environment constant&#34;&gt;UID&lt;/span&gt;        PID  &lt;span class=&#34;token environment constant&#34;&gt;PPID&lt;/span&gt;  C STIME TTY          TIME CMD
root         &lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt;     &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;  &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;17&lt;/span&gt;:31 pts/1    00:00:00 /bin/bash
root        &lt;span class=&#34;token number&#34;&gt;16&lt;/span&gt;     &lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt;  &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;17&lt;/span&gt;:31 pts/1    00:00:00 &lt;span class=&#34;token function&#34;&gt;ps&lt;/span&gt; -ef&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果我们可看出，当前进程只有两个，不再有主机上的其他进程。&lt;/p&gt;
&lt;h2 id=&#34;2-CGroups&#34;&gt;2.CGroups&lt;/h2&gt;
&lt;h3 id=&#34;2-1-CGroups简介&#34;&gt;2.1.CGroups 简介&lt;/h3&gt;
&lt;p&gt;CGroups 是一种将进程分组，并以组为单位对进程实施资源限制的技术。每个组都包含以下几类信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程列表&lt;/li&gt;
&lt;li&gt;资源 A 限制&lt;/li&gt;
&lt;li&gt;资源 B 限制&lt;/li&gt;
&lt;li&gt;资源 C 限制&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们将以常见的 CPU 资源及内存资源为例进行介绍。以下的信息将使进程号为 1001、1002、2008、3306 的四个进程总共只能使用一个 CPU 核心；总共最多使用 25% 的 CPU 资源；总共最多使用 100M 内存，这样的一个分组被称为 cgroup。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2022/03/1820220318143103.png&#34; alt=&#34;使用 Shell 脚本实现 Docker&#34;&gt;&lt;/p&gt;
&lt;p&gt;上面的介绍只是说明了要将何种资源限制施加于哪些进程，并未说明资源限制是如何施加到进程上。具体施加资源限制的过程需要 subsystem 来帮忙。subsystem 读取 cgroup 中的资源限制和进程列表，然后将这些资源限制施加到这些进程上。常见的 subsystem 包括如下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cpu&lt;/li&gt;
&lt;li&gt;memory&lt;/li&gt;
&lt;li&gt;pids&lt;/li&gt;
&lt;li&gt;devices&lt;/li&gt;
&lt;li&gt;blkio&lt;/li&gt;
&lt;li&gt;net_cls&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个 subsystem 只读取与其相关的资源限制，然后施加到进程上。例如：memory 子系统只读取内存限制，而 cpu 子系统只读取 cpu 限制。&lt;/p&gt;
&lt;p&gt;cgroup 被组织成树，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2022/03/1820220318143057.png&#34; alt=&#34;使用 Shell 脚本实现 Docker&#34;&gt;&lt;/p&gt;
&lt;p&gt;采用树状结构可以方便地实现资源限制继承，一个 cgroup 中的资源限制将作用于该 cgroup 及其子孙 cgroup 中的进程。例如：图中 13001、10339、2999 受到 A、B、C、D 四个 cgroup 中的资源限制。这样的一个树状结构被称为 hierarchy。&lt;/p&gt;
&lt;p&gt;hierarchy 中包含了系统中所有的进程，它们分布于各个 cgroup 中。在 hierarchy 中，一个进程必须属于且只属于一个 cgroup，这样才能保证对进程施加的资源限制不会遗漏也不会冲突。&lt;/p&gt;
&lt;p&gt;要想让一个 subsystem 读取 hierarchy 中各 cgroup 的资源限制，并施加于其中的进程需要将 subsystem 和 hierarchy 关联起来。subsystem 与 hierarchy 的关系如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统中可以有多个 hierarchy&lt;/li&gt;
&lt;li&gt; 一个 hierarchy 可以关联 0 个或多个 subsystem，当关联 0 个 subsystem 时，该 hierarchy 只是对进程进行分类&lt;/li&gt;
&lt;li&gt;一个 subsystem 最多关联到一个 hierarchy，因为每个 hierarchy 都包含系统中所有的进程，若一个 subsystem 关联到了多个 hierarchy，对同一进程将有多种资源限制，这是不对的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;系统使用 CGroups 通常有两种形式：一种是创建一个 hierarchy，将所有的 subsystem 关联到其上，在这个 hierarchy 上配置各种资源限制；另一种是为每一个 subsystem 创建一个 hierarchy，并将该 subsystem 关联到其上，每个 hierarchy 只对一种资源进行限制。后一种比较清晰，得到了更普遍的采用。&lt;/p&gt;
&lt;p&gt;CGroups 不像大多数的技术那样提供 API 或命令之类的用户接口，而是提供给用户一个虚拟文件系统，该虚拟文件系统类型为 cgroup。一个挂载后的 cgroup 文件系统就是一个 hierarchy，文件系统中的一个目录就是一个 cgroup，目录中的文件代表了进程列表或者资源限制信息。文件系统是树状结构，其各个目录之间的父子关系就代表了 cgroup 之间的继承关系。挂载 cgroup 虚拟文件系统后，通过在该文件系统上创建目录、写进程列表文件、写资源限制文件就可以操作 CGroups。&lt;/p&gt;
&lt;p&gt;下面，我们通过实验学习一下 CGroups 的用法。首先，我们挂载一个 cgroup 虚拟文件系统，该文件系统不与任何 subsystem 关联，仅仅是将进程进行分类。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~$ &lt;span class=&#34;token function&#34;&gt;mkdir&lt;/span&gt; -p cg/test
&lt;span class=&#34;token comment&#34;&gt;# -o none,name=test 表示该cgroup文件系统不与任何子系统关联&lt;/span&gt;
&lt;span class=&#34;token comment&#34;&gt;# 该文件系统用name=test来标识&lt;/span&gt;
phl@kernelnewbies:~$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;mount&lt;/span&gt; -t cgroup -o none,name&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;test &lt;span class=&#34;token builtin class-name&#34;&gt;test&lt;/span&gt; cg/test
phl@kernelnewbies:~$ tree cg/test
cg/test
├── cgroup.clone_children
├── cgroup.procs
├── cgroup.sane_behavior
├── notify_on_release
├── release_agent
└── tasks
&lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt; directories, &lt;span class=&#34;token number&#34;&gt;6&lt;/span&gt; files&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;挂载 cgroup 文件系统后，该 cgroup 文件系统的根目录下会生成许多文件，该根目录被称为 root cgroup。cgroup.procs 里面存放的是当前 cgroup 中的所有进程 id，由于该 hierarchy 中只有一个 cgroup，所以这个文件包含了系统中所有的进程 id。其他的文件与 cgroups 基本功能关系不大，暂时可以忽略。&lt;/p&gt;
&lt;p&gt;在 cgroup 文件系统中，创建一个目录就会创建一个 cgroup。下面我们将会演示如何创建下面这样的 hierarchy：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2022/03/1820220318143054.png&#34; alt=&#34;使用 Shell 脚本实现 Docker&#34;&gt;&lt;/p&gt;
&lt;p&gt;命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;mkdir&lt;/span&gt; -p cg/test/test1/test11
phl@kernelnewbies:~$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;mkdir&lt;/span&gt; -p cg/test/test2/test22
phl@kernelnewbies:~$ tree cg/test
cg/test
├── cgroup.clone_children
├── cgroup.procs
├── cgroup.sane_behavior
├── notify_on_release
├── release_agent
├── tasks
├── test1
│   ├── cgroup.clone_children
│   ├── cgroup.procs
│   ├── notify_on_release
│   ├── tasks
│   └── test11
│       ├── cgroup.clone_children
│       ├── cgroup.procs
│       ├── notify_on_release
│       └── tasks
└── test2
    ├── cgroup.clone_children
    ├── cgroup.procs
    ├── notify_on_release
    ├── tasks
    └── test22
        ├── cgroup.clone_children
        ├── cgroup.procs
        ├── notify_on_release
        └── tasks

&lt;span class=&#34;token number&#34;&gt;4&lt;/span&gt; directories, &lt;span class=&#34;token number&#34;&gt;22&lt;/span&gt; files&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果我们可以看到，我们创建了相应的目录后，这些目录下自动出现了包含 cgroup 信息的目录及文件。&lt;/p&gt;
&lt;p&gt;删除 cgroup 时只需删除该 cgroup 所在的目录即可。下面我们将删除 test11 cgroup，命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;rmdir&lt;/span&gt; cg/test/test1/test11
phl@kernelnewbies:~$ tree cg/test
cg/test
├── cgroup.clone_children
├── cgroup.procs
├── cgroup.sane_behavior
├── notify_on_release
├── release_agent
├── tasks
├── test1
│   ├── cgroup.clone_children
│   ├── cgroup.procs
│   ├── notify_on_release
│   └── tasks
└── test2
    ├── cgroup.clone_children
    ├── cgroup.procs
    ├── notify_on_release
    ├── tasks
    └── test22
        ├── cgroup.clone_children
        ├── cgroup.procs
        ├── notify_on_release
        └── tasks

&lt;span class=&#34;token number&#34;&gt;3&lt;/span&gt; directories, &lt;span class=&#34;token number&#34;&gt;18&lt;/span&gt; files&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每个 cgroup 下面都有一个 cgroup.procs 文件，该文件里面包含当前 cgroup 里面的所有进程 id。只要将某个进程的 id 写入该文件，即可将该进程加入到该 cgroup 中。下面，我们将当前的 bash 加入到 test22 cgroup 中，命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~$ &lt;span class=&#34;token builtin class-name&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;token variable&#34;&gt;$$&lt;/span&gt;
&lt;span class=&#34;token number&#34;&gt;3894&lt;/span&gt;
phl@kernelnewbies:~$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;sh&lt;/span&gt; -c &lt;span class=&#34;token string&#34;&gt;&#34;echo 3894 &amp;gt; cg/test/test2/test22/cgroup.procs&#34;&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;/proc/[pid]/cgroup 包含了某个进程所在的 cgroup 信息。下面，我们查看一下当前 bash 进程所在的 cgroup 信息，命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~$ &lt;span class=&#34;token function&#34;&gt;cat&lt;/span&gt; /proc/3894/cgroup
&lt;span class=&#34;token number&#34;&gt;13&lt;/span&gt;:name&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;test:/test2/test22
&lt;span class=&#34;token number&#34;&gt;12&lt;/span&gt;:freezer:/
&lt;span class=&#34;token number&#34;&gt;11&lt;/span&gt;:perf_event:/
&lt;span class=&#34;token number&#34;&gt;10&lt;/span&gt;:blkio:/user.slice
&lt;span class=&#34;token number&#34;&gt;9&lt;/span&gt;:devices:/user.slice
&lt;span class=&#34;token number&#34;&gt;8&lt;/span&gt;:hugetlb:/
&lt;span class=&#34;token number&#34;&gt;7&lt;/span&gt;:cpu,cpuacct:/user.slice
&lt;span class=&#34;token number&#34;&gt;6&lt;/span&gt;:net_cls,net_prio:/
&lt;span class=&#34;token number&#34;&gt;5&lt;/span&gt;:memory:/user.slice
&lt;span class=&#34;token number&#34;&gt;4&lt;/span&gt;:rdma:/
&lt;span class=&#34;token number&#34;&gt;3&lt;/span&gt;:pids:/user.slice/user-1001.slice/session-4.scope
&lt;span class=&#34;token number&#34;&gt;2&lt;/span&gt;:cpuset:/
&lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt;:name&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;systemd:/user.slice/user-1001.slice/session-4.scope
&lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;::/user.slice/user-1001.slice/session-4.scope&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果我们可以看到，当前 bash 进程加入了多个 cgroup，其中带下划线的行为我们刚刚加入的 cgroup。&lt;/p&gt;
&lt;p&gt;要想将 hierarchy 与子系统关联起来，需要在 - o 选项中指定子系统名称。下面演示了如何将 memory 子系统与新挂载的 cgroup 文件系统关联起来。代码如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;mkdir&lt;/span&gt; cg/memory
phl@kernelnewbies:~$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;mount&lt;/span&gt; -t cgroup -o memory memcg cg/memory&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于很多发行版的操作系统已经为我们配置好了这些 cgroup 文件系统，我们应当直接使用这些已经挂在好的文件系统，不需要自己去挂载。&lt;/p&gt;
&lt;p&gt;另外，当创建子进程时，子进程会自动加入父进程所在的 cgroup。&lt;/p&gt;
&lt;h3 id=&#34;2-2-限制内存&#34;&gt;2.2. 限制内存&lt;/h3&gt;
&lt;h4 id=&#34;2-2-1-用CGroups限制内存&#34;&gt;2.2.1. 用 CGroups 限制内存&lt;/h4&gt;
&lt;p&gt;下面我们将介绍演示 CGroups 如何限制进程使用的内存资源，我们以内存为例进行讲解。&lt;/p&gt;
&lt;p&gt;Ubuntu18.04 已经为我们挂载了一个关联 memory 子系统的 cgroup 虚拟文件系统。我们用 mount 命令查看一下该系统挂载到了何处，命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~$ &lt;span class=&#34;token function&#34;&gt;mount&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;grep&lt;/span&gt; cgroup
tmpfs on /sys/fs/cgroup &lt;span class=&#34;token builtin class-name&#34;&gt;type&lt;/span&gt; tmpfs &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;ro,nosuid,nodev,noexec,mode&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;755&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;
cgroup on /sys/fs/cgroup/unified &lt;span class=&#34;token builtin class-name&#34;&gt;type&lt;/span&gt; cgroup2 &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;rw,nosuid,nodev,noexec,relatime,nsdelegate&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;
cgroup on /sys/fs/cgroup/systemd &lt;span class=&#34;token builtin class-name&#34;&gt;type&lt;/span&gt; cgroup &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;rw,nosuid,nodev,noexec,relatime,xattr,name&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;systemd&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;
cgroup on /sys/fs/cgroup/cpuset &lt;span class=&#34;token builtin class-name&#34;&gt;type&lt;/span&gt; cgroup &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;rw,nosuid,nodev,noexec,relatime,cpuset&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;
cgroup on /sys/fs/cgroup/pids &lt;span class=&#34;token builtin class-name&#34;&gt;type&lt;/span&gt; cgroup &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;rw,nosuid,nodev,noexec,relatime,pids&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;
cgroup on /sys/fs/cgroup/rdma &lt;span class=&#34;token builtin class-name&#34;&gt;type&lt;/span&gt; cgroup &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;rw,nosuid,nodev,noexec,relatime,rdma&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;
cgroup on /sys/fs/cgroup/memory &lt;span class=&#34;token builtin class-name&#34;&gt;type&lt;/span&gt; cgroup &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;rw,nosuid,nodev,noexec,relatime,memory&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;
cgroup on /sys/fs/cgroup/net_cls,net_prio &lt;span class=&#34;token builtin class-name&#34;&gt;type&lt;/span&gt; cgroup &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;rw,nosuid,nodev,noexec,relatime,net_cls,net_prio&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;
cgroup on /sys/fs/cgroup/cpu,cpuacct &lt;span class=&#34;token builtin class-name&#34;&gt;type&lt;/span&gt; cgroup &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;rw,nosuid,nodev,noexec,relatime,cpu,cpuacct&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;
cgroup on /sys/fs/cgroup/hugetlb &lt;span class=&#34;token builtin class-name&#34;&gt;type&lt;/span&gt; cgroup &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;rw,nosuid,nodev,noexec,relatime,hugetlb&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;
cgroup on /sys/fs/cgroup/devices &lt;span class=&#34;token builtin class-name&#34;&gt;type&lt;/span&gt; cgroup &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;rw,nosuid,nodev,noexec,relatime,devices&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;
cgroup on /sys/fs/cgroup/blkio &lt;span class=&#34;token builtin class-name&#34;&gt;type&lt;/span&gt; cgroup &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;rw,nosuid,nodev,noexec,relatime,blkio&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;
cgroup on /sys/fs/cgroup/perf_event &lt;span class=&#34;token builtin class-name&#34;&gt;type&lt;/span&gt; cgroup &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;rw,nosuid,nodev,noexec,relatime,perf_event&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;
cgroup on /sys/fs/cgroup/freezer &lt;span class=&#34;token builtin class-name&#34;&gt;type&lt;/span&gt; cgroup &lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;rw,nosuid,nodev,noexec,relatime,freezer&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该系统挂载到了 /sys/fs/cgroup/memory 目录下。我们在该 hierarchy 中创建一个 test cgroup 并查看该 cgroup 的目录结构，命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;mkdir&lt;/span&gt; /sys/fs/cgroup/memory/test
phl@kernelnewbies:~$ tree /sys/fs/cgroup/memory/test
/sys/fs/cgroup/memory/test
├── cgroup.clone_children
├── cgroup.event_control
├── cgroup.procs
├── memory.failcnt
├── memory.force_empty
├── memory.kmem.failcnt
├── memory.kmem.limit_in_bytes
├── memory.kmem.max_usage_in_bytes
├── memory.kmem.slabinfo
├── memory.kmem.tcp.failcnt
├── memory.kmem.tcp.limit_in_bytes
├── memory.kmem.tcp.max_usage_in_bytes
├── memory.kmem.tcp.usage_in_bytes
├── memory.kmem.usage_in_bytes
├── memory.limit_in_bytes
├── memory.max_usage_in_bytes
├── memory.move_charge_at_immigrate
├── memory.numa_stat
├── memory.oom_control
├── memory.pressure_level
├── memory.soft_limit_in_bytes
├── memory.stat
├── memory.swappiness
├── memory.usage_in_bytes
├── memory.use_hierarchy
├── notify_on_release
└── tasks
&lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt; directories, &lt;span class=&#34;token number&#34;&gt;27&lt;/span&gt; files&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果我们可以看到，新建的 test cgroup 中有许多文件，这些文件中存放着资源限制信息。其中 memory.limit_in_bytes 里面存放的是该 cgroup 中的进程能够使用的内存额度。&lt;/p&gt;
&lt;p&gt;下面，我们将当前 bash 加入到 test cgroup 中并查看当前 bash 所属的 cgroup 信息。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~$ &lt;span class=&#34;token builtin class-name&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;token variable&#34;&gt;$$&lt;/span&gt;
&lt;span class=&#34;token number&#34;&gt;2984&lt;/span&gt;
phl@kernelnewbies:~$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;sh&lt;/span&gt; -c &lt;span class=&#34;token string&#34;&gt;&#34;echo 2984 &amp;gt; /sys/fs/cgroup/memory/test/cgroup.procs&#34;&lt;/span&gt;
phl@kernelnewbies:~$ &lt;span class=&#34;token function&#34;&gt;cat&lt;/span&gt; /proc/2984/cgroup
&lt;span class=&#34;token number&#34;&gt;12&lt;/span&gt;:devices:/user.slice
&lt;span class=&#34;token number&#34;&gt;11&lt;/span&gt;:hugetlb:/
&lt;span class=&#34;token number&#34;&gt;10&lt;/span&gt;:memory:/test
&lt;span class=&#34;token number&#34;&gt;9&lt;/span&gt;:rdma:/
&lt;span class=&#34;token number&#34;&gt;8&lt;/span&gt;:perf_event:/
&lt;span class=&#34;token number&#34;&gt;7&lt;/span&gt;:blkio:/user.slice
&lt;span class=&#34;token number&#34;&gt;6&lt;/span&gt;:cpu,cpuacct:/user.slice
&lt;span class=&#34;token number&#34;&gt;5&lt;/span&gt;:pids:/user.slice/user-1001.slice/session-4.scope
&lt;span class=&#34;token number&#34;&gt;4&lt;/span&gt;:freezer:/
&lt;span class=&#34;token number&#34;&gt;3&lt;/span&gt;:cpuset:/
&lt;span class=&#34;token number&#34;&gt;2&lt;/span&gt;:net_cls,net_prio:/
&lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt;:name&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;systemd:/user.slice/user-1001.slice/session-4.scope
&lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;::/user.slice/user-1001.slice/session-4.scope&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果我们可以看到，当前 bash 所属的 memory cgroup 变为了 /test，该目录为一个相对于 root cgroup 的相对路径。&lt;/p&gt;
&lt;p&gt;然后，将 100M 写入 test cgroup 中的 memory.limit_in_bytes 文件中，命令如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;sh&lt;/span&gt; -c &lt;span class=&#34;token string&#34;&gt;&#34;echo 100M &amp;gt; /sys/fs/cgroup/memory/test/memory.limit_in_bytes&#34;&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们在当前 bash 中启动一个占用 300M 进程的 stress 进程，该 stress 进程是 bash 的子进程，其与 bash 进程都在 test cgroup 中。命令如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~$ stress --vm &lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt; --vm-bytes 300M --vm-keep&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动一个新的 Shell 窗口，执行 top 命令查看 stress 进程占用的内存。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;PID &lt;span class=&#34;token environment constant&#34;&gt;USER&lt;/span&gt;      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND
&lt;span class=&#34;token number&#34;&gt;14216&lt;/span&gt; root      &lt;span class=&#34;token number&#34;&gt;20&lt;/span&gt;   &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;  &lt;span class=&#34;token number&#34;&gt;315440&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;101224&lt;/span&gt;    &lt;span class=&#34;token number&#34;&gt;264&lt;/span&gt; D &lt;span class=&#34;token number&#34;&gt;27.7&lt;/span&gt;  &lt;span class=&#34;token number&#34;&gt;2.5&lt;/span&gt;   &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;:02.66 stress&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果我们可以看到，stress 进程占用了 2.5% 的内存。我的电脑的内存为 4G，4G * 2.5% = 100M，stress 进程确实受到了 cgroup 中设置的内存额度的限制。&lt;/p&gt;
&lt;h4 id=&#34;2-2-2-docker-sh&#34;&gt;2.2.2.docker.sh&lt;/h4&gt;
&lt;p&gt;下有了以上关于 CGroups 的知识，我们就可以将限制内存的功能加入到 docker.sh 中了。限制内存的功能将放在 container.sh 中，带下划线的行是我们为实现限制内存而新添的代码。修改后的 container.sh 脚本如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&lt;span class=&#34;token function&#34;&gt;hostname&lt;/span&gt; &lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;
&lt;span class=&#34;token function&#34;&gt;mkdir&lt;/span&gt; -p /sys/fs/cgroup/memory/&lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;
&lt;span class=&#34;token builtin class-name&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;token variable&#34;&gt;$$&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;&amp;gt;&lt;/span&gt; /sys/fs/cgroup/memory/&lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;/cgroup.procs
&lt;span class=&#34;token builtin class-name&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;token variable&#34;&gt;$memory&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;&amp;gt;&lt;/span&gt; /sys/fs/cgroup/memory/&lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;/memory.limit_in_bytes
&lt;span class=&#34;token function&#34;&gt;mount&lt;/span&gt; -t proc proc /proc
&lt;span class=&#34;token builtin class-name&#34;&gt;exec&lt;/span&gt; &lt;span class=&#34;token variable&#34;&gt;$program&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先，我们根据容器的名字创建 cgroup，命令如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&lt;span class=&#34;token function&#34;&gt;mkdir&lt;/span&gt; -p /sys/fs/cgroup/memory/&lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，我们将当前 bash 加入到我们创建的 cgroup 中，命令如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&lt;span class=&#34;token builtin class-name&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;token variable&#34;&gt;$$&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;&amp;gt;&lt;/span&gt; /sys/fs/cgroup/memory/&lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;/cgroup.procs&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后，我们将内存限制写入新 cgroup 的 memory.limit_in_bytes 文件中，命令如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&lt;span class=&#34;token builtin class-name&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;token variable&#34;&gt;$memory&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;&amp;gt;&lt;/span&gt; /sys/fs/cgroup/memory/&lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;/memory.limit_in_bytes&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在，我们运行 docker.sh，并启动一个占用 300M 进程的 stress 进程。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~/docker.sh$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; ./docker.sh -c run -m 100M -C dreamland -I ubuntu1604 -V data1 -P /bin/bash
root@dreamland:~/docker.sh&lt;span class=&#34;token comment&#34;&gt;# stress --vm 1 --vm-bytes 300M --vm-keep&lt;/span&gt;
stress: info: &lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;12&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt; dispatching hogs: &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt; cpu, &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt; io, &lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt; vm, &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt; hdd&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动一个新的 Shell 窗口，执行 top 命令查看 stress 进程占用的内存。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;PID &lt;span class=&#34;token environment constant&#34;&gt;USER&lt;/span&gt;      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND
&lt;span class=&#34;token number&#34;&gt;14216&lt;/span&gt; root      &lt;span class=&#34;token number&#34;&gt;20&lt;/span&gt;   &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;  &lt;span class=&#34;token number&#34;&gt;315440&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;101224&lt;/span&gt;    &lt;span class=&#34;token number&#34;&gt;264&lt;/span&gt; D &lt;span class=&#34;token number&#34;&gt;27.7&lt;/span&gt;  &lt;span class=&#34;token number&#34;&gt;2.5&lt;/span&gt;   &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;:02.66 stress&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果我们可以看到，容器内的 stress 进程只使用了 100M 的内存。&lt;/p&gt;
&lt;h2 id=&#34;3-切换根文件系统&#34;&gt;3. 切换根文件系统&lt;/h2&gt;
&lt;h3 id=&#34;3-1-根文件系统&#34;&gt;3.1. 根文件系统&lt;/h3&gt;
&lt;p&gt;在容器技术中，根文件系统可为容器进程提供一个与主机不一致的文件系统环境。举个例子，主机为 Ubuntu 18.04，创建的容器采用 Ubuntu 16.04 的根文件系统，那么容器运行时所用的软件及其依赖库、配置文件等都是 Ubuntu 16.04 的。尽管该容器使用的内核是仍旧是 Ubuntu 18.04 的，但应用软件的表现却与 Ubuntu 16.04 一致，从虚拟化的角度来说该容器就是一个 Ubuntu 16.04 系统。&lt;/p&gt;
&lt;p&gt;debootstrap 是 Ubuntu 下的一个工具，用来构建根文件系统。生成的目录符合 Linux 文件系统标准，即包含了 /boot、/etc、/bin、/usr 等目录。debootstrap 的安装命令如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;apt&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;install&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;debootstrap&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面我们通过 debootstrap 构建 Ubuntu 16.04 的根文件系统。为了清晰，我们在 images 目录下生成根文件系统。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~/docker.sh$ &lt;span class=&#34;token function&#34;&gt;mkdir&lt;/span&gt; images
phl@kernelnewbies:~/docker.sh$ &lt;span class=&#34;token builtin class-name&#34;&gt;cd&lt;/span&gt; images
phl@kernelnewbies:~/docker.sh/images$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;debootstrap&lt;/span&gt; --arch amd64 xenial ./ubuntu1604&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;制作根文件系统需要从服务器下载很多文件，很耗时，请耐心等待。当文件系统制作好后，可以使用 tree 命令查看生成的根文件系统。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~/docker.sh/images$ tree -L &lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt; ubuntu1604/
ubuntu1604/
├── bin
├── boot
├── dev
├── etc
├── home
├── lib
├── lib64
├── media
├── mnt
├── old_root
├── opt
├── proc
├── root
├── run
├── sbin
├── srv
├── sys
├── tmp
├── usr
└── var
&lt;span class=&#34;token number&#34;&gt;20&lt;/span&gt; directories, &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt; files&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个根文件系统与 Linux 系统目录很相近，我们后续的实验将使用该根文件系统。&lt;/p&gt;
&lt;h3 id=&#34;3-2-pivot-root&#34;&gt;3.2.pivot_root&lt;/h3&gt;
&lt;p&gt;pivot_root 命令用于切换根文件系统，其使用方式如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;pivot_root new_root put_old&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;pivot_root 将当前进程的根文件系统移至 put_old 目录并使 new_root 目录成为新的根文件系统。&lt;/p&gt;
&lt;p&gt;下面我们将通过实验学习 pivot_root 的使用方法。为了简单，我们在一个新的 mount namespace 下进行实验。首先，我们创建一个新的 mount namespace，命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~/docker.sh/images$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; unshare --mount /bin/bash
root@kernelnewbies:~/docker.sh/images&lt;span class=&#34;token comment&#34;&gt;#&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在我们的实验中，我们的根文件系统将挂载在 ubuntu1604 目录，而老的根文件系统将被移动到 ubuntu1604/old_root 目录下。我们先创建 old_root 目录，命令如下：&lt;/p&gt;
&lt;p&gt;root@kernelnewbies:~/docker.sh/images# mkdir -p ubuntu1604/old_root/&lt;/p&gt;
&lt;p&gt;由于 pivot_root 命令要求老的根目录和新的根目录不能在同一个挂载点下，因此我们通过 bind mount 将 ubuntu1604 目录变成一个挂载点。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;root@kernelnewbies:~/docker.sh/images&lt;span class=&#34;token comment&#34;&gt;# mount --bind ubuntu1604 ubuntu1604&lt;/span&gt;
root@kernelnewbies:~/docker.sh/images&lt;span class=&#34;token comment&#34;&gt;# cat /proc/self/mountinfo | grep ubuntu1604&lt;/span&gt;
&lt;span class=&#34;token number&#34;&gt;624&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;382&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;8&lt;/span&gt;:1 /home/phl/docker.sh/images/ubuntu1604 /home/phl/docker.sh/images/ubuntu1604 rw,relatime - ext4 /dev/sda1 rw,errors&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;remount-ro&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;准备好切换根文件系统所需要的条件后，我们调用 pivot_root 切换根文件系统。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;root@kernelnewbies:~/docker.sh/images&lt;span class=&#34;token comment&#34;&gt;# cd ubuntu1604/&lt;/span&gt;
root@kernelnewbies:~/docker.sh/images/ubuntu1604&lt;span class=&#34;token comment&#34;&gt;# pivot_root . old_root/&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时，已完成根文件系统的切换，/proc 文件系统也被挪到了&lt;br&gt;
/home/phl/docker.sh/images/ubuntu1604/old_root/proc，也就是说当前没有 /proc 文件系统，因此，我们无法查看挂载点信息，自然也无法执行一些依赖于 /proc 文件系统的操作。我们需要重新挂载 /proc 文件系统。命令如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;root@kernelnewbies:~/docker.sh/images/ubuntu1604&lt;span class=&#34;token comment&#34;&gt;# mount -t proc proc /proc&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重新挂载 /proc 文件系统后，我们就可以查看当前的挂载点信息了。通过读取 /proc/self/mountinfo 文件来查看系统的挂载点信息。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;root@kernelnewbies:~/docker.sh/images/ubuntu1604&lt;span class=&#34;token comment&#34;&gt;# cat /proc/self/mountinfo&lt;/span&gt;
&lt;span class=&#34;token number&#34;&gt;382&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;624&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;8&lt;/span&gt;:1 / /old_root rw,relatime - ext4 /dev/sda1 rw,errors&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;remount-ro
&lt;span class=&#34;token punctuation&#34;&gt;..&lt;/span&gt;.
&lt;span class=&#34;token number&#34;&gt;624&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;381&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;8&lt;/span&gt;:1 /home/phl/docker.sh/images/ubuntu1604 / rw,relatime - ext4 /dev/sda1 rw,errors&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;remount-ro
&lt;span class=&#34;token number&#34;&gt;625&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;624&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;:5 / /proc rw,relatime - proc proc rw&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时的挂载点很多，为了方便查看，此处只保留了一些主要的挂载点信息。这些挂载点信息包括 /、/proc、/old_root。/old_root 为老的根文件系统，我们需要将其卸载。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;root@kernelnewbies:~/docker.sh/images/ubuntu1604&lt;span class=&#34;token comment&#34;&gt;# umount -l /old_root/&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;卸载掉老的根文件系统后，我们再查看系统的挂载点信息。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;root@kernelnewbies:~/docker.sh/images/ubuntu1604&lt;span class=&#34;token comment&#34;&gt;# cat /proc/self/mountinfo&lt;/span&gt;
&lt;span class=&#34;token number&#34;&gt;624&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;381&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;8&lt;/span&gt;:1 /home/phl/docker.sh/images/ubuntu1604 / rw,relatime - ext4 /dev/sda1 rw,errors&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;remount-ro
&lt;span class=&#34;token number&#34;&gt;625&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;624&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;:5 / /proc rw,relatime - proc proc rw&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时，挂载点信息中只有 /、/proc，不再有主机的挂载点信息。&lt;/p&gt;
&lt;h3 id=&#34;3-3-docker-sh&#34;&gt;3.3.docker.sh&lt;/h3&gt;
&lt;p&gt;有了以上关于切换根文件系统的知识，我们就可以将切换根文件系统的功能加入到 docker.sh 中了。切换根文件系统的功能将放在 container.sh 中，带下划线的行是我们为实现切换根文件系统而新添的代码。修改后的 container.sh 脚本如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&lt;span class=&#34;token shebang important&#34;&gt;#!/bin/bash&lt;/span&gt;

&lt;span class=&#34;token function&#34;&gt;hostname&lt;/span&gt; &lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;

&lt;span class=&#34;token function&#34;&gt;mkdir&lt;/span&gt; -p /sys/fs/cgroup/memory/&lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;
&lt;span class=&#34;token builtin class-name&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;token variable&#34;&gt;$$&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;&amp;gt;&lt;/span&gt; /sys/fs/cgroup/memory/&lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;/cgroup.procs
&lt;span class=&#34;token builtin class-name&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;token variable&#34;&gt;$memory&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;&amp;gt;&lt;/span&gt; /sys/fs/cgroup/memory/&lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;/memory.limit_in_bytes

&lt;span class=&#34;token function&#34;&gt;mkdir&lt;/span&gt; -p images/&lt;span class=&#34;token variable&#34;&gt;$image&lt;/span&gt;/old_root
&lt;span class=&#34;token function&#34;&gt;mount&lt;/span&gt; --bind images/&lt;span class=&#34;token variable&#34;&gt;$image&lt;/span&gt; images/&lt;span class=&#34;token variable&#34;&gt;$image&lt;/span&gt;

&lt;span class=&#34;token builtin class-name&#34;&gt;cd&lt;/span&gt; images/&lt;span class=&#34;token variable&#34;&gt;$image&lt;/span&gt;
pivot_root &lt;span class=&#34;token builtin class-name&#34;&gt;.&lt;/span&gt; ./old_root

&lt;span class=&#34;token function&#34;&gt;mount&lt;/span&gt; -t proc proc /proc
&lt;span class=&#34;token function&#34;&gt;umount&lt;/span&gt; -l /old_root

&lt;span class=&#34;token builtin class-name&#34;&gt;exec&lt;/span&gt; &lt;span class=&#34;token variable&#34;&gt;$program&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先，我们在新的根文件系统目录中创建挂载老的根文件系统的目录。命令如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&lt;span class=&#34;token function&#34;&gt;mkdir&lt;/span&gt; -p images/&lt;span class=&#34;token variable&#34;&gt;$image&lt;/span&gt;/old_root&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，我们将新根文件系统目录 bind mount 成一个挂载点。命令如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&lt;span class=&#34;token function&#34;&gt;mount&lt;/span&gt; --bind images/&lt;span class=&#34;token variable&#34;&gt;$image&lt;/span&gt; images/&lt;span class=&#34;token variable&#34;&gt;$image&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，我们切换根文件系统。命令如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&lt;span class=&#34;token builtin class-name&#34;&gt;cd&lt;/span&gt; images/&lt;span class=&#34;token variable&#34;&gt;$image&lt;/span&gt;
pivot_root &lt;span class=&#34;token builtin class-name&#34;&gt;.&lt;/span&gt; ./old_root&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后，我们重新挂载 /proc 文件系统，然后卸载掉老的根文件系统。命令如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&lt;span class=&#34;token function&#34;&gt;mount&lt;/span&gt; -t proc proc /proc
&lt;span class=&#34;token function&#34;&gt;umount&lt;/span&gt; -l /old_root&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在，我们运行 docker.sh，并查看当前的发行版信息。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~/docker.sh$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; ./docker.sh -c run -m 100M -C dreamland -I ubuntu1604 -V data1 -P /bin/bash
root@dreamland:/&lt;span class=&#34;token comment&#34;&gt;# cat /etc/issue&lt;/span&gt;
Ubuntu &lt;span class=&#34;token number&#34;&gt;16.04&lt;/span&gt; LTS &lt;span class=&#34;token punctuation&#34;&gt;\&lt;/span&gt;n &lt;span class=&#34;token punctuation&#34;&gt;\&lt;/span&gt;l&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果我们可以看出，读出的发行版信息是 Ubuntu 16.04 LTS \n \l，而非主机的 Ubuntu 18.04.3 LTS \n \l。这说明当前使用的根文件系统确实是 ubuntu16.04 目录下的根文件系统，而非主机的根文件系统。&lt;/p&gt;
&lt;p&gt;我们再查看一下当前的挂载点信息，看看是否只有 / 与 /proc。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;root@dreamland:/&lt;span class=&#34;token comment&#34;&gt;# cat /proc/self/mountinfo&lt;/span&gt;
&lt;span class=&#34;token number&#34;&gt;625&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;381&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;8&lt;/span&gt;:1 /home/phl/docker.sh/images/ubuntu1604 / rw,relatime - ext4 /dev/sda1 rw,errors&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;remount-ro
&lt;span class=&#34;token number&#34;&gt;626&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;625&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt;:52 / /proc rw,relatime - proc proc rw&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果我们可看出，当前挂载点信息中只有 /、/proc，不再有主机的挂载点信息。&lt;/p&gt;
&lt;p&gt;通过根文件系统，我们实现了在容器中虚拟出与主机不一样的操作系统的功能。&lt;/p&gt;
&lt;h2 id=&#34;4-联合加载&#34;&gt;4. 联合加载&lt;/h2&gt;
&lt;h3 id=&#34;4-1-联合加载简介&#34;&gt;4.1. 联合加载简介&lt;/h3&gt;
&lt;p&gt;联合加载指的是一次同时加载多个文件系统，但是在外面看起来只能看到 一个文件系统。联合加载会将各层文件系统叠加到一起，这样最终的文件系统会 包含所有底层的文件和目录。&lt;/p&gt;
&lt;p&gt;联合加载的多个文件系统中有一个是可读写文件系统，称为读写层，其他文件系统是只读的，称为只读层。当联合加载的文件系统发生变化时，这些变化都应用到这个读写层。比如，如果想修改一个文件，这个文件首先会从只读层复制到读写层。原只读层中的文件依然存在，但是被读写层中的该文件副本所隐藏。我们以后读写该文件时，都是读写的该文件在读写层中的副本。这种机制被称为 写时复制。&lt;/p&gt;
&lt;p&gt;我们之前实现的 docker.sh，有一个很大的缺陷。那就是，如果使用相同的根文件系统同时启动多个容器的实例，那么，这些容器实例使用的根文件系统位于同一个目录。我们在不同的容器实例对根文件系统所作的修改，这些容器彼此之间都可以看到，甚至一个容器可以覆覆盖另一个容器所作的修改。同时，容器实例退出时，对根文件系统所作的修改也直接作用于其所使用的根文件系统。当我们使用该根文件系统再次启动容器实例时，新启动的容器实例也可以看到以前的这些修改。例如，我们用 ubuntu1604 根文件系统启动两个容器实例，命令如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~/docker.sh$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; ./docker.sh -c run -m 100M -C dreamland -I ubuntu1604 -V data1 -P /bin/bash
phl@kernelnewbies:~/docker.sh$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; ./docker.sh -c run -m 100M -C dreamland2 -I ubuntu1604 -V data1 -P /bin/bash&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这两个容器实例对根文件系统做的修改彼此都可以看到。容器实例退出时，这些修改也被保存了下来，当用 ubuntu1604 根文件系统启动新的容器实例时，新实例也可看到以前实例所做的修改。&lt;/p&gt;
&lt;p&gt;如果容器使用的根文件系统是一个联合加载的文件系统，原先的根文件系统作为一个只读层，再添加一个读写层，那么，在容器内所作的修改都将只作用于读写层。为了区分，我们以后称 ubuntu1604 目录下的根文件系统为镜像。而我们可以为每一个容器实例指定一个唯一的读写层目录，这样的话，多个容器实例就可以使用同一个镜像，容器内所作的修改不会影响彼此，也不会影响到以后启动的容器实例。例如：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~/docker.sh$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; ./docker.sh -c run -m 100M -C dreamland -I ubuntu1604 -V data1 -P /bin/bash
phl@kernelnewbies:~/docker.sh$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; ./docker.sh -c run -m 100M -C dreamland2 -I ubuntu1604 -V data1 -P /bin/bash&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们使用 ubuntu1604 镜像启动了两个容器示例，并在容器实例里进行读写操作。这两个容器实例的读写层目录是不一样的，在容器实例中所作的修改只作用于各自的读写层，彼此之间不会影响，当然更不会影响到后续启动的容器实例。&lt;/p&gt;
&lt;h3 id=&#34;4-2-AUFS&#34;&gt;4.2. AUFS&lt;/h3&gt;
&lt;p&gt;AUFS 是一个实现了联合加载功能的文件系统。我们将采用 AUFS 实现 docker.sh 中的联合加载功能。&lt;/p&gt;
&lt;p&gt;下面，我们将通过实验演示一下 AUFS 文件系统的用法。首先，我们准备需要用到的目录及文件。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~$ &lt;span class=&#34;token function&#34;&gt;mkdir&lt;/span&gt; aufs
phl@kernelnewbies:~$ &lt;span class=&#34;token builtin class-name&#34;&gt;cd&lt;/span&gt; aufs/
phl@kernelnewbies:~/aufs$ &lt;span class=&#34;token function&#34;&gt;mkdir&lt;/span&gt; rw r1 r2 union
phl@kernelnewbies:~/aufs$ &lt;span class=&#34;token builtin class-name&#34;&gt;echo&lt;/span&gt; hello r1 &lt;span class=&#34;token operator&#34;&gt;&amp;gt;&lt;/span&gt; r1/hellor1.txt
phl@kernelnewbies:~/aufs$ &lt;span class=&#34;token builtin class-name&#34;&gt;echo&lt;/span&gt; hello r2 &lt;span class=&#34;token operator&#34;&gt;&amp;gt;&lt;/span&gt; r2/hellor2.txt
phl@kernelnewbies:~/aufs$ &lt;span class=&#34;token builtin class-name&#34;&gt;echo&lt;/span&gt; hello rw &lt;span class=&#34;token operator&#34;&gt;&amp;gt;&lt;/span&gt; rw/hellorw.txt&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下表列出了各个目录的作用。列表如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;rw 为 aufs 文件系统的读写层目录&lt;/li&gt;
&lt;li&gt; r1 为 aufs 文件系统的只读层目录&lt;/li&gt;
&lt;li&gt; r2 为 aufs 文件系统的只读层目录&lt;/li&gt;
&lt;li&gt; union 为挂载点，联合加载的 aufs 文件系统挂载于此目录&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我们将 rw、r1、r2 联合加载到 union 目录。命令如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~/aufs$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;mount&lt;/span&gt; -t aufs -o &lt;span class=&#34;token assign-left variable&#34;&gt;dirs&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;rw:r1:r2 none union&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;-t aufs 表示要挂载的文件系统类型为 AUFS&lt;/li&gt;
&lt;li&gt;-o dirs=rw:r1:r2 表示要将哪些目录加载到 afus 文件系统中，多个目录之间以：分隔。目录列表中的第一个目录表示读写层目录&lt;/li&gt;
&lt;li&gt; union 表示 aufs 文件系统要挂载的目录&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;挂载好 AUFS 文件系统后，我们进入该文件系统，查看其内容。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~/aufs$ &lt;span class=&#34;token builtin class-name&#34;&gt;cd&lt;/span&gt; union/
phl@kernelnewbies:~/aufs/union$ &lt;span class=&#34;token function&#34;&gt;ls&lt;/span&gt;
hellor1.txt hellor2.txt hellorw.txt&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从输出结果来看，rw、r1、r2 目录下的内容全部出现在了 AUFS 文件系统中，该文件系统由 rw、r1、r2 目录叠加而成。&lt;/p&gt;
&lt;p&gt;然后，我们修改这些文件，看看原始的 rw、r1、r2 目录下的文件是否更改。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~/aufs/union$ &lt;span class=&#34;token builtin class-name&#34;&gt;echo&lt;/span&gt; hello to r1 from union &lt;span class=&#34;token operator&#34;&gt;&amp;gt;&lt;/span&gt; hellor1.txt
phl@kernelnewbies:~/aufs/union$ &lt;span class=&#34;token builtin class-name&#34;&gt;echo&lt;/span&gt; hello to r2 from union &lt;span class=&#34;token operator&#34;&gt;&amp;gt;&lt;/span&gt; hellor2.txt
phl@kernelnewbies:~/aufs/union$ &lt;span class=&#34;token builtin class-name&#34;&gt;echo&lt;/span&gt; hello to rw from union &lt;span class=&#34;token operator&#34;&gt;&amp;gt;&lt;/span&gt; hellorw.txt&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们返回到 aufs 目录，直接查看 aufs 目录下的内容。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~/aufs$ tree &lt;span class=&#34;token builtin class-name&#34;&gt;.&lt;/span&gt;
&lt;span class=&#34;token builtin class-name&#34;&gt;.&lt;/span&gt;
├── r1
│   └── hellor1.txt
├── r2
│   └── hellor2.txt
├── rw
│   ├── hellor1.txt
│   ├── hellor2.txt
│   └── hellorw.txt
└── union
    ├── hellor1.txt
    ├── hellor2.txt
    └── hellorw.txt

&lt;span class=&#34;token number&#34;&gt;4&lt;/span&gt; directories, &lt;span class=&#34;token number&#34;&gt;8&lt;/span&gt; files&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从输出结果我们可以看到，我们修改的 hellor1.txt 和 hellor2.txt 文件分别被拷贝了一份放在读写层目录 rw 中。我们查看一下这些文件的内容，命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~/aufs$ &lt;span class=&#34;token function&#34;&gt;cat&lt;/span&gt; r1/hellor1.txt
hello r1
phl@kernelnewbies:~/aufs$ &lt;span class=&#34;token function&#34;&gt;cat&lt;/span&gt; r2/hellor2.txt
hello r2
phl@kernelnewbies:~/aufs$ &lt;span class=&#34;token function&#34;&gt;cat&lt;/span&gt; rw/hellor1.txt
hello to r1 from union
phl@kernelnewbies:~/aufs$ &lt;span class=&#34;token function&#34;&gt;cat&lt;/span&gt; rw/hellor2.txt
hello to r2 from union
phl@kernelnewbies:~/aufs$ &lt;span class=&#34;token function&#34;&gt;cat&lt;/span&gt; rw/hellorw.txt
hello to rw from union&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从输出结果我们看到，用户修改只读层 r1、r2 中的文件时，这些文件被复制到了读写层，我们修改的是读写层的副本，原只读层中的文件没有变化。用户修改读写层 rw 中的文件时，修改直接作用于这些文件本身。&lt;/p&gt;
&lt;h3 id=&#34;4-3-docker-sh&#34;&gt;4.3.docker.sh&lt;/h3&gt;
&lt;p&gt;在继续之前，我们需要将上一章在 ubuntu1604 根文件系统中创建的 old_root 目录删除掉，以保证该根文件系统跟刚制作好时一样。命令及结果如下：&lt;/p&gt;
&lt;p&gt;phl@kernelnewbies:~/docker.sh$ sudo rm -rf images/ubuntu1604/old_root&lt;/p&gt;
&lt;p&gt;有了以上关于联合加载的介绍，我们就可以将联合加载功能加入到 docker.sh 中了。联合加载功能将放在 container.sh 脚本中，带下划线的行是我们为实现联合加载功能而新添的代码。修改后的 container.sh 如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&lt;span class=&#34;token shebang important&#34;&gt;#!/bin/bash&lt;/span&gt;

&lt;span class=&#34;token function&#34;&gt;hostname&lt;/span&gt; &lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;

&lt;span class=&#34;token function&#34;&gt;mkdir&lt;/span&gt; -p /sys/fs/cgroup/memory/&lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;
&lt;span class=&#34;token builtin class-name&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;token variable&#34;&gt;$$&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;&amp;gt;&lt;/span&gt; /sys/fs/cgroup/memory/&lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;/cgroup.procs
&lt;span class=&#34;token builtin class-name&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;token variable&#34;&gt;$memory&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;&amp;gt;&lt;/span&gt; /sys/fs/cgroup/memory/&lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;/memory.limit_in_bytes

&lt;span class=&#34;token function&#34;&gt;mkdir&lt;/span&gt; -p &lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;/rwlayer
&lt;span class=&#34;token function&#34;&gt;mount&lt;/span&gt; -t aufs -o &lt;span class=&#34;token assign-left variable&#34;&gt;dirs&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;/rwlayer:./images/&lt;span class=&#34;token variable&#34;&gt;$image&lt;/span&gt; none &lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;

&lt;span class=&#34;token function&#34;&gt;mkdir&lt;/span&gt; -p &lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;/old_root
&lt;span class=&#34;token builtin class-name&#34;&gt;cd&lt;/span&gt; &lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;
pivot_root &lt;span class=&#34;token builtin class-name&#34;&gt;.&lt;/span&gt; ./old_root

&lt;span class=&#34;token function&#34;&gt;mount&lt;/span&gt; -t proc proc /proc
&lt;span class=&#34;token function&#34;&gt;umount&lt;/span&gt; -l /old_root

&lt;span class=&#34;token builtin class-name&#34;&gt;exec&lt;/span&gt; &lt;span class=&#34;token variable&#34;&gt;$program&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先，我们根据容器的名字创建联合加载需要的读写层目录及文件系统挂载目录。命令如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&lt;span class=&#34;token function&#34;&gt;mkdir&lt;/span&gt; -p &lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;/rwlayer&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;假如我们传递的容器的名字为 dreamland，将创建以下目录：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~/docker.sh$ tree dreamland/
dreamland/
└── rwlayer&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 dreamland/rwlayer 目录为创建的 AUFS 文件系统的读写层，dreamland 目录为 AUFS 文件系统的挂载点。&lt;/p&gt;
&lt;p&gt;然后我们将镜像目录、读写层目录联合加载到挂载点目录。命令如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&lt;span class=&#34;token function&#34;&gt;mount&lt;/span&gt; -t aufs -o &lt;span class=&#34;token assign-left variable&#34;&gt;dirs&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;/rwlayer:./images/&lt;span class=&#34;token variable&#34;&gt;$image&lt;/span&gt; none &lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;假如容器名字为 dreamland，使用的镜像为 ubuntu1604 根文件系统，dreamland/rwlayer、images/ubuntu1604 将被联合加载的 dreamland 目录。其中，dreamland/rwlayer 为 AUFS 文件系统的读写层，images/ubuntu1604 为 AUFS 文件系统的只读层。&lt;/p&gt;
&lt;p&gt;之前我们将老的根文件系统挪到了 rootfs/old_root，rootfs 代表一个具体的镜像目录。创建 old_root 目录时直接修改了该镜像。下面我们将老的根文件系统的挂载点目录放在 AUFS 文件系统中，并将老的根文件系统挪到此处。命令如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&lt;span class=&#34;token function&#34;&gt;mkdir&lt;/span&gt; -p &lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;/old_root
&lt;span class=&#34;token builtin class-name&#34;&gt;cd&lt;/span&gt; &lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;
pivot_root &lt;span class=&#34;token builtin class-name&#34;&gt;.&lt;/span&gt; ./old_root&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时，$container 目录本身就是一个挂载点，挂载了 AUFS 文件系统。因此下面的代码就被移除了：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&lt;span class=&#34;token function&#34;&gt;mount&lt;/span&gt; --bind images/&lt;span class=&#34;token variable&#34;&gt;$image&lt;/span&gt; images/&lt;span class=&#34;token variable&#34;&gt;$image&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在，我们运行 docker.sh，并在 /root 下创建一个文件。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~/docker.sh$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; ./docker.sh -c run -m 100M -C dreamland -I ubuntu1604 -V data1 -P /bin/bash
root@dreamland:/&lt;span class=&#34;token comment&#34;&gt;# cd /root&lt;/span&gt;
root@dreamland:/root&lt;span class=&#34;token comment&#34;&gt;# ls&lt;/span&gt;
root@dreamland:/root&lt;span class=&#34;token comment&#34;&gt;# cat /etc/issue &amp;gt; hello.txt&lt;/span&gt;
root@dreamland:/root&lt;span class=&#34;token comment&#34;&gt;# cat hello.txt&lt;/span&gt;
Ubuntu &lt;span class=&#34;token number&#34;&gt;16.04&lt;/span&gt; LTS &lt;span class=&#34;token punctuation&#34;&gt;\&lt;/span&gt;n &lt;span class=&#34;token punctuation&#34;&gt;\&lt;/span&gt;l&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动一个新的 Shell 窗口，查看一下该容器使用的 AUFS 文件系统。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~/docker.sh$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; tree dreamland/
dreamland/
└── rwlayer
    ├── old_root
    └── root
        └── hello.txt

&lt;span class=&#34;token number&#34;&gt;2&lt;/span&gt; directories, &lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;file&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果我们可以看到，我们新建的文件及创建的老根文件系统的挂载点目录都出现在了读写层。我们再查看一下新创建的文件。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~/docker.sh$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;cat&lt;/span&gt; dreamland/rwlayer/root/hello.txt
Ubuntu &lt;span class=&#34;token number&#34;&gt;16.04&lt;/span&gt; LTS &lt;span class=&#34;token punctuation&#34;&gt;\&lt;/span&gt;n &lt;span class=&#34;token punctuation&#34;&gt;\&lt;/span&gt;l&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;文件内容是 Ubuntu 16.04 的发行版信息。&lt;/p&gt;
&lt;p&gt;通过联合加载，我们实现了在容器中的读写不会影响使用的镜像。这样使用 ubuntu1604 镜像创建多个容器时，彼此之间就不会相互影响了。&lt;/p&gt;
&lt;h2 id=&#34;5-卷&#34;&gt;5. 卷&lt;/h2&gt;
&lt;h3 id=&#34;5-1-卷简介&#34;&gt;5.1. 卷简介&lt;/h3&gt;
&lt;p&gt;卷是容器内的一个目录，这个目录可以绕过联合文件系统，提供数据共享（容器所使用的的联合文件系统不应该被主机或其他容器访问）与数据持久化的功能。&lt;/p&gt;
&lt;p&gt;举个例子，假如容器有个目录为 /data 的卷，我们向这个卷写入的内容不会出现在联合文件系统的读写层，而是直接出现在这个目录里。主机与其他容器也可以访问该目录，从而达到数据共享与数据持久化的目的。&lt;/p&gt;
&lt;p&gt;卷位于联合文件系统中，通常来说写入该目录的内容会被写入容器的读写层中，那么怎样才能是写入卷的目录直接出现在该目录中，而不是容器读写层呢？其实方法很简单，只要我们将该目录变成一个挂载点就行，变成挂载点后，这个目录中的内容就不属于联合文件系统了，写入该目录的内容自然会保存在挂载到该挂载点的设备中。&lt;/p&gt;
&lt;h3 id=&#34;5-2-docker-sh&#34;&gt;5.2 docker.sh&lt;/h3&gt;
&lt;p&gt;有了以上关于卷的介绍，我们就可以将卷功能加入到 docker.sh 中了。卷功能将放在 container.sh 脚本中，带下划线的行是我们为实现卷功能而新添的代码。修改后的 container.sh 脚本如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&lt;span class=&#34;token shebang important&#34;&gt;#!/bin/bash&lt;/span&gt;

&lt;span class=&#34;token function&#34;&gt;hostname&lt;/span&gt; &lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;

&lt;span class=&#34;token function&#34;&gt;mkdir&lt;/span&gt; -p /sys/fs/cgroup/memory/&lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;
&lt;span class=&#34;token builtin class-name&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;token variable&#34;&gt;$$&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;&amp;gt;&lt;/span&gt; /sys/fs/cgroup/memory/&lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;/cgroup.procs
&lt;span class=&#34;token builtin class-name&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;token variable&#34;&gt;$memory&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;&amp;gt;&lt;/span&gt; /sys/fs/cgroup/memory/&lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;/memory.limit_in_bytes

&lt;span class=&#34;token function&#34;&gt;mkdir&lt;/span&gt; -p &lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;/rwlayer
&lt;span class=&#34;token function&#34;&gt;mount&lt;/span&gt; -t aufs -o &lt;span class=&#34;token assign-left variable&#34;&gt;dirs&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;/rwlayer:./images/&lt;span class=&#34;token variable&#34;&gt;$image&lt;/span&gt; none &lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;

&lt;span class=&#34;token function&#34;&gt;mkdir&lt;/span&gt; -p &lt;span class=&#34;token variable&#34;&gt;$volume&lt;/span&gt;
&lt;span class=&#34;token function&#34;&gt;mkdir&lt;/span&gt; -p &lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;/&lt;span class=&#34;token variable&#34;&gt;$volume&lt;/span&gt;
&lt;span class=&#34;token function&#34;&gt;mount&lt;/span&gt; --bind &lt;span class=&#34;token variable&#34;&gt;$volume&lt;/span&gt; &lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;/&lt;span class=&#34;token variable&#34;&gt;$volume&lt;/span&gt;

&lt;span class=&#34;token function&#34;&gt;mkdir&lt;/span&gt; -p &lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;/old_root
&lt;span class=&#34;token builtin class-name&#34;&gt;cd&lt;/span&gt; &lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;
pivot_root &lt;span class=&#34;token builtin class-name&#34;&gt;.&lt;/span&gt; ./old_root

&lt;span class=&#34;token function&#34;&gt;mount&lt;/span&gt; -t proc proc /proc
&lt;span class=&#34;token function&#34;&gt;umount&lt;/span&gt; -l /old_root

&lt;span class=&#34;token builtin class-name&#34;&gt;exec&lt;/span&gt; &lt;span class=&#34;token variable&#34;&gt;$program&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先，我们根据卷的名字创建主机卷目录，我们在容器内部对卷的修改，都将作用于此目录。命令如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&lt;span class=&#34;token function&#34;&gt;mkdir&lt;/span&gt; -p &lt;span class=&#34;token variable&#34;&gt;$volume&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，我们在容器内部创建同名卷目录，该目录本身会出现在容器的读写层中，因为该目录是在 AUFS 文件系统中创建的。因为&lt;img src=&#34;https://math.now.sh?inline=container%E7%9B%AE%E5%BD%95%E4%B8%BA%E5%AE%B9%E5%99%A8%E7%9A%84%E6%A0%B9%E7%9B%AE%E5%BD%95%EF%BC%8C%E6%89%80%E4%BB%A5%E5%AE%B9%E5%99%A8%E5%86%85%E9%83%A8%E5%8D%B7%E7%9B%AE%E5%BD%95%E7%9A%84%E8%B7%AF%E5%BE%84%E4%B8%BA%2F&#34; style=&#34;filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;&#34;&gt;volume。命令如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&lt;span class=&#34;token function&#34;&gt;mkdir&lt;/span&gt; -p &lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;/&lt;span class=&#34;token variable&#34;&gt;$volume&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将主机上的卷目录 bind mount 到容器内部的卷目录上，这样容器内部对卷目录的修改，都将作用于主机卷目录。命令如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&lt;span class=&#34;token function&#34;&gt;mount&lt;/span&gt; --bind &lt;span class=&#34;token variable&#34;&gt;$volume&lt;/span&gt; &lt;span class=&#34;token variable&#34;&gt;$container&lt;/span&gt;/&lt;span class=&#34;token variable&#34;&gt;$volume&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在，我们运行 docker.sh，并在卷目录（/data1）中创建一个文件。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~/docker.sh$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; ./docker.sh -c run -m 100M -C dreamland -I ubuntu1604 -V data1 -P /bin/bash
root@dreamland:/&lt;span class=&#34;token comment&#34;&gt;# cd /data1&lt;/span&gt;
root@dreamland:/data1&lt;span class=&#34;token comment&#34;&gt;# echo &#34;hello to data1 volume from ubuntu16.04&#34; &amp;gt;&amp;gt; hello.txt&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;启动一个新的 Shell 窗口，查看一下该容器使用的 AUFS 文件系统中的内容。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~/docker.sh$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; tree dreamland/
dreamland/
└── rwlayer
    ├── data1
    ├── old_root
    └── root
        └── hello.txt

&lt;span class=&#34;token number&#34;&gt;4&lt;/span&gt; directories, &lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;file&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果我们可以看到，我们使用的卷目录被创建在了容器的读写层，但是我们在卷目录中新建的文件却没有出现在读写层中。&lt;/p&gt;
&lt;p&gt;我们再来查看一下主机卷目录的内容。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~/docker.sh$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; tree data1/
data1/
└── hello.txt

&lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt; directories, &lt;span class=&#34;token number&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;file&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果我们可以看到，在容器内部对卷目录的修改直接作用在了主机上的卷目录。我们再来查看一下主机卷目录下 hello.txt 中的内容。命令及结果如下：&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;phl@kernelnewbies:~/docker.sh$ &lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;cat&lt;/span&gt; data1/hello.txt
hello to data1 volume from ubuntu16.04&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果我们可以看到，该文件的内容与我们在容器内部写入 hello.txt 的内容一致。&lt;/p&gt;
&lt;p&gt;通过卷目录，我们实现了容器之间数据共享与数据持久化的功能。&lt;/p&gt;
&lt;h2 id=&#34;6-后记&#34;&gt;6. 后记&lt;/h2&gt;
&lt;p&gt;至此，我们通过一系列的实验对 docker 的底层技术有了一个感性的认识。我们在使用 docker 时，也能够对其是如何运作的有了一个大致的了解。当然，这对于掌握 docker 技术来说还远远不够，有很多知识我们没有涉及，例如 user namespace、容器安全、其他的 CGroups、虚拟网络等。&lt;/p&gt;
&lt;p&gt;编辑整理 &lt;a target=&#34;_blank&#34; rel=&#34;noopener&#34; href=&#34;https://www.toutiao.com/i6890898988879315468/?tt_from=weixin&amp;amp;utm_campaign=client_share&amp;amp;wxshare_count=1&amp;amp;timestamp=1647576105&amp;amp;app=news_article&amp;amp;utm_source=weixin&amp;amp;utm_medium=toutiao_android&amp;amp;use_new_style=1&amp;amp;req_id=202203181201440101511900790A2CBE46&amp;amp;share_token=b2d9351e-4cb1-4a25-ae82-f70543ce2a3b&amp;amp;group_id=6890898988879315468&#34;&gt;ScratchLab&lt;/a&gt;&lt;/p&gt;
&lt;link rel=&#34;stylesheet&#34; href=&#34;/css/bilicard.css&#34; type=&#34;text/css&#34;&gt;</content>
        <category term="linux" />
        <category term="docker" />
        <category term="shell" />
        <updated>2022-03-18T06:33:17.000Z</updated>
    </entry>
    <entry>
        <id>https://blog.17lai.site/posts/593cc323/</id>
        <title>Earthly 一个更加强大的镜像构建工具</title>
        <link rel="alternate" href="https://blog.17lai.site/posts/593cc323/"/>
        <content type="html">&lt;link rel=&#34;stylesheet&#34; class=&#34;aplayer-secondary-style-marker&#34; href=&#34;/assets/css/APlayer.min.css&#34;&gt;&lt;script src=&#34;/assets/js/APlayer.min.js&#34; class=&#34;aplayer-secondary-script-marker&#34;&gt;&lt;/script&gt;&lt;h2 id=&#34;一、Earthly-介绍&#34;&gt;一、Earthly 介绍&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;开局一张图，功能全靠吹。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/11/0120211101210057.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;Earthly 是一个更加高级的 Docker 镜像构建工具，Earthly 通过自己定义的 Earthfile 来代替传统的 Dockerfile 完成镜像构建；Earthfile 就如同 Earthly 官方所描述:&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;**Makefile + Dockerfile = Earthfile**&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在使用 Earthly 进行构建镜像时目前强依赖于 buildkit，Earthly 通过 buildkit 支持了一些 Dockerfile 的扩展语法，同时将 Dockerfile 与 Makefile 整合，使得多平台构建和代码化 Dockerfile 变得更加简单；使用 Earthly 可以更加方便的完成 Dockerfile 的代码复用以及更加友好的 CI 自动集成。&lt;/p&gt;
&lt;h2 id=&#34;二、快速开始&#34;&gt;二、快速开始&lt;/h2&gt;
&lt;h3 id=&#34;2-1、安装依赖&#34;&gt;2.1、安装依赖&lt;/h3&gt;
&lt;p&gt;Earthly 目前依赖于 Docker 和 Git，所以安装 Earthly 前请确保机器已经安装了 Docker 和 Git。&lt;/p&gt;
&lt;h3 id=&#34;2-2、安装-Earthly&#34;&gt;2.2、安装 Earthly&lt;/h3&gt;
&lt;p&gt;Earthly 采用 Go 编写，所以主要就一个二进制文件，Linux 下安装可以直接参考官方的安装脚本:&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&lt;span class=&#34;token function&#34;&gt;sudo&lt;/span&gt; /bin/sh -c &lt;span class=&#34;token string&#34;&gt;&#39;wget https://github.com/earthly/earthly/releases/latest/download/earthly-linux-amd64 -O /usr/local/bin/earthly &amp;amp;&amp;amp; chmod +x /usr/local/bin/earthly &amp;amp;&amp;amp; /usr/local/bin/earthly bootstrap --with-autocomplete&#39;&lt;/span&gt;Copy&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装完成后 Earthly 将会启动一个 buildkitd 容器: &lt;code&gt;earthly-buildkitd&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;2-3、语法高亮&#34;&gt;2.3、语法高亮&lt;/h3&gt;
&lt;p&gt;目前 Earthly 官方支持 VS Code、VIM 以及 Sublime Text 三种编辑器的语法高亮，具体如何安装请参考 &lt;a target=&#34;_blank&#34; rel=&#34;noopener&#34; href=&#34;https://earthly.dev/get-earthly&#34;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;2-4、基本使用&#34;&gt;2.4、基本使用&lt;/h3&gt;
&lt;p&gt;本示例源于官方 Basic 教程，以下示例以编译 Go 项目为样例:&lt;/p&gt;
&lt;p&gt;首先创建一个任意名称的目录，目录中存在项目源码文件以及一个 &lt;code&gt;Earthfile&lt;/code&gt; 文件；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;main.go&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-go&#34; data-language=&#34;go&#34;&gt;&lt;code class=&#34;language-go&#34;&gt;&lt;span class=&#34;token keyword&#34;&gt;package&lt;/span&gt; main

&lt;span class=&#34;token keyword&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#34;fmt&#34;&lt;/span&gt;

&lt;span class=&#34;token keyword&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;{&lt;/span&gt;
    fmt&lt;span class=&#34;token punctuation&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;token function&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;token string&#34;&gt;&#34;hello world&#34;&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;token punctuation&#34;&gt;}&lt;/span&gt;Copy&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Earthfile&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-dockerfile&#34; data-language=&#34;dockerfile&#34;&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;FROM golang:1.17-alpine
WORKDIR /go-example

build:
    COPY main.go .
    RUN go build -o build/go-example main.go
    SAVE ARTIFACT build/go-example /go-example AS LOCAL build/go-example

docker:
    COPY +build/go-example .
    ENTRYPOINT [&#34;/go-example/go-example&#34;]
    SAVE IMAGE go-example:latestCopy&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有了 &lt;code&gt;Earthfile&lt;/code&gt; 以后我们就可以使用 &lt;code&gt;Earthly&lt;/code&gt; 将其打包为镜像；&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&lt;span class=&#34;token comment&#34;&gt;# 目录结构&lt;/span&gt;
~/t/earthlytest ❯❯❯ tree
&lt;span class=&#34;token builtin class-name&#34;&gt;.&lt;/span&gt;
├── Earthfile
└── main.go

&lt;span class=&#34;token number&#34;&gt;0&lt;/span&gt; directories, &lt;span class=&#34;token number&#34;&gt;2&lt;/span&gt; files

&lt;span class=&#34;token comment&#34;&gt;# 通过 earthly 进行构建&lt;/span&gt;
~/t/earthlytest ❯❯❯ earthly +dockerCopy&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/11/0120211101210338.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;构建完成后我们就可以直接从 docker 的 images 列表中查看刚刚构建的镜像，并运行:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/11/0120211101212129.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;三、进阶使用&#34;&gt;三、进阶使用&lt;/h2&gt;
&lt;h3 id=&#34;3-1、多阶段构建&#34;&gt;3.1、多阶段构建&lt;/h3&gt;
&lt;p&gt;Earthfile 中包含类似 Makefile 一样的 &lt;code&gt;target&lt;/code&gt;，不同的 &lt;code&gt;target&lt;/code&gt; 之间还可以通过特定语法进行引用，每个 &lt;code&gt;target&lt;/code&gt; 都可以被单独执行，执行过程中 earthly 会自动解析这些依赖关系。&lt;/p&gt;
&lt;p&gt;这种多阶段构建时语法很弹性，我们可以在每个阶段运行独立的命令以及使用不同的基础镜像；从快速开始中可以看到，我们始终使用了一个基础镜像 (&lt;code&gt;golang:1.17-alpine&lt;/code&gt;)，对于 Go 这种编译后自带运行时不依赖其语言 SDK 的应用，我们事实上可以将 “发布物” 仅放在简单的运行时系统镜像内，从而减少最终镜像体积:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/11/0120211101210338-2.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;由于使用了多个 target，所以我们可以单独的运行 &lt;code&gt;build&lt;/code&gt; 这个 target 来验证我们的编译流程，&lt;strong&gt;这种多 target 的设计方便我们构建应用时对编译、打包步骤的细化拆分，同时也方便我们进行单独的验证。&lt;/strong&gt; 例如我们单独执行 &lt;code&gt;build&lt;/code&gt; 这个 target 来验证我们的编译流程是否正确:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/11/0120211101210338-3.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;在其他阶段验证完成后，我们可以直接运行最终的 target，earthly 会自动识别到这种依赖关系从而自动运行其依赖的 target:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/11/0120211101210338-4.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-2、扩展指令&#34;&gt;3.2、扩展指令&lt;/h3&gt;
&lt;h4 id=&#34;3-2-1、SAVE&#34;&gt;3.2.1、SAVE&lt;/h4&gt;
&lt;p&gt;SAVE 指令是 Earthly 自己的一个扩展指令，实际上分为 &lt;code&gt;SAVE ARTIFACT&lt;/code&gt; 和 &lt;code&gt;SAVE IMAGE&lt;/code&gt;；其中 &lt;code&gt;SAVE ARTIFACT&lt;/code&gt; 指令格式如下:&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-dockerfile&#34; data-language=&#34;dockerfile&#34;&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;SAVE ARTIFACT [--keep-ts] [--keep-own] [--if-exists] [--force] &amp;lt;src&amp;gt; [&amp;lt;artifact-dest-path&amp;gt;] [AS LOCAL &amp;lt;local-path&amp;gt;]Copy&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;SAVE ARTIFACT&lt;/code&gt; 指令用于将文件或目录从 build 运行时环境保存到 target 的 artifact 环境；当保存到 artifact 环境后，可以通过 &lt;code&gt;COPY&lt;/code&gt; 等命令在其他位置进行引用，类似于 Dockerfile 的 &lt;code&gt;COPY --from...&lt;/code&gt; 语法；不同的是 &lt;code&gt;SAVE ARTIFACT&lt;/code&gt; 支持 &lt;code&gt;AS LOCAL &amp;lt;local-path&amp;gt;&lt;/code&gt; 附加参数，一但指定此参数后，earthly 会同时将文件或目录在宿主机复制一份，一般用于调试等目的。&lt;code&gt;SAVE ARTIFACT&lt;/code&gt; 命令在上面的样例中已经展示了，在运行完 &lt;code&gt;earthly +build&lt;/code&gt; 命令后实际上会在本地看到被 SAVE 出来的 ARTIFACT:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/11/0120211101210338-5.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;而另一个 &lt;code&gt;SAVE IMAGE&lt;/code&gt; 指令则主要用于将当前的 build 环境 SAVE 为一个 IMAGE，&lt;strong&gt;如果指定了 &lt;code&gt;--push&lt;/code&gt; 选项，同时在执行 &lt;code&gt;earthly +target&lt;/code&gt; 命令时也加入 &lt;code&gt;--push&lt;/code&gt; 选项，该镜像将会自动被推送到目标 Registry 上。&lt;/strong&gt;&lt;code&gt;SAVE IMAGE&lt;/code&gt; 指令格式如下:&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-dockerfile&#34; data-language=&#34;dockerfile&#34;&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;SAVE IMAGE [--cache-from=&amp;lt;cache-image&amp;gt;] [--push] &amp;lt;image-name&amp;gt;...Copy&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/11/0120211101210338-6.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;3-2-2、GIT-CLONE&#34;&gt;3.2.2、GIT CLONE&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;GIT CLONE&lt;/code&gt; 指令用于将指定 git 仓库 clone 到 build 环境中；与 &lt;code&gt;RUN git clone...&lt;/code&gt; 命令不同的是，&lt;strong&gt;&lt;code&gt;GIT CLONE&lt;/code&gt; 通过宿主机的 git 命令运行，它不依赖于容器内的 git 命令，同时还可以直接为 earthly 配置 git 认证，从而避免将这些安全信息泄漏到 build 环境中；&lt;/strong&gt; 关于如何配置 earthly 的 git 认证请参考 &lt;a target=&#34;_blank&#34; rel=&#34;noopener&#34; href=&#34;https://docs.earthly.dev/docs/guides/auth&#34;&gt;官方文档&lt;/a&gt;；下面是 &lt;code&gt;GIT CLONE&lt;/code&gt; 指令的样例&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/11/0120211101213746.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;3-2-3、COPY&#34;&gt;3.2.3、COPY&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;COPY&lt;/code&gt; 指令与标准的 Dockerfile COPY 指令类似，除了支持 Dockerfile 标准的 COPY 功能以外，&lt;strong&gt;earthly 中的 &lt;code&gt;COPY&lt;/code&gt; 指令可以引用其他 target 环节产生的 artifact，在引用时会自动声明依赖关系；即当在 &lt;code&gt;B&lt;/code&gt; target 中存在 &lt;code&gt;COPY +A/xxxxx /path/to/copy&lt;/code&gt; 类似的指令时，如果只单纯的执行 &lt;code&gt;earthly +B&lt;/code&gt;，那么 earthly 根据依赖分析会得出在 COPY 之前需要执行 target A。&lt;/strong&gt;&lt;code&gt;COPY&lt;/code&gt; 指令的语法格式如下:&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-dockerfile&#34; data-language=&#34;dockerfile&#34;&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;# 与 Dockerfile 相同的使用方式，从上下文复制
COPY [options...] &amp;lt;src&amp;gt;... &amp;lt;dest&amp;gt;

# 扩展支持的从 target 复制方式
COPY [options...] &amp;lt;src-artifact&amp;gt;... &amp;lt;dest&amp;gt;Copy&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3-2-4、RUN&#34;&gt;3.2.4、RUN&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;RUN&lt;/code&gt; 指令在标准使用上与 Dockerfile 里保持一致，除此之外增加了更多的扩展选项，其指令格式如下:&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-dockerfile&#34; data-language=&#34;dockerfile&#34;&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;# shell 方式运行(/bin/sh -c)
RUN [--push] [--entrypoint] [--privileged] [--secret &amp;lt;env-var&amp;gt;=&amp;lt;secret-ref&amp;gt;] [--ssh] [--mount &amp;lt;mount-spec&amp;gt;] [--] &amp;lt;command&amp;gt;

# exec 方式运行
RUN [[&amp;lt;flags&amp;gt;...], &#34;&amp;lt;executable&amp;gt;&#34;, &#34;&amp;lt;arg1&amp;gt;&#34;, &#34;&amp;lt;arg2&amp;gt;&#34;, ...]Copy&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;--privileged&lt;/code&gt; 选项允许运行的命令使用 &lt;code&gt;privileged capabilities&lt;/code&gt;，但是需要 earthly 在运行 target 时增加 &lt;code&gt;--allow-privileged&lt;/code&gt; 选项；&lt;code&gt;--interactive / --interactive-keep&lt;/code&gt; 选项用于交互式执行一些命令，在完成交互后 build 继续进行，&lt;strong&gt;在交互过程中进行的操作都会被持久化到 镜像中:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/11/0120211101210338-8.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;限于篇幅原因，其他的具体指令请查阅官方文档 &lt;a target=&#34;_blank&#34; rel=&#34;noopener&#34; href=&#34;https://docs.earthly.dev/docs/earthfile&#34;&gt;Earthfile reference&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;3-3、UDCS&#34;&gt;3.3、UDCS&lt;/h3&gt;
&lt;p&gt;UDCs 全称 “User-defined commands”，即用户定义指令；通过 UDCs 我们可以将 Earthfile 中特定的命令剥离出来，从而实现更加通用和统一的代码复用；下面是一个定义 UDCs 指令的样例:&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-dockerfile&#34; data-language=&#34;dockerfile&#34;&gt;&lt;code class=&#34;language-dockerfile&#34;&gt;# 定义一个 Command
# ⚠️ 注意: 语法必须满足以下规则
# 1、名称全大写
# 2、名称下划线分割
# 3、首个命令必须为 COMMAND(后面没有冒号)
MY_COPY:
    COMMAND
    ARG src
    ARG dest=./
    ARG recursive=false
    RUN cp $(if $recursive =  &#34;true&#34;; then printf -- -r; fi) &#34;$src&#34; &#34;$dest&#34;

# target 中引用
build:
    FROM alpine:3.13
    WORKDIR /udc-example
    RUN echo &#34;hello&#34; &amp;gt;./foo
    # 通过 DO 关键字引用 UDCs
    DO +MY_COPY --src=./foo --dest=./bar
    RUN cat ./bar # prints &#34;hello&#34;Copy&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;UDCs 不光可以定义在一个 Earthfile 中，UDCs 可以跨文件、跨目录引用:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/11/0120211101212525.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;有了 UDCs 以后，我们可以通过这种方式将对基础镜像的版本统一控制、对特殊镜像的通用处理等操作全部抽象出来，然后每个 Earthfile 根据需要进行引用；关于 UDCs 的使用样例可以参考我的 &lt;a target=&#34;_blank&#34; rel=&#34;noopener&#34; href=&#34;https://github.com/mritd/autobuild&#34;&gt;autobuild&lt;/a&gt; 项目，其中的 &lt;a target=&#34;_blank&#34; rel=&#34;noopener&#34; href=&#34;https://github.com/mritd/autobuild/tree/main/earthfiles/udcs&#34;&gt;udcs&lt;/a&gt; 目录定义了大量的通用 UDCs，这些 UDCs 被其他目标镜的 Earthfile 批量引用。&lt;/p&gt;
&lt;h3 id=&#34;3-4、多平台构建&#34;&gt;3.4、多平台构建&lt;/h3&gt;
&lt;p&gt;在以前使用 Dockerfile 的时候，我们需要自己配置然后开启 buildkit 来实现多平台构建；在配置过程中可能会很繁琐，现在使用 earthly 可以默认帮我们实现多平台的交叉编译，我们需要做的仅仅是在 Earthfile 中声明需要支持哪些平台而已:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/11/0120211101210338-10.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;以上 Earthfile 在执行 &lt;code&gt;earthly --push +all&lt;/code&gt; 构建时，将会自动构建四个平台的镜像，并保持单个 tag，同时由于使用了 &lt;code&gt;--push&lt;/code&gt; 选项还会自动推送到 Docker Hub 上:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/11/0120211101210338-11.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;四、总结&#34;&gt;四、总结&lt;/h2&gt;
&lt;p&gt;Earthly 弥补了 Dockerfile 的很多不足，解决了很多痛点问题；但同样可能需要一些学习成本，但是如果已经熟悉了 Dockerfile 其实学习成本不高；所以目前还是比较推荐将 Dockerfile 切换为 Earthfile 进行统一和版本化管理的。本文由于篇幅所限 (懒) 很多地方没有讲，比如共享缓存等，所以关于 Earthly 更多的详细使用等最好还是仔细阅读一下&lt;a target=&#34;_blank&#34; rel=&#34;noopener&#34; href=&#34;https://docs.earthly.dev/docs/guides&#34;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;整理转载：&lt;a target=&#34;_blank&#34; rel=&#34;noopener&#34; href=&#34;https://mritd.com/2021/10/27/the-best-image-build-tool-earthly/&#34;&gt;the-best-image-build-tool-earthly&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;link rel=&#34;stylesheet&#34; href=&#34;/css/bilicard.css&#34; type=&#34;text/css&#34;&gt;</content>
        <category term="Docker" />
        <category term="Earthly" />
        <updated>2021-10-31T23:25:00.000Z</updated>
    </entry>
    <entry>
        <id>https://blog.17lai.site/posts/9912bd5d/</id>
        <title>使用 jeckett,sonarr,iyuu,qt,emby 打造全自动追剧流程</title>
        <link rel="alternate" href="https://blog.17lai.site/posts/9912bd5d/"/>
        <content type="html">&lt;link rel=&#34;stylesheet&#34; class=&#34;aplayer-secondary-style-marker&#34; href=&#34;/assets/css/APlayer.min.css&#34;&gt;&lt;script src=&#34;/assets/js/APlayer.min.js&#34; class=&#34;aplayer-secondary-script-marker&#34;&gt;&lt;/script&gt;&lt;blockquote&gt;
&lt;p&gt;使用 jeckett,sonarr,iyuu,qt,emby 打造全自动追剧流程，打造一个完整的 HTPC。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;持续滚动更新&lt;/strong&gt;，欢迎收藏关注。也可以 &lt;a href=&#34;https://blog.17lai.site/atom.xml&#34;&gt;RSS 订阅&lt;/a&gt;本博客！&lt;/p&gt;
&lt;p&gt;jackett 作为种子源，sonarr 剧集管理，bt 下载，qbittorrent 主力下载，使用 iyuu 转移辅种，emby，jellyfin 做海报墙，sunfinder 自动下载字幕。基本算是完美打通全流程自动追剧。bt 种子文件命名规则 SxxExx 的自动识别下载，国内的资源手动查找下载，自动推送到 emby 刮削好。&lt;/p&gt;
&lt;p&gt;结合本地 DNS 管理，DNS 去广告，Nginx 反向代理去端口访问，形成一个完整解决方案。&lt;/p&gt;
&lt;p&gt;硬链接工具导入到新目录，使用 TMM 刮削。&lt;/p&gt;
&lt;p&gt;Tips：博主只是把个人使用经验的一部分&lt;em&gt;&lt;strong&gt;无偿&lt;/strong&gt;&lt;/em&gt;写下来，写完后发现整理流程很复杂，要求很高，博主整体软硬件成本上 2W 以上了。各位读者赶着看得懂的做，如果看不懂，请略过，或者 Google 之。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;indexer-种子索引源&#34;&gt;&lt;strong&gt;indexer 种子索引源&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;种子索引来源。&lt;/p&gt;
&lt;h3 id=&#34;jackett&#34;&gt;&lt;strong&gt;jackett&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;docker: linuxserver/jackett:latest&lt;/li&gt;
&lt;li&gt; 老牌选手，种子源非常丰富。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/08/1920210819002543.png&#34; alt=&#34;jackett 界面&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;prowlarr&#34;&gt;&lt;strong&gt;prowlarr&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;indexer manager/proxy&lt;/li&gt;
&lt;li&gt;Docker:  &lt;a target=&#34;_blank&#34; rel=&#34;noopener&#34; href=&#34;https://hub.docker.com/r/linuxserver/prowlarr&#34;&gt;linuxserver/prowlarr:develop&lt;/a&gt;&lt;/li&gt;
&lt;li&gt; 新开发的，和 sonarr, lidarr 等结合比 jackett 配置更简单。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/08/1920210819002628.png&#34; alt=&#34;prowlarr&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;sonarr动画剧集管理&#34;&gt;&lt;strong&gt;sonarr 动画剧集管理&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;管理剧集名，查找剧集种子推送到下载工具&lt;/p&gt;
&lt;p&gt;剧集管理示例图片&lt;/p&gt;
&lt;p&gt;管理剧集目录，剧集日历，提醒你那一天哪些节目播放&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/08/1920210819001244.png&#34; alt=&#34;sonarr&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/08/1920210819211051.png&#34; alt=&#34;sonarr 日历提醒&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/08/1920210819001328.png&#34; alt=&#34;sonarr&#34;&gt;&lt;/p&gt;
&lt;p&gt;自动识别下载对英文剧集支持较好，对于中文资源，结合手动识别下载更佳。&lt;/p&gt;
&lt;h3 id=&#34;手动识别下载&#34;&gt;&lt;strong&gt;手动识别下载&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;示例图片&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/08/1920210819001055.png&#34; alt=&#34;sonarr&#34;&gt;&lt;/p&gt;
&lt;p&gt;电影使用 radarr, 音乐使用 lidarr，同样可以自动化过程&lt;/p&gt;
&lt;h2 id=&#34;多媒体中心&#34;&gt;多媒体中心&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Emby，Jellyfin, Plex 都是优秀的多媒体中心。Jellyfin 是开源的，基于 Emby 早期版本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;emby海报墙，流媒体中心&#34;&gt;&lt;strong&gt;emby 海报墙，流媒体中心&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;emby 作为海报墙，元数据查看器，结合 tampermonkey js 脚本调用外部 potplayer 播放减少 nas 服务器压力，并且得到更好解码性能。手机端也有 emby 客户端。jellyfin，plex 也可以&lt;/p&gt;
&lt;p&gt;js 脚本: &lt;a target=&#34;_blank&#34; rel=&#34;noopener&#34; href=&#34;https://greasyfork.org/scripts/406811-embylaunchpotplayer/code/embyLaunchPotplayer.user.js&#34;&gt;embyLaunchPotplayer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/08/1920210819001419.png&#34; alt=&#34;emby&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/08/1920210819000847.png&#34; alt=&#34;emby&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;jellyfin-开源版本的emby&#34;&gt;&lt;strong&gt;jellyfin 开源版本的 emby&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;jellyfin 硬件解码&lt;/li&gt;
&lt;li&gt; jellyfin 中文字体显示方块问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面两个问题见下面 compose 配置解决方法&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-yaml&#34; data-language=&#34;yaml&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;&lt;span class=&#34;token key atrule&#34;&gt;version&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#39;3&#39;&lt;/span&gt;
&lt;span class=&#34;token key atrule&#34;&gt;services&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;:&lt;/span&gt;
  &lt;span class=&#34;token key atrule&#34;&gt;jellyfin&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;:&lt;/span&gt;
    &lt;span class=&#34;token key atrule&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;:&lt;/span&gt; jellyfin/jellyfin
    &lt;span class=&#34;token key atrule&#34;&gt;container_name&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;:&lt;/span&gt; jellyfin
    &lt;span class=&#34;token key atrule&#34;&gt;user&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;:&lt;/span&gt; $&lt;span class=&#34;token punctuation&#34;&gt;{&lt;/span&gt;PUID&lt;span class=&#34;token punctuation&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;:&lt;/span&gt;$&lt;span class=&#34;token punctuation&#34;&gt;{&lt;/span&gt;PGID&lt;span class=&#34;token punctuation&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;token key atrule&#34;&gt;hostname&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;:&lt;/span&gt; jellyfin
    &lt;span class=&#34;token key atrule&#34;&gt;restart&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;:&lt;/span&gt; always
    &lt;span class=&#34;token key atrule&#34;&gt;devices&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;:&lt;/span&gt;
     &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt; /dev/dri&lt;span class=&#34;token punctuation&#34;&gt;:&lt;/span&gt;/dev/dri     &lt;span class=&#34;token comment&#34;&gt;#使jellfin支持硬件解码&lt;/span&gt;
    &lt;span class=&#34;token key atrule&#34;&gt;environment&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;:&lt;/span&gt;
      &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt; PUID=$&lt;span class=&#34;token punctuation&#34;&gt;{&lt;/span&gt;PUID&lt;span class=&#34;token punctuation&#34;&gt;}&lt;/span&gt;
      &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt; PGID=$&lt;span class=&#34;token punctuation&#34;&gt;{&lt;/span&gt;PGID&lt;span class=&#34;token punctuation&#34;&gt;}&lt;/span&gt;
      &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt; TZ=$&lt;span class=&#34;token punctuation&#34;&gt;{&lt;/span&gt;TZ&lt;span class=&#34;token punctuation&#34;&gt;}&lt;/span&gt;
      &lt;span class=&#34;token comment&#34;&gt;# 给一些插件做代理&lt;/span&gt;
      &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt; http_proxy=http&lt;span class=&#34;token punctuation&#34;&gt;:&lt;/span&gt;//xxx.17lai.site&lt;span class=&#34;token punctuation&#34;&gt;:&lt;/span&gt;1089/
      &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt; https_proxy=http&lt;span class=&#34;token punctuation&#34;&gt;:&lt;/span&gt;//xxx.17lai.site&lt;span class=&#34;token punctuation&#34;&gt;:&lt;/span&gt;1089/
    &lt;span class=&#34;token comment&#34;&gt;# ports:    # 使用nginx 反向代理，所以这里就不用开端口了&lt;/span&gt;
      &lt;span class=&#34;token comment&#34;&gt;# - 8098:8096&lt;/span&gt;
    &lt;span class=&#34;token key atrule&#34;&gt;volumes&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;:&lt;/span&gt;
      &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt; $&lt;span class=&#34;token punctuation&#34;&gt;{&lt;/span&gt;USERDIR&lt;span class=&#34;token punctuation&#34;&gt;}&lt;/span&gt;/jellyfin/config&lt;span class=&#34;token punctuation&#34;&gt;:&lt;/span&gt;/config
      &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt; $&lt;span class=&#34;token punctuation&#34;&gt;{&lt;/span&gt;USERDIR&lt;span class=&#34;token punctuation&#34;&gt;}&lt;/span&gt;/jellyfin/cache&lt;span class=&#34;token punctuation&#34;&gt;:&lt;/span&gt;/cache
      &lt;span class=&#34;token comment&#34;&gt;# 把windowsfonts目录下面的字体都复制到`jellyfin/fonts`目录中&lt;/span&gt;
      &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt; $&lt;span class=&#34;token punctuation&#34;&gt;{&lt;/span&gt;USERDIR&lt;span class=&#34;token punctuation&#34;&gt;}&lt;/span&gt;/jellyfin/fonts&lt;span class=&#34;token punctuation&#34;&gt;:&lt;/span&gt;/usr/share/fonts    &lt;span class=&#34;token comment&#34;&gt;# 给jellyfin装载更多字体，使中文显示正确，不再是方块&lt;/span&gt;
      &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt; $&lt;span class=&#34;token punctuation&#34;&gt;{&lt;/span&gt;USERDIR&lt;span class=&#34;token punctuation&#34;&gt;}&lt;/span&gt;/nginx/resolv.conf&lt;span class=&#34;token punctuation&#34;&gt;:&lt;/span&gt;/etc/resolv.conf    &lt;span class=&#34;token comment&#34;&gt;# 定制dns&lt;/span&gt;
 &lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;赋予 emby，jellyfin 访问硬件加速驱动权限&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&lt;span class=&#34;token function&#34;&gt;chmod&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;755&lt;/span&gt; /dev/dri
&lt;span class=&#34;token function&#34;&gt;chmod&lt;/span&gt; &lt;span class=&#34;token number&#34;&gt;666&lt;/span&gt; /dev/dri/renderD128&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;TMM刮削，改名，目录整理&#34;&gt;&lt;strong&gt;TMM 刮削，改名，目录整理&lt;/strong&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;电影，电视剧，动画等视频为了更好的体验效果，需要刮削元数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一些命名不规范，不能被 emby 识别的剧集使用 tmm 刮削改名，配合硬链接工具，可以不影响做种的前提下改名，该目录。大文件硬链接，小文件直接复制方便刮削，推荐一个自己写的硬链接 bash shell 脚本，PTtool 在 nas，linux 环境使用更方便。&lt;/p&gt;
&lt;p&gt;电影，电视剧，动画完整刮削教程，见&lt;a href=&#34;https://blog.17lai.site/video/2021-10-11-how-to-scrape-video-whit-tinymediamanager/&#34;&gt;如何使用 tinyMediaManager 刮削电影和电视剧，动画，并自动下载字幕&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Github: &lt;a target=&#34;_blank&#34; rel=&#34;noopener&#34; href=&#34;https://github.com/appotry/PTtool&#34;&gt;appotry/PTtool&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Gitee: 镜像 &lt;a target=&#34;_blank&#34; rel=&#34;noopener&#34; href=&#34;https://gitee.com/bloodwolf/PTtool&#34;&gt;bloodwolf/PTtool&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.17lai.site/video/2021-10-11-how-to-scrape-video-whit-tinymediamanager/&#34;&gt;如何使用 tinyMediaManager 刮削电影和电视剧，动画，并自动下载字幕&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/08/1920210819001155.png&#34; alt=&#34;tmm&#34;&gt;&lt;/p&gt;
&lt;p&gt;注意：使用 v3 版本，不要升级到 v4，v4 版本收费。&lt;/p&gt;
&lt;h2 id=&#34;硬链接工具&#34;&gt;&lt;strong&gt;硬链接工具&lt;/strong&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;博主编写的脚本，自推一下，在 Nas，linux 环境使用的 Shell 脚本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PT hard link tools。方便 PT 用户硬链接文件，在最大可能情况下节约空间，并保持做种。 小于 1M 的文件直接复制，方便 emby，tmm 等工具刮削修改 nfo 等小文件。 大于 1M 的文件硬链接到目的目录，可以随意修改文件名，但是不能修改文件内容！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从此，做种，刮削改名两不误！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Github&lt;/strong&gt;: &lt;a target=&#34;_blank&#34; rel=&#34;noopener&#34; href=&#34;https://github.com/appotry/PTtool&#34;&gt;&lt;strong&gt;PTools&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt; 使用教程&lt;/strong&gt;： &lt;a href=&#34;https://blog.17lai.site/blogging/pt/2021-07-09-linux-pt-hard-link-tools/&#34;&gt;&lt;strong&gt;Linux PT 硬链接助手使用教程&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;BT下载工具&#34;&gt;&lt;strong&gt;BT 下载工具&lt;/strong&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;qBittorrent 下载，种子分类整理较好，但占用资源，内存较多。Transmissoin 种子整理分类远不如 qBittorrent，但资源占用低，是 PT 做种混魔力的首选！建议 qBittorrent 和 Transmissoin 搭配使用，使用 Iyuu 自动在两者之间转移种子。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;Transmissoin&#34;&gt;&lt;strong&gt;Transmissoin&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.17lai.site/bt/2021-08-18-transmission-parameter-reference-configuration/&#34;&gt;&lt;strong&gt;transmission 使用及其配置&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;qBittorrent&#34;&gt;qBittorrent&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.17lai.site/bt/2021-08-18-qbittorrent-parameter-reference-configuration/&#34;&gt;&lt;strong&gt;qBittorrent 参数详细设置教程&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;都分别有 docker 版本和套件版本。&lt;/p&gt;
&lt;p&gt;虽然下载工具很多，但 IYUU 只支持这两个辅种工具，开发者的话是这两个工具的 RPC 调用接口稳定。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/08/1920210819005826.png&#34; alt=&#34;Transmissoin&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/08/1920210819005858.png&#34; alt=&#34;qBittorrent&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;辅种工具IYUU&#34;&gt;&lt;strong&gt;辅种工具 IYUU&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Doker 版本&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a target=&#34;_blank&#34; rel=&#34;noopener&#34; href=&#34;https://hub.docker.com/r/iyuucn/iyuuautoreseed&#34;&gt;iyuucn/iyuuautoreseed&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;命令行版本&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a target=&#34;_blank&#34; rel=&#34;noopener&#34; href=&#34;https://hub.docker.com/r/iyuucn/iyuuplus&#34;&gt;iyuucn/iyuuplus&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;图形界面版本，更轻松上手。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自动辅种，解放双手，更多魔力，更容易养多站。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/08/1920210819010407.png&#34; alt=&#34;iyuuplus&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;字幕下载&#34;&gt;&lt;strong&gt;字幕下载&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;想要较好的自动下载字幕，最好用前面介绍的 tmm 刮削改名之后再使用下面工具。&lt;/p&gt;
&lt;h3 id=&#34;subfinder-自动下载字幕&#34;&gt;subfinder 自动下载字幕&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Docker： &lt;a target=&#34;_blank&#34; rel=&#34;noopener&#34; href=&#34;https://hub.docker.com/r/superng6/subfinder&#34;&gt;superng6/subfinder&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下载完成，刮削后的目录，挂载到 subfinder 的 media 目录，就会自动下载字幕。&lt;/p&gt;
&lt;p&gt;字幕下载对电影，英文剧集支持较好。对于一些 tv，动画手动下载字幕会更好一些。&lt;/p&gt;
&lt;p&gt;注意：官方的配置文件有问题，时效问题。修改 URL 到最新即可。&lt;/p&gt;
&lt;h3 id=&#34;chinesesubfinder&#34;&gt;chinesesubfinder&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h3 id=&#34;Docker：-allanpk716-chinesesubfinder&#34;&gt;Docker： &lt;a target=&#34;_blank&#34; rel=&#34;noopener&#34; href=&#34;https://hub.docker.com/r/allanpk716/chinesesubfinder&#34;&gt;allanpk716/chinesesubfinder&lt;/a&gt;&lt;/h3&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新开发的中文字幕查找工具，上面那个很久没更新了，这个刚出来。使用 nfo 里面刮削出来的文件名来匹配字幕。所以就原理来说，这个字幕匹配更准确。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bazarr&#34;&gt;bazarr&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Docker：&lt;a target=&#34;_blank&#34; rel=&#34;noopener&#34; href=&#34;https://hub.docker.com/r/linuxserver/bazarr&#34;&gt;linuxserver/bazarr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt; 字幕下载管理，配合 sonarr, radarr 使用效果更好。对于英文剧集命名规范的支持较好，比如 &lt;code&gt;[name]S01E01&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/08/1920210819002816.png&#34; alt=&#34;bazarr&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;电影管理&#34;&gt;电影管理&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;电影，电视剧，动画等视频都是类似。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;使用radarr管理电影&#34;&gt;&lt;strong&gt;使用 radarr 管理电影&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;radarr 示例图片&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/08/1920210819001114.png&#34; alt=&#34;radarr&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;使用Emby观看电影&#34;&gt;使用 Emby 观看电影&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/08/1920210819000847.png&#34; alt=&#34;emby&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;音乐管理&#34;&gt;音乐管理&lt;/h2&gt;
&lt;h3 id=&#34;使用lidarr管理音乐&#34;&gt;&lt;strong&gt;使用 lidarr 管理音乐&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/08/1920210819001200.png&#34; alt=&#34;lidarr示例图片&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;音乐刮削&#34;&gt;音乐刮削&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;使用 Mp3tag, MediaGo, MusicBrainZ 等工具刮削&lt;/p&gt;
&lt;p&gt;音乐刮削教程： &lt;a href=&#34;https://blog.17lai.site/music/2021-10-11-how-to-scrape-music-idtag/&#34;&gt;如何使用 media Go,MusicBrainz,Mp3tag 工具刮削音乐 整理音乐资料库&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/10/1120211011175602.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;使用Mstream听音乐&#34;&gt;使用 Mstream 听音乐&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;教程： &lt;a href=&#34;https://blog.17lai.site/music/2021-10-06-private-music-service/&#34;&gt;私人在线音乐服务器搭建与使用介绍&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/10/0620211006015739.png&#34; alt=&#34;私人音乐服务&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;Docker管理&#34;&gt;Docker 管理&lt;/h2&gt;
&lt;h3 id=&#34;使用docker-compose-管理docker配置文件，一键安装，升级&#34;&gt;使用 docker compose 管理 docker 配置文件，一键安装，升级&lt;/h3&gt;
&lt;h3 id=&#34;使用portainer管理docker&#34;&gt;&lt;strong&gt;使用 portainer 管理 docker&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/08/1920210819001116.png&#34; alt=&#34;portainer&#34;&gt;&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;version: &lt;span class=&#34;token string&#34;&gt;&#39;3&#39;&lt;/span&gt;
services:
  portainer-ce:
    container_name:  portainer-ce
    image: portainer/portainer-ce
    command: -H unix:///var/run/docker.sock
    restart: always
    ports:
      - &lt;span class=&#34;token number&#34;&gt;9300&lt;/span&gt;:9000
      - &lt;span class=&#34;token number&#34;&gt;9301&lt;/span&gt;:8000
    environment:
      - &lt;span class=&#34;token assign-left variable&#34;&gt;TZ&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;Asia/Shanghai
      - &lt;span class=&#34;token assign-left variable&#34;&gt;&lt;span class=&#34;token environment constant&#34;&gt;LANG&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;token operator&#34;&gt;=&lt;/span&gt;en_US.UTF-8
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - /share/Container/portainer_data:/data&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;使用watchtower自动升级docker&#34;&gt;&lt;strong&gt;使用 watchtower 自动升级 docker&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;使所有软件保持最新最佳状态&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/08/1920210819001124.png&#34; alt=&#34;watchtower&#34;&gt;&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-yaml&#34; data-language=&#34;yaml&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;&lt;span class=&#34;token key atrule&#34;&gt;version&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;token string&#34;&gt;&#39;3&#39;&lt;/span&gt;
&lt;span class=&#34;token key atrule&#34;&gt;services&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;:&lt;/span&gt;
  &lt;span class=&#34;token key atrule&#34;&gt;watchtower&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;:&lt;/span&gt;
    &lt;span class=&#34;token key atrule&#34;&gt;container_name&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;:&lt;/span&gt; watchtower
    &lt;span class=&#34;token key atrule&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;:&lt;/span&gt; containrrr/watchtower&lt;span class=&#34;token punctuation&#34;&gt;:&lt;/span&gt;latest
    &lt;span class=&#34;token key atrule&#34;&gt;volumes&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;:&lt;/span&gt;
      &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt; /var/run/docker.sock&lt;span class=&#34;token punctuation&#34;&gt;:&lt;/span&gt;/var/run/docker.sock
    &lt;span class=&#34;token key atrule&#34;&gt;environment&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;:&lt;/span&gt;
      &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt; TZ=Asia/Shanghai
      &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt; WATCHTOWER_CLEANUP=true
      &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt; WATCHTOWER_SCHEDULE=0 0 1 * * *
    &lt;span class=&#34;token key atrule&#34;&gt;restart&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;:&lt;/span&gt; always
    &lt;span class=&#34;token key atrule&#34;&gt;command&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;:&lt;/span&gt; nginx redis&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述配置文件中 &lt;code&gt;volumes&lt;/code&gt; 使用了绝对路径，使这个容器能访问系统 &lt;code&gt;docker.sock&lt;/code&gt; 目录，用于方便监控容器镜像的版本以便更新。其他的一些环境变量，例如时区，清理旧镜像，定时任务都转换为 &lt;code&gt;environment&lt;/code&gt;, 而特殊的 &lt;code&gt;command&lt;/code&gt; 命令则定义了指定监控 &lt;code&gt;nginx&lt;/code&gt; 和 &lt;code&gt;redis&lt;/code&gt; 两个容器。没有 command 这一行，默认监控升级所有运行中的 docker&lt;/p&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&lt;span class=&#34;token comment&#34;&gt;# 运行一次，更新所有的容器，并清除旧的容器 &lt;/span&gt;
&lt;span class=&#34;token function&#34;&gt;docker&lt;/span&gt; run -d --name watchtower -v /var/run/docker.sock:/var/run/docker.sock containrrr/watchtower --cleanup --run-once&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&lt;span class=&#34;token comment&#34;&gt;#只更新nginx和redis&lt;/span&gt;
&lt;span class=&#34;token function&#34;&gt;docker&lt;/span&gt; run -d --name watchtower -v /var/run/docker.sock:/var/run/docker.sock containrrr/watchtower --cleanup --run-once nginx redis&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;使用muximux来管理多个docker入口&#34;&gt;&lt;strong&gt;使用 muximux 来管理多个 docker 入口&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;主页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/08/1920210819001210.png&#34; alt=&#34;muximux&#34;&gt;&lt;/p&gt;
&lt;p&gt;配置页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/08/1920210819001131.png&#34; alt=&#34;muximux&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;更进阶定制本地域名访问&#34;&gt;&lt;strong&gt;更进阶定制本地域名访问&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&#34;nginx-管理域名访问&#34;&gt;&lt;strong&gt;nginx 管理域名访问&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Docker: &lt;a target=&#34;_blank&#34; rel=&#34;noopener&#34; href=&#34;https://hub.docker.com/r/bloodstar/nginx-purge&#34;&gt;bloodstar/nginx-purge&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Github： &lt;a target=&#34;_blank&#34; rel=&#34;noopener&#34; href=&#34;https://github.com/appotry/nginx-purge-docker&#34;&gt;nginx&lt;/a&gt;&lt;/li&gt;
&lt;li&gt; 去掉烦人的端口后缀，实现 80,443 端口复用。这个 docker 是博主定制功能版。&lt;/li&gt;
&lt;li&gt;配置 SSL 证书访问，密码等敏感数据从此加密传输。并可以使用 http2 高级特性。&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/08/1920210819010407.png&#34; alt=&#34;nginx&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;version: &lt;span class=&#34;token string&#34;&gt;&#39;3&#39;&lt;/span&gt;
services:
  nginxweb:
    image: bloodstar/nginx-purge
    container_name: &lt;span class=&#34;token string&#34;&gt;&#34;nginxweb&#34;&lt;/span&gt;
    hostname: nginxweb
    ports:
      - &lt;span class=&#34;token string&#34;&gt;&#34;80:80&#34;&lt;/span&gt;
      - &lt;span class=&#34;token string&#34;&gt;&#34;443:443&#34;&lt;/span&gt;
    restart: always
    volumes:
      &lt;span class=&#34;token comment&#34;&gt;# 映射主机目录&lt;/span&gt;
      - &lt;span class=&#34;token variable&#34;&gt;${USERDIR}&lt;/span&gt;/nginx/conf.d:/etc/nginx/conf.d:ro
      - &lt;span class=&#34;token variable&#34;&gt;${USERDIR}&lt;/span&gt;/nginxproxy/certs:/etc/nginx/certs:ro
      - &lt;span class=&#34;token variable&#34;&gt;${USERDIR}&lt;/span&gt;/nginx/nginx.conf:/etc/nginx/nginx.conf:ro&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里推荐博主制作的 nginx docker 镜像： &lt;a target=&#34;_blank&#34; rel=&#34;noopener&#34; href=&#34;https://hub.docker.com/r/bloodstar/nginx-purge&#34;&gt;bloodstar/nginx-purge&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;支持 ARM64, ARMV7, AMD64 ，增加 CA 证书，防火墙，brotli, Proxy-cache-purge, htpasswd 支持&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;DNS-域名管理&#34;&gt;&lt;strong&gt;DNS 域名管理&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/08/1920210819003924.png&#34; alt=&#34;DNS&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;和 nginx 配合使用。 简单的可以直接修改 &lt;code&gt;/etc/hosts&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DNSCrypt Proxy： 作为 DNS 前端访问 DOH 的 DNS&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DNSMasq： 作为 DNS 后端，连接到 DNSCrypt Proxy，并配置本地域名。还可以添加 DNS 去广告功能，浏览器插件去广告非常消耗 CPU 和内存，但是在 DNS 前端去广告，资源消耗低，并一次性解决所有的访问终端（pc，手机，平板）广告问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;配置一个去广告，本地域名管理工具。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Xteve-看IPTV&#34;&gt;&lt;strong&gt;Xteve 看 IPTV&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Docker: &lt;a target=&#34;_blank&#34; rel=&#34;noopener&#34; href=&#34;https://hub.docker.com/r/dnsforge/xteve&#34;&gt;dnsforge/xteve&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;结合 Emby， jellyfin 直接看 iptv。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/08/1920210819010804.png&#34; alt=&#34;Xteve&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;注意事项&#34;&gt;注意事项&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;tmm，jackett，sonarr 最好配置代理。否则，刮削，图片墙可能工作不正常。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;docker 最好配置镜像加速，提高安装 docker 速度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一些 docker 初始化安装，运行、更新时需要访问 github，最好配置代理。推荐博主定制 Docker &lt;a target=&#34;_blank&#34; rel=&#34;noopener&#34; href=&#34;https://hub.docker.com/r/bloodstar/v2fly-privoxy&#34;&gt;bloodstar/v2fly-privoxy&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;link rel=&#34;stylesheet&#34; href=&#34;/css/bilicard.css&#34; type=&#34;text/css&#34;&gt;</content>
        <category term="Emby" />
        <category term="Sonarr" />
        <category term="Jeckett" />
        <category term="Portainer" />
        <category term="Watchtower" />
        <category term="DNSMasq" />
        <category term="DNSCrypt" />
        <updated>2021-09-01T10:25:00.000Z</updated>
    </entry>
    <entry>
        <id>https://blog.17lai.site/posts/42b6a86d/</id>
        <title>docker 使用简明教程</title>
        <link rel="alternate" href="https://blog.17lai.site/posts/42b6a86d/"/>
        <content type="html">&lt;link rel=&#34;stylesheet&#34; class=&#34;aplayer-secondary-style-marker&#34; href=&#34;/assets/css/APlayer.min.css&#34;&gt;&lt;script src=&#34;/assets/js/APlayer.min.js&#34; class=&#34;aplayer-secondary-script-marker&#34;&gt;&lt;/script&gt;&lt;p&gt;关于 docker 安装，查看，镜像管理，以及一个实用 Dockerfile， LAMP，PHP，LTMJ。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关于本 blog，&lt;strong&gt;图床&lt;/strong&gt;一般使用 &lt;strong&gt;github&lt;/strong&gt;，已经配置了 CDN，如果图片还是未显示请自行代理解决&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;一、Docker安装&#34;&gt;一、Docker 安装&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在 Ubuntu 系统下安装：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;line-numbers language-shell&#34; data-language=&#34;shell&#34;&gt;&lt;code class=&#34;language-shell&#34;&gt;&lt;span class=&#34;token function&#34;&gt;apt-get&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;install&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;docker&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;在 Fedora/CentOS 系统下安装：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;line-numbers language-shell&#34; data-language=&#34;shell&#34;&gt;&lt;code class=&#34;language-shell&#34;&gt;yum &lt;span class=&#34;token function&#34;&gt;install&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;docker&lt;/span&gt;
dnf &lt;span class=&#34;token function&#34;&gt;install&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;docker&lt;/span&gt; &lt;span class=&#34;token comment&#34;&gt;# Fedora 25+&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;在 SUSE 系统下安装：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;line-numbers language-shell&#34; data-language=&#34;shell&#34;&gt;&lt;code class=&#34;language-shell&#34;&gt;&lt;span class=&#34;token function&#34;&gt;zypper&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;install&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;docker&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;二、Docker容器&#34;&gt;二、Docker 容器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;首先启动 Docker&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;line-numbers language-shell&#34; data-language=&#34;shell&#34;&gt;&lt;code class=&#34;language-shell&#34;&gt;&lt;span class=&#34;token comment&#34;&gt;# 启动Docker&lt;/span&gt;
systemctl start &lt;span class=&#34;token function&#34;&gt;docker&lt;/span&gt;
&lt;span class=&#34;token comment&#34;&gt;# 设置开机自启动，可选&lt;/span&gt;
systemctl &lt;span class=&#34;token builtin class-name&#34;&gt;enable&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;docker&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;启动 Docker 测试容器 &lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;line-numbers language-shell&#34; data-language=&#34;shell&#34;&gt;&lt;code class=&#34;language-shell&#34;&gt;&lt;span class=&#34;token function&#34;&gt;docker&lt;/span&gt; run &lt;span class=&#34;token string&#34;&gt;&#34;hello-world&#34;&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;在启动容器时，如果使用的镜像在本地不存在，会尝试从网络上获取。&lt;/li&gt;
&lt;li&gt;在一般情况下，启动 Web 服务的容器，使用以下命令：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;line-numbers language-shell&#34; data-language=&#34;shell&#34;&gt;&lt;code class=&#34;language-shell&#34;&gt;&lt;span class=&#34;token comment&#34;&gt;# -d：daemon，使容器在后台运行&lt;/span&gt;
&lt;span class=&#34;token comment&#34;&gt;# -p：port，指定容器的端口，这里是将容器的80端口映射到主机的8001端口&lt;/span&gt;
&lt;span class=&#34;token function&#34;&gt;docker&lt;/span&gt; run -d -p &lt;span class=&#34;token number&#34;&gt;8001&lt;/span&gt;:80 &lt;span class=&#34;token string&#34;&gt;&#34;image_name&#34;&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;查看容器运行情况 &lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;line-numbers language-shell&#34; data-language=&#34;shell&#34;&gt;&lt;code class=&#34;language-shell&#34;&gt;&lt;span class=&#34;token function&#34;&gt;docker&lt;/span&gt; &lt;span class=&#34;token function&#34;&gt;ps&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Docker 会为容器分配一个 Container ID 和一个 Container Name，Name 可以在运行时通过 &lt;code&gt;-name&lt;/code&gt; 自行指定，这两个可以用来标识容器。&lt;/li&gt;
&lt;li&gt;需要停止容器时，使用以下命令：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;line-numbers language-shell&#34; data-language=&#34;shell&#34;&gt;&lt;code class=&#34;language-shell&#34;&gt;&lt;span class=&#34;token function&#34;&gt;docker&lt;/span&gt; stop &lt;span class=&#34;token string&#34;&gt;&#34;container_name&#34;&lt;/span&gt;
&lt;span class=&#34;token comment&#34;&gt;# 或使用ID查找&lt;/span&gt;
&lt;span class=&#34;token function&#34;&gt;docker&lt;/span&gt; stop &lt;span class=&#34;token string&#34;&gt;&#34;container_id&#34;&lt;/span&gt;
&lt;span class=&#34;token comment&#34;&gt;# 重启&lt;/span&gt;
&lt;span class=&#34;token function&#34;&gt;docker&lt;/span&gt; restart &lt;span class=&#34;token string&#34;&gt;&#34;container_id&#34;&lt;/span&gt;&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;三、Docker镜像&#34;&gt;三、Docker 镜像&lt;/h2&gt;
&lt;h3 id=&#34;Dokerfile编译镜像&#34;&gt;Dokerfile 编译镜像&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Docker 容器是运行的 Docker 镜像实例，一般情况下，我们需要制作自己的 Docker 镜像。&lt;/li&gt;
&lt;li&gt;Docker 镜像的制作依赖于 Dockerfile，我们稍后在讨论 Dockerfile 的编写，这里假定我们有一个编写好的 Dockerfile。&lt;/li&gt;
&lt;li&gt;下面的命令将在当前路径查找 Dockerfile 并构建一个名为 “image_name” 的镜像。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;line-numbers language-shell&#34; data-language=&#34;shell&#34;&gt;&lt;code class=&#34;language-shell&#34;&gt;&lt;span class=&#34;token function&#34;&gt;docker&lt;/span&gt; build -t &lt;span class=&#34;token string&#34;&gt;&#34;image_name&#34;&lt;/span&gt; ./&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;查看本地所有镜像&#34;&gt;查看本地所有镜像&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在构建过程中需要在网络上下载来源镜像，可能需要一段时间。&lt;/li&gt;
&lt;li&gt;如果 Dockerfile 中的命令都正确结束（Exit code 0），那么 Docker 镜像的构建也将顺利完成，我们可以通过下面的命令查看我们的所有镜像：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;line-numbers language-shell&#34; data-language=&#34;shell&#34;&gt;&lt;code class=&#34;language-shell&#34;&gt;&lt;span class=&#34;token function&#34;&gt;docker&lt;/span&gt; images&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;导出备份已有镜像文件&#34;&gt;导出备份已有镜像文件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;我们还可以导出我们制作好的 Docker 镜像，下面的命令将 image_name 镜像导出为 image_name.tar&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;line-numbers language-shell&#34; data-language=&#34;shell&#34;&gt;&lt;code class=&#34;language-shell&#34;&gt;&lt;span class=&#34;token function&#34;&gt;docker&lt;/span&gt; save &lt;span class=&#34;token string&#34;&gt;&#34;image_name&#34;&lt;/span&gt; &lt;span class=&#34;token operator&#34;&gt;&amp;gt;&lt;/span&gt; image_name.tar&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;导入已有镜像备份&#34;&gt;导入已有镜像备份&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在另一台机器上，我们不需要网络就可以导入并使用该镜像：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;line-numbers language-shell&#34; data-language=&#34;shell&#34;&gt;&lt;code class=&#34;language-shell&#34;&gt;&lt;span class=&#34;token function&#34;&gt;docker&lt;/span&gt; load &lt;span class=&#34;token operator&#34;&gt;&amp;lt;&lt;/span&gt; image_name.tar&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;四、Dockerfile&#34;&gt;四、Dockerfile&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Dockerfile 本质上是一组命令集合，用于自动化构建镜像，下面以几个实例来说明 Dockerfile 的编写方法：&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;实例一：LAMP（Linux-Apache-MySQL-PHP）环境配置&#34;&gt;实例一：LAMP（Linux+Apache+MySQL+PHP）环境配置&lt;/h3&gt;
&lt;pre class=&#34;line-numbers language-yaml&#34; data-language=&#34;yaml&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;&lt;span class=&#34;token comment&#34;&gt;# 来源镜像，一般可以使用标准的系统或者带有各种环境的系统&lt;/span&gt;
&lt;span class=&#34;token comment&#34;&gt;# 显然这里使用的是标准的Ubuntu 14.04系统&lt;/span&gt;
FROM ubuntu&lt;span class=&#34;token punctuation&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;14.04&lt;/span&gt;
&lt;span class=&#34;token comment&#34;&gt;# 镜像作者&lt;/span&gt;
MAINTAINER wrlu
&lt;span class=&#34;token comment&#34;&gt;# 刷新日期&lt;/span&gt;
ENV REFRESHED_AT 2018&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;08&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;05&lt;/span&gt;
&lt;span class=&#34;token comment&#34;&gt;# 设定字符集&lt;/span&gt;
ENV LANG C.UTF&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;8&lt;/span&gt;
&lt;span class=&#34;token comment&#34;&gt;# RUN命令用于执行系统命令&lt;/span&gt;
&lt;span class=&#34;token comment&#34;&gt;# 因为需要自动化安装，所以最好通过-y命令跳过确认&lt;/span&gt;
&lt;span class=&#34;token comment&#34;&gt;# 更新APT软件源&lt;/span&gt;
RUN apt&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;get update &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;y
&lt;span class=&#34;token comment&#34;&gt;# 安装MySQL&lt;/span&gt;
RUN apt&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;get &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;y install mysql&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;server
&lt;span class=&#34;token comment&#34;&gt;# 安装Apache&lt;/span&gt;
RUN apt&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;get &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;y install apache2
&lt;span class=&#34;token comment&#34;&gt;# 安装PHP5&lt;/span&gt;
RUN apt&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;get &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;y install php5 libapache2&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;mod&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;php5
RUN apt&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;get install &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;yqq php5&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;mysql php5&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;curl php5&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;gd php5&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;intl php&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;pear php5&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;imagick php5&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;imap php5&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;mcrypt php5&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;memcache php5&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;ming php5&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;ps php5&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;pspell php5&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;recode php5&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;snmp php5&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;sqlite php5&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;tidy php5&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;xmlrpc php5&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;xsl
&lt;span class=&#34;token comment&#34;&gt;# 删除Apache2列出目录配置&lt;/span&gt;
RUN sed &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;i &#39;s/Options Indexes FollowSymLinks/Options None/&#39; /etc/apache2/apache2.conf
&lt;span class=&#34;token comment&#34;&gt;# COPY命令可以复制文件，但是似乎不能递归复制文件&lt;/span&gt;
COPY IncludeAirline/* /var/www/html/
COPY IncludeAirline/airlines/* /var/www/html/airlines/
&lt;span class=&#34;token comment&#34;&gt;# 删除默认的主页&lt;/span&gt;
RUN rm /var/www/html/index.html
&lt;span class=&#34;token comment&#34;&gt;# 复制启动脚本&lt;/span&gt;
COPY start.sh /root/start.sh
RUN chmod +x /root/start.sh
&lt;span class=&#34;token comment&#34;&gt;# 设置启动目录以及启动脚本&lt;/span&gt;
ENTRYPOINT cd /root; ./start.sh
&lt;span class=&#34;token comment&#34;&gt;# 设置需要暴露的端口&lt;/span&gt;
EXPOSE 80&lt;span class=&#34;token punctuation&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;3306&lt;/span&gt; &lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;本例中还有一个启动脚本 &lt;code&gt;start.sh&lt;/code&gt;，用于导入数据库，编写如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;line-numbers language-yaml&#34; data-language=&#34;yaml&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;&lt;span class=&#34;token comment&#34;&gt;#!/bin/bash&lt;/span&gt;
&lt;span class=&#34;token comment&#34;&gt;# 启动后延时&lt;/span&gt;
sleep 1
&lt;span class=&#34;token comment&#34;&gt;# 启动Apache服务器&lt;/span&gt;
/etc/init.d/apache2 start
&lt;span class=&#34;token comment&#34;&gt;# 启动MySQL数据库&lt;/span&gt;
find /var/lib/mysql &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;type f &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;exec touch &lt;span class=&#34;token punctuation&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;}&lt;/span&gt; ; &lt;span class=&#34;token important&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; service mysql start
&lt;span class=&#34;token comment&#34;&gt;# 定义SQL文件路径&lt;/span&gt;
sqlfile=/var/www/html/includeAirline.sql
if &lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;f $flagfile &lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;; then
	&lt;span class=&#34;token comment&#34;&gt;# 修改MySQL的密码&lt;/span&gt;
    mysqladmin &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;u root password &#34;root&#34;
    &lt;span class=&#34;token comment&#34;&gt;# 登录MySQL并导入SQL文件执行&lt;/span&gt;
    mysql &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;uroot &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;proot &amp;lt; $sqlfile
    &lt;span class=&#34;token comment&#34;&gt;# 删除SQL文件&lt;/span&gt;
    rm &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;f $sqlfile
fi
&lt;span class=&#34;token comment&#34;&gt;# 此处注意，如果命令执行完后脚本退出&lt;/span&gt;
&lt;span class=&#34;token comment&#34;&gt;# 则Docker容器也会因为没有前台应用运行而中止&lt;/span&gt;
&lt;span class=&#34;token comment&#34;&gt;# 所以这里使用一个前台命令来保活Docker容器&lt;/span&gt;
tail &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;f /var/log/apache2/error.log&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;实例二：PHP环境配置：&#34;&gt;实例二：PHP 环境配置：&lt;/h3&gt;
&lt;pre class=&#34;line-numbers language-yaml&#34; data-language=&#34;yaml&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;&lt;span class=&#34;token comment&#34;&gt;# 来源镜像，自带Apache+PHP环境&lt;/span&gt;
FROM php&lt;span class=&#34;token punctuation&#34;&gt;:&lt;/span&gt;7.0&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;apache
MAINTAINER tl
ENV REFRESHED_AT 2018‐08‐03
ENV LANG C.UTF‐8
&lt;span class=&#34;token comment&#34;&gt;# ADD命令在COPY命令的基础上，具有自动解包tar的功能&lt;/span&gt;
ADD web_tired.tar /var/www/html/
EXPOSE 80&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;实例三：LTMJ（Linux-Tomcat-MySQL-JSP）环境配置&#34;&gt;实例三：LTMJ（Linux+Tomcat+MySQL+JSP）环境配置&lt;/h3&gt;
&lt;pre class=&#34;line-numbers language-yaml&#34; data-language=&#34;yaml&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;FROM ubuntu&lt;span class=&#34;token punctuation&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;16.04&lt;/span&gt;
MAINTAINER wrlu
ENV REFRESHED_AT 2018&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;08&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;05&lt;/span&gt;
ENV LANG C.UTF&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;token number&#34;&gt;8&lt;/span&gt;
RUN apt&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;get update &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;y
RUN apt&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;get &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;y install mysql&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;server
&lt;span class=&#34;token comment&#34;&gt;# 安装wget，因为Docker提供的镜像是最小镜像，所以用到的其他工具需要自行安装&lt;/span&gt;
RUN apt&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;get &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;y install wget
&lt;span class=&#34;token comment&#34;&gt;# 安装Java 8&lt;/span&gt;
RUN apt&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;get &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;y install openjdk&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;8&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;jre
&lt;span class=&#34;token comment&#34;&gt;# 下载Tomcat 8服务器&lt;/span&gt;
RUN wget http&lt;span class=&#34;token punctuation&#34;&gt;:&lt;/span&gt;//mirrors.hust.edu.cn/apache/tomcat/tomcat&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;8/v8.5.32/bin/apache&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;tomcat&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;8.5.32.tar.gz
&lt;span class=&#34;token comment&#34;&gt;# 解压tar.gz&lt;/span&gt;
RUN tar &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;xzf apache&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;tomcat&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;8.5.32.tar.gz &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;C /root
RUN mv /root/apache&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;tomcat&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;8.5.32 /root/tomcat
&lt;span class=&#34;token comment&#34;&gt;# 删除默认页面&lt;/span&gt;
RUN rm &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;rf /root/tomcat/webapps/*
&lt;span class=&#34;token comment&#34;&gt;# 拷贝war文件&lt;/span&gt;
COPY CAAC&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;SQL&lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;Injection.war /root/tomcat/webapps/
COPY wafwtf.sql /root/
COPY start.sh /root/start.sh
RUN chmod +x /root/start.sh
ENTRYPOINT cd /root; ./start.sh
&lt;span class=&#34;token comment&#34;&gt;# Tomcat使用8080端口，不同于Apache&lt;/span&gt;
EXPOSE 8080&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;启动脚本如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;line-numbers language-yaml&#34; data-language=&#34;yaml&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;&lt;span class=&#34;token comment&#34;&gt;#!/bin/bash&lt;/span&gt;
sleep 1
find /var/lib/mysql &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;type f &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;exec touch &lt;span class=&#34;token punctuation&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;token punctuation&#34;&gt;}&lt;/span&gt; ; &lt;span class=&#34;token important&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; service mysql start
chmod +x /root/tomcat/bin/startup.sh
&lt;span class=&#34;token comment&#34;&gt;# 启动Tomcat服务器&lt;/span&gt;
/root/tomcat/bin/startup.sh
sqlfile=/root/wafwtf.sql
if &lt;span class=&#34;token punctuation&#34;&gt;[&lt;/span&gt; &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;f $flagfile &lt;span class=&#34;token punctuation&#34;&gt;]&lt;/span&gt;; then
    mysqladmin &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;u root password &#34;root&#34;
    mysql &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;uroot &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;proot &amp;lt; $sqlfile
    rm &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;f $sqlfile
fi
&lt;span class=&#34;token comment&#34;&gt;# 容器保活&lt;/span&gt;
tail &lt;span class=&#34;token punctuation&#34;&gt;-&lt;/span&gt;f /root/tomcat/conf/server.xml&lt;span aria-hidden=&#34;true&#34; class=&#34;line-numbers-rows&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;link rel=&#34;stylesheet&#34; href=&#34;/css/bilicard.css&#34; type=&#34;text/css&#34;&gt;</content>
        <category term="Linux" />
        <category term="MySQL" />
        <category term="Docker" />
        <category term="LAMP" />
        <category term="PHP" />
        <category term="Tomcat" />
        <category term="JSP" />
        <category term="教程" />
        <updated>2021-08-01T12:25:00.000Z</updated>
    </entry>
</feed>
