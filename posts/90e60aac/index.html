<!DOCTYPE HTML><html lang="zh-CN"><head><link href="https://cdn.jsdelivr.net/npm/hexo-tag-common@0.0.5/css/index.css" rel="stylesheet"><meta charset="utf-8"><meta name="keywords" content="docker, shell, linux"><meta name="description" content="通过一系列的实验使用户对docker的底层技术，如Namespace、CGroups、rootfs、联合加载等有一个感性的认识。在此过程中，我们还将通过Shell脚本一步一步地实现一个简易的docker，以期使读者在使用docker的过程中知其然知其所以然。"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="apple-mobile-web-app-title" content="夜法之书"><meta name="theme-color" content="#7e9fc4"><meta name="msapplication-TileImage" content="/medias_webp/icons/android-chrome-192x192.png"><meta name="msapplication-TileColor" content="#7e9fc4"><link rel="apple-touch-icon" href="/medias_webp/icons/apple-touch-icon.png"><meta name="referrer" content="no-referrer-when-downgrade"><title>使用 Shell 脚本实现一个简单 Docker | 夜法之书</title><link rel="manifest" href="/manifest.json"><link rel="icon" type="image/png" href="/favicon.png"><link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css"><link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css"><link rel="stylesheet" type="text/css" href="/libs/aos/aos.css"><link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css"><link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" type="text/css" href="/css/matery.css"><link rel="stylesheet" type="text/css" href="/css/my.css"><link rel="stylesheet" type="text/css" href="/css/dark.css"><link rel="alternate" type="application/atom+xml" title="所有订阅--夜法之书" href="https://blog.17lai.site/atom.xml"><script src="/libs/jquery/jquery-3.6.0.min.js"></script><meta name="generator" content="Hexo 6.1.0"><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style></head><style>body{background-image:url(https://cdn.jsdelivr.net/gh/appotry/hexo@latest/medias_webp/sea.webp);background-repeat:no-repeat;background-size:100% 100%;background-attachment:fixed}</style><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"> <a href="/" class="waves-effect waves-light"><img no-lazy src="/medias/logo.png" style="width:40px;height:45px" class="logo-img" alt="LOGO"> <span class="logo-span">夜法之书</span></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item menu-2d-home"><a href="/" class="waves-effect waves-light"><i class="fas fa-home" style="zoom:.6"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item menu-2d-nav"><a href="https://nav.17lai.site/" class="waves-effect waves-light"><i class="fas fa-suitcase" style="zoom:.6"></i> <span>导航</span></a></li><li class="hide-on-med-and-down nav-item menu-2d-media"><a href="" class="waves-effect waves-light"><i class="fas fa-music" style="zoom:.6"></i> <span>多媒体</span><i class="fas fa-chevron-down" aria-hidden="true" style="zoom:.6"></i></a><ul class="sub-nav menus_item_child"><li class="menu-2d-musics"><a href="/musics"><i class="fas fa-music" style="margin-top:-20px;zoom:.6"></i> <span>音乐</span></a></li><li class="menu-2d-galleries"><a href="/galleries"><i class="fas fa-image" style="margin-top:-20px;zoom:.6"></i> <span>相册</span></a></li><li class="menu-2d-movies"><a href="/movies"><i class="fas fa-film" style="margin-top:-20px;zoom:.6"></i> <span>视频</span></a></li><li class="menu-2d-musicplayer"><a href="https://musicplayer.17lai.site/"><i class="fas fa-music" style="margin-top:-20px;zoom:.6"></i> <span>在线云音乐</span></a></li><li class="menu-2d-music"><a href="https://music.17lai.site/"><i class="fas fa-music" style="margin-top:-20px;zoom:.6"></i> <span>音乐播放器</span></a></li></ul></li><li class="hide-on-med-and-down nav-item menu-2d-posts"><a href="" class="waves-effect waves-light"><i class="fas fa-folder-plus" style="zoom:.6"></i> <span>文章</span><i class="fas fa-chevron-down" aria-hidden="true" style="zoom:.6"></i></a><ul class="sub-nav menus_item_child"><li class="menu-2d-tags"><a href="/tags"><i class="fas fa-tags" style="margin-top:-20px;zoom:.6"></i> <span>标签</span></a></li><li class="menu-2d-categories"><a href="/categories"><i class="fas fa-bookmark" style="margin-top:-20px;zoom:.6"></i> <span>分类</span></a></li><li class="menu-2d-archives"><a href="/archives"><i class="fas fa-archive" style="margin-top:-20px;zoom:.6"></i> <span>归档</span></a></li></ul></li><li class="hide-on-med-and-down nav-item menu-2d-friends"><a href="/friends" class="waves-effect waves-light"><i class="fas fa-link" style="zoom:.6"></i> <span>友链</span></a></li><li class="hide-on-med-and-down nav-item menu-2d-comments"><a href="" class="waves-effect waves-light"><i class="fas fa-comments" style="zoom:.6"></i> <span>交流</span><i class="fas fa-chevron-down" aria-hidden="true" style="zoom:.6"></i></a><ul class="sub-nav menus_item_child"><li class="menu-2d-contact"><a href="/contact"><i class="fas fa-comments" style="margin-top:-20px;zoom:.6"></i> <span>留言</span></a></li><li class="menu-2d-tg"><a href="https://t.me/joinchat/Sg3__qc4LBE2VsLO"><i class="fab fa-telegram-plane" style="margin-top:-20px;zoom:.6"></i> <span>TG群</span></a></li></ul></li><li class="hide-on-med-and-down nav-item menu-2d-cheatsheets"><a href="" class="waves-effect waves-light"><i class="fas fa-code" style="zoom:.6"></i> <span>快查</span><i class="fas fa-chevron-down" aria-hidden="true" style="zoom:.6"></i></a><ul class="sub-nav menus_item_child"><li class="menu-2d-vim"><a href="/cheatsheets/Vim_CN.docset/Contents/Resources/Documents/"><i class="fab fa-vimeo-v" style="margin-top:-20px;zoom:.6"></i> <span>Vim快查表</span></a></li><li class="menu-2d-vscode"><a href="/cheatsheets/Visual_Studio_Code.docset/Contents/Resources/Documents/"><i class="fas fa-code" style="margin-top:-20px;zoom:.6"></i> <span>VSCode快查表</span></a></li><li class="menu-2d-git"><a href="/cheatsheets/Git.docset/Contents/Resources/Documents/"><i class="fab fa-git-square" style="margin-top:-20px;zoom:.6"></i> <span>Git快查表</span></a></li><li class="menu-2d-sql"><a href="/cheatsheets/SQLite.docset/Contents/Resources/Documents/"><i class="fas fa-database" style="margin-top:-20px;zoom:.6"></i> <span>SQLite快查表</span></a></li><li class="menu-2d-tmux"><a href="/cheatsheets/tmux.docset/Contents/Resources/Documents/"><i class="fas fa-terminal" style="margin-top:-20px;zoom:.6"></i> <span>Tmux快查表</span></a></li><li class="menu-2d-bash"><a href="/cheatsheets/Bash_Shortcuts.docset/Contents/Resources/Documents/"><i class="fas fa-terminal" style="margin-top:-20px;zoom:.6"></i> <span>Bash快查表</span></a></li><li class="menu-2d-dash"><a href="/dash/"><i class="fas fa-laptop-code" style="margin-top:-20px;zoom:.6"></i> <span>更多快查表</span></a></li></ul></li><li class="hide-on-med-and-down nav-item menu-2d-toolbox"><a href="" class="waves-effect waves-light"><i class="fas fa-toolbox" style="zoom:.6"></i> <span>工具</span><i class="fas fa-chevron-down" aria-hidden="true" style="zoom:.6"></i></a><ul class="sub-nav menus_item_child"><li class="menu-2d-linuxtool"><a href="https://linux-command.17lai.site/"><i class="fas fa-terminal" style="margin-top:-20px;zoom:.6"></i> <span>Linux命令</span></a></li><li class="menu-2d-encdec"><a href="http://encode.chahuo.com/"><i class="fas fa-tools" style="margin-top:-20px;zoom:.6"></i> <span>加密解密</span></a></li><li class="menu-2d-markmap"><a href="https://markmap.js.org/repl"><i class="fas fa-brain" style="margin-top:-20px;zoom:.6"></i> <span>思维导图</span></a></li><li class="menu-2d-aIcon"><a href="https://fontawesome.com/v5.15/icons"><i class="fab fa-font-awesome" style="margin-top:-20px;zoom:.6"></i> <span>Awesome</span></a></li><li class="menu-2d-zhanzhang"><a href="http://ping.chinaz.com/"><i class="fas fa-tools" style="margin-top:-20px;zoom:.6"></i> <span>站长工具</span></a></li><li class="menu-2d-toolport"><a href="http://tool.chinaz.com/port/"><i class="fas fa-tools" style="margin-top:-20px;zoom:.6"></i> <span>端口扫描</span></a></li><li class="menu-2d-webssh"><a href="https://ssh.17lai.site/"><i class="fas fa-tools" style="margin-top:-20px;zoom:.6"></i> <span>WebSSH</span></a></li><li class="menu-2d-saveso"><a href="https://so.17lai.site/"><i class="fas fa-tools" style="margin-top:-20px;zoom:.6"></i> <span>安全搜索</span></a></li><li class="menu-2d-staticnav"><a href="/nav"><i class="fas fa-tools" style="margin-top:-20px;zoom:.6"></i> <span>网址导航</span></a></li><li class="menu-2d-devbox"><a href="https://devtool.tech/"><i class="fas fa-tools" style="margin-top:-20px;zoom:.6"></i> <span>Devtools</span></a></li></ul></li><li class="hide-on-med-and-down nav-item menu-2d-about"><a href="" class="waves-effect waves-light"><i class="fas fa-id-badge" style="zoom:.6"></i> <span>关于</span><i class="fas fa-chevron-down" aria-hidden="true" style="zoom:.6"></i></a><ul class="sub-nav menus_item_child"><li class="site-author menu-2d-aboutme"><a href="/about"><i class="fas fa-user-circle" style="margin-top:-20px;zoom:.6"></i> <span>关于我</span></a></li><li class="menu-2d-abouttech"><a href="/myTeck"><i class="fas fa-address-card" style="margin-top:-20px;zoom:.6"></i> <span>我的技术</span></a></li><li class="menu-2d-aboutporj"><a href="/myProject"><i class="fas fa-laptop-code" style="margin-top:-20px;zoom:.6"></i> <span>我的项目</span></a></li><li class="menu-2d-aboutpost"><a href="/myPost"><i class="fas fa-pen-nib" style="margin-top:-20px;zoom:.6"></i> <span>我的文章</span></a></li><li class="menu-2d-aboutneed"><a href="/needtoread"><i class="fas fa-exclamation-circle" style="margin-top:-20px;zoom:.6"></i> <span>博客须知</span></a></li></ul></li><li class="menu-2d-search"><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fas fa-search" title="搜索" style="zoom:.85"></i></a></li><li class="menu-2d-dark"><a class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色"><i id="sum-moon-icon" class="fas fa-sun" style="zoom:.85"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><div> <img no-lazy src="/medias/logo.png" style="width:45px;height:45px" class="logo-img circle responsive-img" alt="LOGO"><div class="logo-name">夜法之书</div><div class="logo-desc"> ~软件驱动世界~</div></div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa-fw fas fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="https://nav.17lai.site/" class="waves-effect waves-light"><i class="fa-fw fas fa-suitcase"></i> 导航</a></li><li class="m-nav-item"><a href="javascript:;"><i class="fa-fw fas fa-music"></i> 多媒体<span class="m-icon"><i class="fas fa-chevron-right"></i></span></a><ul style=""><li><a href="/musics" style="margin-left:75px"><i class="fa fas fa-music" style="position:absolute;left:50px"></i> <span>音乐</span></a></li><li><a href="/galleries" style="margin-left:75px"><i class="fa fas fa-image" style="position:absolute;left:50px"></i> <span>相册</span></a></li><li><a href="/movies" style="margin-left:75px"><i class="fa fas fa-film" style="position:absolute;left:50px"></i> <span>视频</span></a></li><li><a href="https://musicplayer.17lai.site/" style="margin-left:75px"><i class="fa fas fa-music" style="position:absolute;left:50px"></i> <span>在线云音乐</span></a></li><li><a href="https://music.17lai.site/" style="margin-left:75px"><i class="fa fas fa-music" style="position:absolute;left:50px"></i> <span>音乐播放器</span></a></li></ul></li><li class="m-nav-item"><a href="javascript:;"><i class="fa-fw fas fa-folder-plus"></i> 文章<span class="m-icon"><i class="fas fa-chevron-right"></i></span></a><ul style=""><li><a href="/tags" style="margin-left:75px"><i class="fa fas fa-tags" style="position:absolute;left:50px"></i> <span>标签</span></a></li><li><a href="/categories" style="margin-left:75px"><i class="fa fas fa-bookmark" style="position:absolute;left:50px"></i> <span>分类</span></a></li><li><a href="/archives" style="margin-left:75px"><i class="fa fas fa-archive" style="position:absolute;left:50px"></i> <span>归档</span></a></li></ul></li><li class="m-nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa-fw fas fa-link"></i> 友链</a></li><li class="m-nav-item"><a href="javascript:;"><i class="fa-fw fas fa-comments"></i> 交流<span class="m-icon"><i class="fas fa-chevron-right"></i></span></a><ul style=""><li><a href="/contact" style="margin-left:75px"><i class="fa fas fa-comments" style="position:absolute;left:50px"></i> <span>留言</span></a></li><li><a href="https://t.me/joinchat/Sg3__qc4LBE2VsLO" style="margin-left:75px"><i class="fa fab fa-telegram-plane" style="position:absolute;left:50px"></i> <span>TG群</span></a></li></ul></li><li class="m-nav-item"><a href="javascript:;"><i class="fa-fw fas fa-code"></i> 快查<span class="m-icon"><i class="fas fa-chevron-right"></i></span></a><ul style=""><li><a href="/cheatsheets/Vim_CN.docset/Contents/Resources/Documents/" style="margin-left:75px"><i class="fa fab fa-vimeo-v" style="position:absolute;left:50px"></i> <span>Vim快查表</span></a></li><li><a href="/cheatsheets/Visual_Studio_Code.docset/Contents/Resources/Documents/" style="margin-left:75px"><i class="fa fas fa-code" style="position:absolute;left:50px"></i> <span>VSCode快查表</span></a></li><li><a href="/cheatsheets/Git.docset/Contents/Resources/Documents/" style="margin-left:75px"><i class="fa fab fa-git-square" style="position:absolute;left:50px"></i> <span>Git快查表</span></a></li><li><a href="/cheatsheets/SQLite.docset/Contents/Resources/Documents/" style="margin-left:75px"><i class="fa fas fa-database" style="position:absolute;left:50px"></i> <span>SQLite快查表</span></a></li><li><a href="/cheatsheets/tmux.docset/Contents/Resources/Documents/" style="margin-left:75px"><i class="fa fas fa-terminal" style="position:absolute;left:50px"></i> <span>Tmux快查表</span></a></li><li><a href="/cheatsheets/Bash_Shortcuts.docset/Contents/Resources/Documents/" style="margin-left:75px"><i class="fa fas fa-terminal" style="position:absolute;left:50px"></i> <span>Bash快查表</span></a></li><li><a href="/dash/" style="margin-left:75px"><i class="fa fas fa-laptop-code" style="position:absolute;left:50px"></i> <span>更多快查表</span></a></li></ul></li><li class="m-nav-item"><a href="javascript:;"><i class="fa-fw fas fa-toolbox"></i> 工具<span class="m-icon"><i class="fas fa-chevron-right"></i></span></a><ul style=""><li><a href="https://linux-command.17lai.site/" style="margin-left:75px"><i class="fa fas fa-terminal" style="position:absolute;left:50px"></i> <span>Linux命令</span></a></li><li><a href="http://encode.chahuo.com/" style="margin-left:75px"><i class="fa fas fa-tools" style="position:absolute;left:50px"></i> <span>加密解密</span></a></li><li><a href="https://markmap.js.org/repl" style="margin-left:75px"><i class="fa fas fa-brain" style="position:absolute;left:50px"></i> <span>思维导图</span></a></li><li><a href="https://fontawesome.com/v5.15/icons" style="margin-left:75px"><i class="fa fab fa-font-awesome" style="position:absolute;left:50px"></i> <span>Awesome</span></a></li><li><a href="http://ping.chinaz.com/" style="margin-left:75px"><i class="fa fas fa-tools" style="position:absolute;left:50px"></i> <span>站长工具</span></a></li><li><a href="http://tool.chinaz.com/port/" style="margin-left:75px"><i class="fa fas fa-tools" style="position:absolute;left:50px"></i> <span>端口扫描</span></a></li><li><a href="https://ssh.17lai.site/" style="margin-left:75px"><i class="fa fas fa-tools" style="position:absolute;left:50px"></i> <span>WebSSH</span></a></li><li><a href="https://so.17lai.site/" style="margin-left:75px"><i class="fa fas fa-tools" style="position:absolute;left:50px"></i> <span>安全搜索</span></a></li><li><a href="/nav" style="margin-left:75px"><i class="fa fas fa-tools" style="position:absolute;left:50px"></i> <span>网址导航</span></a></li><li><a href="https://devtool.tech/" style="margin-left:75px"><i class="fa fas fa-tools" style="position:absolute;left:50px"></i> <span>Devtools</span></a></li></ul></li><li class="m-nav-item"><a href="javascript:;"><i class="fa-fw fas fa-id-badge"></i> 关于<span class="m-icon"><i class="fas fa-chevron-right"></i></span></a><ul style=""><li><a href="/about" style="margin-left:75px"><i class="fa fas fa-user-circle" style="position:absolute;left:50px"></i> <span>关于我</span></a></li><li><a href="/myTeck" style="margin-left:75px"><i class="fa fas fa-address-card" style="position:absolute;left:50px"></i> <span>我的技术</span></a></li><li><a href="/myProject" style="margin-left:75px"><i class="fa fas fa-laptop-code" style="position:absolute;left:50px"></i> <span>我的项目</span></a></li><li><a href="/myPost" style="margin-left:75px"><i class="fa fas fa-pen-nib" style="position:absolute;left:50px"></i> <span>我的文章</span></a></li><li><a href="/needtoread" style="margin-left:75px"><i class="fa fas fa-exclamation-circle" style="position:absolute;left:50px"></i> <span>博客须知</span></a></li></ul></li></ul></div></div></nav></header><script src="/libs/cryptojs/crypto-js.min.js"></script><script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script><div class="bg-cover pd-header post-cover" style="background-image:url(/medias_webp/cover/docker.webp)"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">使用 Shell 脚本实现一个简单 Docker</h1></div></div></div></div></div><main class="post-container content"><link rel="stylesheet" href="/libs/tocbot/tocbot.css"><style>#articleContent h1::before,#articleContent h2::before,#articleContent h3::before,#articleContent h4::before,#articleContent h5::before,#articleContent h6::before{display:block;content:" ";height:100px;margin-top:-100px;visibility:hidden}#articleContent :focus{outline:0}.toc-fixed{position:fixed;top:64px}.toc-widget{width:345px;padding-left:20px}.toc-widget .toc-title{padding:35px 0 15px 17px;font-size:1.5rem;font-weight:700;line-height:1.5rem}.toc-widget ol{padding:0;list-style:none}#toc-content{padding-bottom:30px;overflow:auto}#toc-content ol{padding-left:10px}#toc-content ol li{padding-left:10px}#toc-content .toc-link:hover{color:#42b983;font-weight:700;text-decoration:underline}#toc-content .toc-link::before{background-color:transparent;max-height:25px;position:absolute;right:23.5vw;display:block}#toc-content .is-active-link{color:#42b983}#floating-toc-btn{position:fixed;right:15px;bottom:76px;padding-top:15px;margin-bottom:0;z-index:998}#floating-toc-btn .btn-floating{width:48px;height:48px}#floating-toc-btn .btn-floating i{line-height:48px;font-size:1.4rem}</style><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"> <a href="/tags/linux/"><span class="chip bg-color">linux</span></a> <a href="/tags/docker/"><span class="chip bg-color">docker</span></a> <a href="/tags/shell/"><span class="chip bg-color">shell</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/docker/" class="post-category">docker</a><link rel="alternate" type="application/atom+xml" title="分类订阅--docker" href="https://blog.17lai.site/categories/docker/atom.xml"></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="far fa-calendar-minus fa-fw"></i> 发布日期:&nbsp;&nbsp; 2022-03-18</div><div class="post-date info-break-policy"><i class="far fa-calendar-check fa-fw"></i> 更新日期:&nbsp;&nbsp; 2022-03-19</div><div class="info-break-policy"><i class="far fa-file-word fa-fw"></i> 文章字数:&nbsp;&nbsp; 14.4k</div><div class="info-break-policy"><i class="far fa-clock fa-fw"></i> 阅读时长:&nbsp;&nbsp; 60 分</div><div id="busuanzi_container_page_pv" class="info-break-policy"><i class="far fa-eye fa-fw"></i> 阅读次数:&nbsp;&nbsp;<span id="busuanzi_value_page_pv"></span></div></div></div><hr class="clearfix"><link rel="stylesheet" href="/libs/prism/prism.css"><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre-wrap!important}</style><div class="card-content article-card-content"><div id="articleContent"><blockquote><p>《使用 Shell 脚本实现 Docker》旨在通过一系列的实验使用户对docker的底层技术，如Namespace、CGroups、rootfs、联合加载等有一个感性的认识。在此过程中，我们还将通过Shell脚本一步一步地实现一个简易的docker，以期使读者在使用docker的过程中知其然知其所以然。</p></blockquote><p>我们的实验环境为Ubuntu 18.04 64bit，简易docker工程的名字为docker.sh，该工程仓库地址如下：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">https://github.com/pandengyang/docker.sh.git
https://github.com/appotry/docker.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>《使用 Shell 脚本实现 Docker》目录如下：</p><pre class="line-numbers language-none"><code class="language-none">1. Namespace
1.1. Namespace简介
1.2. uts namespace
1.2.1. uts namespace简介
1.2.2. docker.sh
1.3. mount namespace
1.3.1. /etc/mtab、/proc/self/mounts
1.3.2. /proc/self/mountinfo
1.3.3. bind mount
1.3.4. mount namespace简介
1.3.5. docker.sh
1.4. pid namespace
1.4.1. unshare的--fork选项
1.4.2. pid namespace简介
1.4.3. pid嵌套
1.4.4. docker.sh
2. CGroups
2.1. CGroups简介
2.2. 限制内存
2.2.1. 用CGroups限制内存
2.2.2. docker.sh
3. 切换根文件系统
3.1. 根文件系统
3.2. pivot_root
3.3. docker.sh
4. 联合加载
4.1. 联合加载简介
4.2. AUFS
4.3. docker.sh
5. 卷
5.1. 卷简介
5.2. docker.sh
6. 后记<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-Namespace">1.Namespace</h2><h3 id="1-1-Namespace简介">1.1.Namespace简介</h3><p>传统上，在Linux中，许多资源是全局管理的。例如，系统中的所有进程按照惯例是通过PID标识的，这意味着内核必须管理一个全局的PID列表。而且，所有调用者通过uname系统调用返回的系统相关信息都是相同的。用户id的管理方式类似，即各个用户是通过一个全局唯一的UID标识。</p><p>Namespace是Linux用来隔离上述全局资源的一种方式。把一个或多个进程加入到同一个namespace中后，这些进程只会看到该namespace中的资源。namespace是后来加入到Linux中的，为了兼容之前的全局资源管理方式，Linux为每一种资源准备了一个全局的namespace。Linux中的每一个进程都默认加入了这些全局namespace。</p><p>Linux中的每个进程都有一个/proc/[pid]/ns/目录，里面包含了该进程所属的namespace信息。我们查看一下当前Shell的/proc/[pid]/ns目录，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">sudo</span> <span class="token function">ls</span> -l /proc/<span class="token variable">$$</span>/ns
total <span class="token number">0</span>
lrwxrwxrwx <span class="token number">1</span> phl phl <span class="token number">0</span> Jan <span class="token number">22</span> 08:43 cgroup -<span class="token operator">&gt;</span> cgroup:<span class="token punctuation">[</span><span class="token number">4026531835</span><span class="token punctuation">]</span>
lrwxrwxrwx <span class="token number">1</span> phl phl <span class="token number">0</span> Jan <span class="token number">22</span> 08:43 ipc -<span class="token operator">&gt;</span> ipc:<span class="token punctuation">[</span><span class="token number">4026531839</span><span class="token punctuation">]</span>
lrwxrwxrwx <span class="token number">1</span> phl phl <span class="token number">0</span> Jan <span class="token number">22</span> 08:43 mnt -<span class="token operator">&gt;</span> mnt:<span class="token punctuation">[</span><span class="token number">4026531840</span><span class="token punctuation">]</span>
lrwxrwxrwx <span class="token number">1</span> phl phl <span class="token number">0</span> Jan <span class="token number">22</span> 08:43 net -<span class="token operator">&gt;</span> net:<span class="token punctuation">[</span><span class="token number">4026531993</span><span class="token punctuation">]</span>
lrwxrwxrwx <span class="token number">1</span> phl phl <span class="token number">0</span> Jan <span class="token number">22</span> 08:43 pid -<span class="token operator">&gt;</span> pid:<span class="token punctuation">[</span><span class="token number">4026531836</span><span class="token punctuation">]</span>
lrwxrwxrwx <span class="token number">1</span> phl phl <span class="token number">0</span> Jan <span class="token number">22</span> 08:43 pid_for_children -<span class="token operator">&gt;</span> pid:<span class="token punctuation">[</span><span class="token number">4026531836</span><span class="token punctuation">]</span>
lrwxrwxrwx <span class="token number">1</span> phl phl <span class="token number">0</span> Jan <span class="token number">22</span> 08:43 user -<span class="token operator">&gt;</span> user:<span class="token punctuation">[</span><span class="token number">4026531837</span><span class="token punctuation">]</span>
lrwxrwxrwx <span class="token number">1</span> phl phl <span class="token number">0</span> Jan <span class="token number">22</span> 08:43 uts -<span class="token operator">&gt;</span> uts:<span class="token punctuation">[</span><span class="token number">4026531838</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该目录下有很多符号链接，每个符号链接代表一个该进程所属的namespace。用readlink读取这些符号链接可以查看进程所属的namespace id。我们读一下当前Shell所属的uts namespace id，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">sudo</span> readlink /proc/<span class="token variable">$$</span>/ns/uts
uts:<span class="token punctuation">[</span><span class="token number">4026531838</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>后文中我们将介绍uts namespace、mount namespace、pid namespace的用法。</p><h3 id="1-2-uts-namespace">1.2.uts namespace</h3><h4 id="1-2-1-uts-namespace简介">1.2.1.uts namespace简介</h4><p>uts namespace用于隔离系统的主机名等信息，我们将通过实验学习其用法。在实验过程中，我们采用如下的步骤：</p><ol><li>查看全局uts namespace信息</li><li>新建一个uts namespace，查看其信息并作出修改</li><li>查看全局uts namespace，查看其是否被新建的uts namespace影响到</li></ol><p>对于其他namespace，我们也采取类似的步骤进行实验学习。</p><p>首先，我们查看一下全局的hostname及uts namespace id。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">hostname</span>
kernelnewbies

phl@kernelnewbies:~$ <span class="token function">sudo</span> readlink /proc/<span class="token variable">$$</span>/ns/uts
uts:<span class="token punctuation">[</span><span class="token number">4026531838</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，我们创建一个新的uts namespace，并查看其namespce id。</p><p>在继续之前，需要介绍一个namespace工具unshare。利用unshare我们可以新建一个的namespace，并在新namespace中执行一条命令。unshare执行时需要root权限。unshare的使用方法如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">unshare <span class="token punctuation">[</span>options<span class="token punctuation">]</span> <span class="token punctuation">[</span>program <span class="token punctuation">[</span>arguments<span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行unshare时，我们可以指定要新建的namespace的类型以及要执行的命令。unshare提供了一系列选项，当指定某个选项时可新建指定的namespace。namespace类型选项如下：</p><ul><li>--uts创建新的uts namespace</li><li>--mount创建新的mount namespace</li><li>--pid创建新的pid namespace</li><li>--user创建新的user namespace</li></ul><p>介绍完unshare之后，我们继续之前的实验。我们用unshare创建一个新的uts namespace，并在新的uts namespace中执行/bin/bash命令，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">sudo</span> unshare --uts /bin/bash
root@kernelnewbies:~<span class="token comment">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们用unshare创建了一个新的uts namespace。在新的uts namespace中查看其hostname和namespace id，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@kernelnewbies:~$ <span class="token function">hostname</span>
kernelnewbies

root@kernelnewbies:~<span class="token comment"># readlink /proc/$$/ns/uts</span>
uts:<span class="token punctuation">[</span><span class="token number">4026532177</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从结果我们可以看到，新uts namespace的id与全局uts namespace的id不一致。这说明/bin/bash已运行在一个新的uts namespace中了。</p><p>我们将新uts namespace的hostname改为dreamland，并强制更新Shell提示符。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@kernelnewbies:~<span class="token comment"># hostname dreamland</span>
root@kernelnewbies:~<span class="token comment"># hostname</span>
dreamland

root@kernelnewbies:~<span class="token comment"># exec /bin/bash</span>
root@dreamland:~<span class="token comment">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从结果我们可以看到，新uts namespace的hostname的确是被修改了，exec /bin/bash用于强制更新Shell的提示符。</p><p>我们重新打开一个Shell窗口，该Shell位于全局uts namespace中。在新的Shell窗口中查看全局uts namespace id及hostname，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">hostname</span>
kernelnewbies

phl@kernelnewbies:~$ <span class="token function">sudo</span> readlink /proc/<span class="token variable">$$</span>/ns/uts
uts:<span class="token punctuation">[</span><span class="token number">4026531838</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从结果我们可以看到，我们在新uts namespace中所作的修改并未影响到全局的uts namespace。</p><p>父进程创建子进程时只有提供创建新namespace的标志，才可创建新的namespace，并使子进程处于新的namespace中。默认情况下，子进程与父进程处于相同的namespace中。我们在新的uts namespace中创建一个子进程，然后查看该子进程的uts namespace id，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">sudo</span> unshare --uts /bin/bash
root@kernelnewbies:~<span class="token comment"># readlink /proc/$$/ns/uts</span>
uts:<span class="token punctuation">[</span><span class="token number">4026532305</span><span class="token punctuation">]</span>

root@kernelnewbies:~<span class="token comment"># bash</span>
root@kernelnewbies:~<span class="token comment"># readlink /proc/$$/ns/uts</span>
uts:<span class="token punctuation">[</span><span class="token number">4026532305</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从结果我们可以看到，子进程所属uts namespace的id与其父进程相同。其他namespae与uts namespace类似，子进程与父进程同属一个namespace。</p><h4 id="1-2-2-docker-sh">1.2.2.docker.sh</h4><p>有了以上关于uts namespace的介绍，我们就可以将uts namespace加入到docker.sh中了。docker.sh工程分为两个脚本：docker.sh和container.sh。</p><p>docker.sh用于收集用户输入、调用unshare创建namespace并执行container.sh脚本，docker.sh脚本如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token function-name function">usage</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token builtin class-name">echo</span> -e <span class="token string">"<span class="token entity" title="\033">\033</span>[31mIMPORTANT: Run As Root<span class="token entity" title="\033">\033</span>[0m"</span>
        <span class="token builtin class-name">echo</span> <span class="token string">""</span>
        <span class="token builtin class-name">echo</span> <span class="token string">"Usage:    docker.sh [OPTIONS]"</span>
        <span class="token builtin class-name">echo</span> <span class="token string">""</span>
        <span class="token builtin class-name">echo</span> <span class="token string">"A docker written by shell"</span>
        <span class="token builtin class-name">echo</span> <span class="token string">""</span>
        <span class="token builtin class-name">echo</span> <span class="token string">"Options:"</span>
        <span class="token builtin class-name">echo</span> <span class="token string">"          -c string       docker command"</span>
        <span class="token builtin class-name">echo</span> <span class="token string">"                          (<span class="token entity" title="\&quot;">\"</span>run<span class="token entity" title="\&quot;">\"</span>)"</span>
        <span class="token builtin class-name">echo</span> <span class="token string">"          -m              memory"</span>
        <span class="token builtin class-name">echo</span> <span class="token string">"                          (<span class="token entity" title="\&quot;">\"</span>100M, 200M, 300M...<span class="token entity" title="\&quot;">\"</span>)"</span>
        <span class="token builtin class-name">echo</span> <span class="token string">"          -C string       container name"</span>
        <span class="token builtin class-name">echo</span> <span class="token string">"          -I string       image name"</span>
        <span class="token builtin class-name">echo</span> <span class="token string">"          -V string       volume"</span>
        <span class="token builtin class-name">echo</span> <span class="token string">"          -P string       program to run in container"</span>

        <span class="token builtin class-name">return</span> <span class="token number">0</span>
<span class="token punctuation">}</span>

<span class="token keyword">if</span> <span class="token builtin class-name">test</span> <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">whoami</span><span class="token variable">)</span></span>"</span> <span class="token operator">!=</span> root
<span class="token keyword">then</span>
        usage
        <span class="token builtin class-name">exit</span> -1
<span class="token keyword">fi</span>

<span class="token keyword">while</span> <span class="token builtin class-name">getopts</span> c:m:C:I:V:P: option
<span class="token keyword">do</span>
        <span class="token keyword">case</span> <span class="token string">"<span class="token variable">$option</span>"</span>
        <span class="token keyword">in</span>
                c<span class="token punctuation">)</span> <span class="token assign-left variable">cmd</span><span class="token operator">=</span><span class="token variable">$OPTARG</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
                m<span class="token punctuation">)</span> <span class="token assign-left variable">memory</span><span class="token operator">=</span><span class="token variable">$OPTARG</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
                C<span class="token punctuation">)</span> <span class="token assign-left variable">container</span><span class="token operator">=</span><span class="token variable">$OPTARG</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
                I<span class="token punctuation">)</span> <span class="token assign-left variable">image</span><span class="token operator">=</span><span class="token variable">$OPTARG</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
                V<span class="token punctuation">)</span> <span class="token assign-left variable">volume</span><span class="token operator">=</span><span class="token variable">$OPTARG</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
                P<span class="token punctuation">)</span> <span class="token assign-left variable">program</span><span class="token operator">=</span><span class="token variable">$OPTARG</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
                <span class="token punctuation">\</span>?<span class="token punctuation">)</span> usage
                    <span class="token builtin class-name">exit</span> -2<span class="token punctuation">;</span><span class="token punctuation">;</span>
        <span class="token keyword">esac</span>
<span class="token keyword">done</span>

<span class="token builtin class-name">export</span> <span class="token assign-left variable">cmd</span><span class="token operator">=</span><span class="token variable">$cmd</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable">memory</span><span class="token operator">=</span><span class="token variable">$memory</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable">container</span><span class="token operator">=</span><span class="token variable">$container</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable">image</span><span class="token operator">=</span><span class="token variable">$image</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable">volume</span><span class="token operator">=</span><span class="token variable">$volume</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable">program</span><span class="token operator">=</span><span class="token variable">$program</span>

unshare --uts ./container.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>脚本最开始为usage函数，该函数为docker.sh的使用说明。当用户以非预期的方式使用docker.sh时，该函数会被调用。该函数输出如下信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">IMPORTANT: Run As Root

Usage:  docker.sh <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span>

A <span class="token function">docker</span> written by shell

Options:
                -c string       <span class="token function">docker</span> <span class="token builtin class-name">command</span>
                                <span class="token punctuation">(</span><span class="token string">"run"</span><span class="token punctuation">)</span>
                -m              memory
                                <span class="token punctuation">(</span><span class="token string">"100M, 200M, 300M..."</span><span class="token punctuation">)</span>
                -C string       container name
                -I string       image name
                -V string       volume
                -P string       program to run <span class="token keyword">in</span> container<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从usage函数的输出我们可以看到，执行docker.sh时需要root权限且需要正确地传递参数。</p><p>docker.sh首先对当前用户进行检测，如果用户不为root，则打印使用说明并退出脚本；如果用户为root，则继续执行。检测用户的脚本如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token builtin class-name">test</span> <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">whoami</span><span class="token variable">)</span></span>"</span> <span class="token operator">!=</span> root
<span class="token keyword">then</span>
        usage
        <span class="token builtin class-name">exit</span> -1
<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，docker.sh使用getopts从命令行提取参数，然后赋值给合适的变量。从命令行提取参数的脚本如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">while</span> <span class="token builtin class-name">getopts</span> c:m:C:I:V:P: option
<span class="token keyword">do</span>
        <span class="token keyword">case</span> <span class="token string">"<span class="token variable">$option</span>"</span>
        <span class="token keyword">in</span>
                c<span class="token punctuation">)</span> <span class="token assign-left variable">cmd</span><span class="token operator">=</span><span class="token variable">$OPTARG</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
                m<span class="token punctuation">)</span> <span class="token assign-left variable">memory</span><span class="token operator">=</span><span class="token variable">$OPTARG</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
                C<span class="token punctuation">)</span> <span class="token assign-left variable">container</span><span class="token operator">=</span><span class="token variable">$OPTARG</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
                I<span class="token punctuation">)</span> <span class="token assign-left variable">image</span><span class="token operator">=</span><span class="token variable">$OPTARG</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
                V<span class="token punctuation">)</span> <span class="token assign-left variable">volume</span><span class="token operator">=</span><span class="token variable">$OPTARG</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
                P<span class="token punctuation">)</span> <span class="token assign-left variable">program</span><span class="token operator">=</span><span class="token variable">$OPTARG</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
                <span class="token punctuation">\</span>?<span class="token punctuation">)</span> usage
                    <span class="token builtin class-name">exit</span> -2<span class="token punctuation">;</span><span class="token punctuation">;</span>
        <span class="token keyword">esac</span>
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果用户的输入不正确，则打印使用说明并退出脚本；如果用户输入正确，则解析命令行参数并赋值给合适的变量。</p><p>为了简化，用户在运行docker.sh时需提供完整的参数列表，示例如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> ./docker.sh -c run -m 100M -C dreamland -I ubuntu1604 -V data1 -P /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当然，如果当前用户就是root，就不需要sudo了。下表列出了各个参数的含义及示例：</p><p><img src="https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2022/03/1820220318143125.png" alt="使用 Shell 脚本实现 Docker"></p><p>docker.sh将命令行参数赋值给变量后，需要将这些变量导出，以传递给container.sh。导出变量的脚本如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">cmd</span><span class="token operator">=</span><span class="token variable">$cmd</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable">memory</span><span class="token operator">=</span><span class="token variable">$memory</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable">container</span><span class="token operator">=</span><span class="token variable">$container</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable">image</span><span class="token operator">=</span><span class="token variable">$image</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable">volume</span><span class="token operator">=</span><span class="token variable">$volume</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable">program</span><span class="token operator">=</span><span class="token variable">$program</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里说明一下为什么要将docker.sh工程拆分为docker.sh和container.sh两个脚本。因为调用unshare创建新的namespace时，会执行一个命令，该命令在新的namespace中运行。该命令一旦结束，unshare也就结束了，unshare创建的新namespace也就不存在了。</p><p>docker.sh不会并发地执行unshare命令与unshare之后的脚本，因此，只有unshare结束了，后续脚本才可继续运行。但是当unshare结束了，准备执行后续脚本时，新的namespae已经不存在了。因此一些加入cgroups、切换根文件系统等工作必须在unshare执行的命令中进行，所以我们采用在unshare中执行container.sh脚本的方式完成后续的工作。</p><p>最后，docker.sh调用unshare创建新的uts namespace，并执行container.sh脚本。调用unshare的脚本如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">unshare --uts ./container.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>container.sh将容器的hostname修改为通过-C传递的容器的名字，然后执行通过-P传递的程序。container.sh脚本如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token function">hostname</span> <span class="token variable">$container</span>
<span class="token builtin class-name">exec</span> <span class="token variable">$program</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>现在，我们运行docker.sh，并查看其hostname。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/docker.sh$ <span class="token function">sudo</span> ./docker.sh -c run -m 100M -C dreamland -I ubuntu1604 -V data1 -P /bin/bash
root@dreamland:~/docker.sh<span class="token comment"># hostname</span>
dreamland<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>从结果我们可以看到，容器的hostname已经改变为我们传递的容器名字dreamland了。</p><h3 id="1-3-mount-namespace">1.3.mount namespace</h3><h4 id="1-3-1-etc-mtab、-proc-self-mounts">1.3.1./etc/mtab、/proc/self/mounts</h4><p>早期的Linux使用/etc/mtab文件来记录当前的挂载点信息。每次mount/umount文件系统时会更新/etc/mtab文件中的信息。</p><p>后来，linux引入了mount namespace，每个进程都有一份自己的挂载点信息。当然，处于同一个mount namespace里面的进程，其挂载点信息是相同的。进程的挂载点信息通过/proc/[pid]/mounts文件导出给用户。</p><p>为了兼容以前的/etc/mtab，/etc/mtab变成了指向/proc/self/mounts的符号链接。通过readlink查看/etc/mtab指向的文件，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ readlink /etc/mtab
<span class="token punctuation">..</span>/proc/self/mounts<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过读取/proc/self/mounts文件，可以查看当前的挂载点信息，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">cat</span> /proc/self/mounts
sysfs /sys sysfs rw,nosuid,nodev,noexec,relatime <span class="token number">0</span> <span class="token number">0</span>
proc /proc proc rw,nosuid,nodev,noexec,relatime <span class="token number">0</span> <span class="token number">0</span>
/dev/sda1 / ext4 rw,relatime,errors<span class="token operator">=</span>remount-ro <span class="token number">0</span> <span class="token number">0</span>
securityfs /sys/kernel/security securityfs rw,nosuid,nodev,noexec,relatime <span class="token number">0</span> <span class="token number">0</span>
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于该文件中内容太多，我们省略了一部分，只保留了一些比较重要的挂载点信息。每行的信息分为六个字段，各字段的含义及示例如下：</p><p><img src="https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2022/03/1820220318143143.png" alt="使用 Shell 脚本实现 Docker"></p><p>由于该文件有点过时，被后文介绍的/proc/self/mountinfo替换掉，所以不做过多介绍。</p><h4 id="1-3-2-proc-self-mountinfo">1.3.2./proc/self/mountinfo</h4><p>/proc/self/mountinfo包含了进程mount namespace中的挂载点信息。 它提供了旧的/proc/[pid]/mounts文件中缺少的各种信息（传播状态，挂载点id，父挂载点id等），并解决了/proc/[pid]/mounts文件的一些其他缺陷。我们查看进程挂载点信息时应优先使用该文件。</p><p>该文件中每一行代表一个挂载点信息，每个挂载点信息分为11个字段。挂载点信息的示例如下：</p><p><img src="https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2022/03/1820220318143124.png" alt="使用 Shell 脚本实现 Docker"></p><p>各字段的含义及示例如下：</p><p><img src="https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2022/03/1820220318143118.png" alt="使用 Shell 脚本实现 Docker"></p><p>我们主要关注可选字段中的传播状态选项。首先，我们看一下关于mount namespace的问题。问题如下：</p><p>当创建mount namespace时，新mount namespace会拷贝一份老mount namespace里面的挂载点信息。例如，全局mount namespace中有一个/a挂载点，新建的mount namespace中也会有一个/a挂载点。那么我们在新mount namespace中的/a下创建或删除一个挂载点，全局mount namespace中的/a会同步创建或删除该挂载点吗？或者在全局mount namespace中的/a下创建或删除一个挂载点，新mount namespace中的/a会同步创建或删除该挂载点吗？</p><p>mountinfo文件中可选字段的传播状态就是控制在一个挂载点下进行创建/删除挂载点操作时是否会传播到其他挂载点的选项。传播状态有四种可取值，常见的有如下两种：</p><ul><li>shared 表示创建/删除挂载点的操作会传播到其他挂载点</li><li>private 表示创建/删除挂载点的操作不会传播到其他挂载点</li></ul><p>由于在容器技术中要保证主机与容器的挂载点信息互不影响，因此要求容器中的挂载点的传播状态为private。</p><h4 id="1-3-3-bind-mount">1.3.3.bind mount</h4><p>bind mount可以将一个目录（源目录）挂载到另一个目录（目的目录），在目的目录里面的读写操作将直接作用于源目录。</p><p>下面我们通过实验了解一下bind mount的功能，首先，我们准备一下实验所需要的的目录及文件。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">mkdir</span> <span class="token builtin class-name">bind</span>
phl@kernelnewbies:~$ <span class="token builtin class-name">cd</span> bind/
phl@kernelnewbies:~/bind$ <span class="token function">mkdir</span> a
phl@kernelnewbies:~/bind$ <span class="token function">mkdir</span> b
phl@kernelnewbies:~/bind$ <span class="token builtin class-name">echo</span> hello, a <span class="token operator">&gt;</span> a/a.txt
phl@kernelnewbies:~/bind$ <span class="token builtin class-name">echo</span> hello, b <span class="token operator">&gt;</span> b/b.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，我们将a目录bind mount到b目录并查看b目录下的内容。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/bind$ <span class="token function">sudo</span> <span class="token function">mount</span> --bind a b
phl@kernelnewbies:~/bind$ tree b
b
└── a.txt
<span class="token number">0</span> directories, <span class="token number">1</span> <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从结果我们可以看到，b目录下原先的内容被隐藏，取而代之的是a目录下的内容。</p><p>然后，我们修改b目录下的内容，修改完毕后，从b目录上卸载掉a目录。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/bind$ <span class="token builtin class-name">echo</span> hello, a from b <span class="token operator">&gt;</span> b/a.txt
phl@kernelnewbies:~/bind$ <span class="token function">sudo</span> <span class="token function">umount</span> b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们读取一下a目录中a.txt，看看其内容是否被改变。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/bind$ <span class="token function">cat</span> a/a.txt
hello, a from b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>从结果我们可以看到，a目录中的内容确实被当a被bind mount到b时对b目录的操作所修改了。</p><p>bind mount在容器技术中有很重要的用途，后文会有涉及。</p><h4 id="1-3-4-mount-namespace简介">1.3.4.mount namespace简介</h4><p>mount namespace用来隔离文件系统的挂载点信息, 使得不同的mount namespace拥有自己独立的挂载点信息。不同的namespace之间不会相互影响，其在unshare中的选项为--mount。</p><p>当用unshare创建新的mount namespace时，新创建的namespace将拷贝一份老namespace里的挂载点信息，但从这之后，他们就没有关系了。这是unshare将新 namespace 里面的所有挂载点的传播状态设置为private实现的。通过mount和umount增加和删除各自mount namespace里面的挂载点都不会相互影响。</p><p>下面我们将演示mount namespace的用法。首先，我们准备需要的目录和文件，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">mkdir</span> -p hds/hd1 hds/hd2 <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">cd</span> hds

phl@kernelnewbies:~/hds$ <span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>/dev/zero <span class="token assign-left variable">bs</span><span class="token operator">=</span>1M <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">of</span><span class="token operator">=</span>hd1.img <span class="token operator">&amp;&amp;</span> mkfs.ext2 hd1.img
phl@kernelnewbies:~/hds$ <span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>/dev/zero <span class="token assign-left variable">bs</span><span class="token operator">=</span>1M <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">of</span><span class="token operator">=</span>hd2.img <span class="token operator">&amp;&amp;</span> mkfs.ext2 hd2.img

phl@kernelnewbies:~$ tree <span class="token builtin class-name">.</span>
<span class="token builtin class-name">.</span>
├── hd1
├── hd1.img
├── hd2
└── hd2.img
<span class="token number">2</span> directories, <span class="token number">2</span> files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，我们在全局的mount namespace中挂载hd1.img到hd1目录，然后查看该mount namespace中的挂载点信息与mount namespace id。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/hds$ <span class="token function">sudo</span> <span class="token function">mount</span> hd1.img hd1
phl@kernelnewbies:~/hds$ <span class="token function">cat</span> /proc/self/mountinfo <span class="token operator">|</span> <span class="token function">grep</span> hd
<span class="token number">556</span> <span class="token number">27</span> <span class="token number">7</span>:18 / /home/phl/hds/hd1 rw,relatime shared:372 - ext2 /dev/loop18 rw

phl@kernelnewbies:~/hds$ <span class="token function">sudo</span> readlink /proc/<span class="token variable">$$</span>/ns/mnt
mnt:<span class="token punctuation">[</span><span class="token number">4026531840</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，执行unshare命令创建一个新的mount namespace并查看该mount namespace id和挂载点信息。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/hds$ <span class="token function">sudo</span> unshare --uts --mount /bin/bash
root@kernelnewbies:~/hds<span class="token comment"># cat /proc/self/mountinfo | grep hd</span>
<span class="token number">739</span> <span class="token number">570</span> <span class="token number">7</span>:18 / /home/phl/hds/hd1 rw,relatime - ext2 /dev/loop18 rw

root@kernelnewbies:~/hds<span class="token comment"># readlink /proc/$$/ns/mnt</span>
mnt:<span class="token punctuation">[</span><span class="token number">4026532180</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从结果我们可以看到，新mount namespace中的挂载点信息与全局mountnamespace中的挂载点信息基本一致，一些挂载选项（如传播状态）变化了。新的mount namespace id与全局mount namespace id是不一样的。</p><p>然后，我们在新的mount namespace中挂载hd2.img到hd2目录，并查看挂载点信息。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@kernelnewbies:~/hds<span class="token comment"># mount hd2.img hd2</span>
root@kernelnewbies:~/hds<span class="token comment"># cat /proc/self/mountinfo | grep hd</span>
<span class="token number">739</span> <span class="token number">570</span> <span class="token number">7</span>:18 / /home/phl/hds/hd1 rw,relatime - ext2 /dev/loop18 rw
<span class="token number">740</span> <span class="token number">570</span> <span class="token number">7</span>:19 / /home/phl/hds/hd2 rw,relatime - ext2 /dev/loop19 rw<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>从结果我们可以看到，新mount namespace中有hd1和hd2这两个挂载点。现在启动一个新的Shell窗口，查看全局mount namespace中的挂载点信息。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/hds$ <span class="token function">cat</span> /proc/self/mountinfo <span class="token operator">|</span> <span class="token function">grep</span> hd
<span class="token number">556</span> <span class="token number">27</span> <span class="token number">7</span>:18 / /home/phl/hds/hd1 rw,relatime shared:372 - ext2 /dev/loop18 rw<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>从结果我们可以看到，全局mount namespace中的挂载点信息只有hd1，而没有hd2。这说明在新mount namespace中进行挂载/卸载操作不会影响其他mount namespace中的挂载点信息。</p><p>mount namespace只隔离挂载点信息，并不隔离挂载点下面的文件信息。对于多个mount namespace都能看到的挂载点，如果在一个namespace中修改了挂载点下面的文件，其他namespace也能感知到。下面，我们在新建的mount namespace中创建一个文件，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@kernelnewbies:~/hds<span class="token comment"># echo hello from new mount namespace &gt; hd1/hello.txt</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在新启动的Shell中，查看hd1目录并读取hd1/hello.txt文件。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/hds$ tree hd1
hd1
├── hello.txt
└── lost+found <span class="token punctuation">[</span>error opening dir<span class="token punctuation">]</span>
<span class="token number">1</span> directory, <span class="token number">1</span> <span class="token function">file</span>

phl@kernelnewbies:~/hds$ <span class="token function">cat</span> hd1/hello.txt
hello from new <span class="token function">mount</span> namespace<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从结果我们可以看到，在全局mount namespace中，我们可以读取到在新建的mount namespace中创建的文件。</p><h4 id="1-3-5-docker-sh">1.3.5.docker.sh</h4><p>有了以上关于mount namespace的知识，我们就可以将mount namespace加入到docker.sh中了。mount namespace将放在docker.sh中，带下划线的行是我们为实现mount namespace而修改的代码。修改后的docker.sh脚本如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">..</span>.
unshare --uts --mount ./container.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>从上述代码我们可以看到，我们仅仅是在调用unshare时加入--mount选项，就可为docker.sh引入了mount namespace功能。</p><h3 id="1-4-pid-namespace">1.4.pid namespace</h3><h4 id="1-4-1-unshare的-fork选项">1.4.1.unshare的--fork选项</h4><p>unshare有一个选项--fork，当执行unshare时，如果没有这个选项，unshare会直接exec新命令，也就是说unshare变成了新命令。如果带有--fork选项，unshare会fork一个子进程，该子进程exec新命令，unshare是该子进程的父进程。我们分别不带--fork和带--fork来执行unshare，然后查看进程之间的关系。</p><p>首先，我们不带--fork选项执行unshare，并查看当前Shell的进程id。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">sudo</span> unshare --uts /bin/bash
root@kernelnewbies:~/hds<span class="token comment"># echo $$</span>
<span class="token number">11699</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此时unshare会创建一个新的uts namespace，然后exec /bin/bash。我们启动一个新Shell，然后使用pstree查看进程间关系，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/hds$ pstree -p <span class="token operator">|</span> <span class="token function">grep</span> <span class="token number">11699</span>
sudo<span class="token punctuation">(</span><span class="token number">11698</span><span class="token punctuation">)</span>---bash<span class="token punctuation">(</span><span class="token number">11699</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>从结果我们可以看到，sudo fork出一个子进程，该子进程执行unshare。unshare创建了新uts namespace后，exec了/bin/bash，也就是说unshare变成了/bin/bash。</p><p>然后，我们带--fork选项执行unshare，并查看当前Shell的进程id。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/hds$ <span class="token function">sudo</span> unshare --uts --fork /bin/bash
root@kernelnewbies:~/hds<span class="token comment"># echo $$</span>
<span class="token number">11866</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此时unshare会创建一个新的uts namespace，然后fork出一个子进程，该子进程exec /bin/bash。我们启动一个新Shell，然后使用pstree查看进程间关系，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/hds$ pstree -p <span class="token operator">|</span> <span class="token function">grep</span> <span class="token number">11866</span>
sudo<span class="token punctuation">(</span><span class="token number">11864</span><span class="token punctuation">)</span>---unshare<span class="token punctuation">(</span><span class="token number">11865</span><span class="token punctuation">)</span>---bash<span class="token punctuation">(</span><span class="token number">11866</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>从结果我们可以看到，sudo fork出一个子进程，该子进程执行命令unshare。unshare创建了新uts namespace后，fork出一个子进程，该子进程exec /bin/bash，也就是说unshare变成了新的/bin/bash进程的父进程。</p><h4 id="1-4-2-pid-namespace简介">1.4.2.pid namespace简介</h4><p>pid namespace用来隔离进程pid空间，使得不同pid namespace里的进程 pid可以重复且相互之间不影响。进程所属的pid namespace在创建的时候就确定了，无法更改，因此需要--fork选项来创建一个新进程，然后将该新进程加入新建的pid namespace中。pid namespace在unshare中的选项为--pid。</p><p>unshare在创建pid namespace时需同时提供--pid与--fork选项。unshare本身会加入全局的pid namespace，其fork出的子进程会加入新建的pid namespace。</p><p>首先，我们查看全局pid namespace id，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">sudo</span> readlink /proc/<span class="token variable">$$</span>/ns/pid
pid:<span class="token punctuation">[</span><span class="token number">4026531836</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后，执行unshare命令创建一个新的pid namespace并查看该pid namespace id。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">sudo</span> unshare --mount --pid --fork /bin/bash
root@kernelnewbies:~<span class="token comment"># readlink /proc/$$/ns/pid</span>
pid:<span class="token punctuation">[</span><span class="token number">4026531836</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>从结果我们可以看到，新创建的进程也处于全局pid namespace中，而不是新的pid namespace。</p><p>出现这种情形是因为当前的/proc文件系统是老的。我们查看一下$$的值，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@kernelnewbies:~<span class="token comment"># echo $$</span>
<span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>从结果我们可以看到，$$的值为1，但是/proc文件系统却是老的，因此我们查看的实际是init进程所属的pid namespace，当然是全局pid namespace了。</p><p>重新挂载/proc文件系统，这也是unshare执行时带--mount选项的原因，只有这样，重新挂载/proc文件系统时，不会搞乱整个系统。再次查看新进程所属的pid namespace，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@kernelnewbies:~<span class="token comment"># mount -t proc proc /proc</span>
root@kernelnewbies:~<span class="token comment"># readlink /proc/$$/ns/pid</span>
pid:<span class="token punctuation">[</span><span class="token number">4026532182</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>从结果我们可以看到，新进程的pid namespace与全局pid namespace的id不同。</p><p>接下来，我们再来查看一下新pid namespace中的进程信息。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@kernelnewbies:~<span class="token comment"># ps -ef</span>
<span class="token environment constant">UID</span>        PID  <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMD
root         <span class="token number">1</span>     <span class="token number">0</span>  <span class="token number">0</span> <span class="token number">19</span>:03 pts/1    00:00:00 /bin/bash
root        <span class="token number">10</span>     <span class="token number">1</span>  <span class="token number">0</span> <span class="token number">19</span>:03 pts/1    00:00:00 <span class="token function">ps</span> -e<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>从结果我们可以看到，当前pid namespace中只有2个进程，看不到全局pid namespace里面的其他进程。我们通过unshare执行的进程pid为1，也就是说该进程成了新pid namespace中的init进程。</p><h4 id="1-4-3-pid嵌套">1.4.3.pid嵌套</h4><p>pid namespace可以嵌套，也就是说有父子关系，在当前pid namespace里面创建的所有新的pid namespace都是当前pid namespace的子pid namespace。</p><p>首先，我们创建3个嵌套的pid namespace，并查看每个pid namespace id。--mount-proc选项用于自动挂载/proc文件系统，省去了手动挂载/proc文件系统的操作。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">sudo</span> readlink /proc/<span class="token variable">$$</span>/ns/pid
pid:<span class="token punctuation">[</span><span class="token number">4026531836</span><span class="token punctuation">]</span>

phl@kernelnewbies:~$ <span class="token function">sudo</span> unshare --uts --mount --pid --mount-proc --fork /bin/bash
root@kernelnewbies:~<span class="token comment"># readlink /proc/$$/ns/pid</span>
pid:<span class="token punctuation">[</span><span class="token number">4026532182</span><span class="token punctuation">]</span>

root@kernelnewbies:~<span class="token comment"># unshare --uts --mount --pid --mount-proc --fork /bin/bash</span>
root@kernelnewbies:~<span class="token comment"># readlink /proc/$$/ns/pid</span>
pid:<span class="token punctuation">[</span><span class="token number">4026532185</span><span class="token punctuation">]</span>

root@kernelnewbies:~<span class="token comment"># unshare --uts --mount --pid --mount-proc --fork /bin/bash</span>
root@kernelnewbies:~<span class="token comment"># readlink /proc/$$/ns/pid</span>
pid:<span class="token punctuation">[</span><span class="token number">4026532188</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，我们启动一个新Shell，然后使用pstree查看进程间关系。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ pstree -lp <span class="token operator">|</span> <span class="token function">grep</span> unshare
sudo<span class="token punctuation">(</span><span class="token number">12547</span><span class="token punctuation">)</span>---unshare<span class="token punctuation">(</span><span class="token number">12548</span><span class="token punctuation">)</span>---bash<span class="token punctuation">(</span><span class="token number">12549</span><span class="token punctuation">)</span>---unshare<span class="token punctuation">(</span><span class="token number">12579</span><span class="token punctuation">)</span>---bash<span class="token punctuation">(</span><span class="token number">12580</span><span class="token punctuation">)</span>---unshare<span class="token punctuation">(</span><span class="token number">12593</span><span class="token punctuation">)</span>---bash<span class="token punctuation">(</span><span class="token number">12594</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用cat /proc/[pid]/status | grep NSpid可查看某进程在当前pid namespace及子孙pid namespace中的pid。我们在全局pid namespace中查看上述各进程在各pid namespace中的pid，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">cat</span> /proc/12594/status <span class="token operator">|</span> <span class="token function">grep</span> NSpid
NSpid: <span class="token number">12594</span> <span class="token number">21</span> <span class="token number">11</span> <span class="token number">1</span>

phl@kernelnewbies:~$ <span class="token function">cat</span> /proc/12593/status <span class="token operator">|</span> <span class="token function">grep</span> NSpid
NSpid: <span class="token number">12593</span> <span class="token number">20</span> <span class="token number">10</span>

phl@kernelnewbies:~$ <span class="token function">cat</span> /proc/12580/status <span class="token operator">|</span> <span class="token function">grep</span> NSpid
NSpid: <span class="token number">12580</span> <span class="token number">11</span> <span class="token number">1</span>

phl@kernelnewbies:~$ <span class="token function">cat</span> /proc/12579/status <span class="token operator">|</span> <span class="token function">grep</span> NSpid
NSpid: <span class="token number">12579</span> <span class="token number">10</span>

phl@kernelnewbies:~$ <span class="token function">cat</span> /proc/12549/status <span class="token operator">|</span> <span class="token function">grep</span> NSpid
NSpid: <span class="token number">12549</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面我们将以上进程在各pid namespace中的pid，整理成表格。表格信息如下：</p><p><img src="https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2022/03/1820220318143156.png" alt="使用 Shell 脚本实现 Docker"></p><p>我们以最后一行为例进行介绍，最后一行有4个pid，这4个pid其实是同一个进程。这个进程在4个pid namespace中都可以被看到，且其在4个pid namespace中的pid各不相同。</p><h4 id="1-4-4-docker-sh">1.4.4.docker.sh</h4><p>有了以上关于pid namespace的知识，我们就可以将pid namespae加入到docker.sh中了。pid namespace将放在docker.sh中，带下划线的行是我们为实现pid namespace而修改的代码。修改后的docker.sh脚本如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">..</span>.
unshare --uts --mount --pid --fork ./container.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>从上述代码我们可以看到，我们仅仅是在调用unshare时加入--pid和--fork选项，就可为docker.sh引入了pid namespace功能。</p><p>然后，我们需要重新挂载/proc文件系统。重新挂载/proc文件系统的功能将放在container.sh中，带下划线的行是我们为重新挂载/proc文件系统而新添的代码。修改后的container.sh脚本如下如下所示：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">hostname</span> <span class="token variable">$container</span>
<span class="token function">mount</span> -t proc proc /proc
<span class="token builtin class-name">exec</span> <span class="token variable">$program</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>现在，我们运行docker.sh，并查看当前的进程信息。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/docker.sh$ <span class="token function">sudo</span> ./docker.sh -c run -m 100M -C dreamland -I ubuntu1604 -V data1 -P /bin/bash
root@dreamland:~/docker.sh<span class="token comment"># ps -ef</span>
<span class="token environment constant">UID</span>        PID  <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMD
root         <span class="token number">1</span>     <span class="token number">0</span>  <span class="token number">0</span> <span class="token number">17</span>:31 pts/1    00:00:00 /bin/bash
root        <span class="token number">16</span>     <span class="token number">1</span>  <span class="token number">0</span> <span class="token number">17</span>:31 pts/1    00:00:00 <span class="token function">ps</span> -ef<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从结果我们可看出，当前进程只有两个，不再有主机上的其他进程。</p><h2 id="2-CGroups">2.CGroups</h2><h3 id="2-1-CGroups简介">2.1.CGroups简介</h3><p>CGroups是一种将进程分组，并以组为单位对进程实施资源限制的技术。每个组都包含以下几类信息：</p><ul><li>进程列表</li><li>资源A限制</li><li>资源B限制</li><li>资源C限制</li><li>...</li></ul><p>我们将以常见的CPU资源及内存资源为例进行介绍。以下的信息将使进程号为1001、1002、2008、3306的四个进程总共只能使用一个CPU核心；总共最多使用25%的CPU资源；总共最多使用100M内存，这样的一个分组被称为cgroup。</p><p><img src="https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2022/03/1820220318143103.png" alt="使用 Shell 脚本实现 Docker"></p><p>上面的介绍只是说明了要将何种资源限制施加于哪些进程，并未说明资源限制是如何施加到进程上。具体施加资源限制的过程需要subsystem来帮忙。subsystem读取cgroup中的资源限制和进程列表，然后将这些资源限制施加到这些进程上。常见的subsystem包括如下几种：</p><ul><li>cpu</li><li>memory</li><li>pids</li><li>devices</li><li>blkio</li><li>net_cls</li></ul><p>每个subsystem只读取与其相关的资源限制，然后施加到进程上。例如：memory子系统只读取内存限制，而cpu子系统只读取cpu限制。</p><p>cgroup被组织成树，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2022/03/1820220318143057.png" alt="使用 Shell 脚本实现 Docker"></p><p>采用树状结构可以方便地实现资源限制继承，一个cgroup中的资源限制将作用于该cgroup及其子孙cgroup中的进程。例如：图中13001、10339、2999受到A、B、C、D四个cgroup中的资源限制。这样的一个树状结构被称为hierarchy。</p><p>hierarchy中包含了系统中所有的进程，它们分布于各个cgroup中。在hierarchy中，一个进程必须属于且只属于一个cgroup，这样才能保证对进程施加的资源限制不会遗漏也不会冲突。</p><p>要想让一个subsystem读取hierarchy中各cgroup的资源限制，并施加于其中的进程需要将subsystem和hierarchy关联起来。subsystem与hierarchy的关系如下：</p><ul><li>系统中可以有多个hierarchy</li><li>一个hierarchy可以关联0个或多个subsystem，当关联0个subsystem时，该hierarchy只是对进程进行分类</li><li>一个subsystem最多关联到一个hierarchy，因为每个hierarchy都包含系统中所有的进程，若一个subsystem关联到了多个hierarchy，对同一进程将有多种资源限制，这是不对的</li></ul><p>系统使用CGroups通常有两种形式：一种是创建一个hierarchy，将所有的subsystem关联到其上，在这个hierarchy上配置各种资源限制；另一种是为每一个subsystem创建一个hierarchy，并将该subsystem关联到其上，每个hierarchy只对一种资源进行限制。后一种比较清晰，得到了更普遍的采用。</p><p>CGroups不像大多数的技术那样提供API或命令之类的用户接口，而是提供给用户一个虚拟文件系统，该虚拟文件系统类型为cgroup。一个挂载后的cgroup文件系统就是一个hierarchy，文件系统中的一个目录就是一个cgroup，目录中的文件代表了进程列表或者资源限制信息。文件系统是树状结构，其各个目录之间的父子关系就代表了cgroup之间的继承关系。挂载cgroup虚拟文件系统后，通过在该文件系统上创建目录、写进程列表文件、写资源限制文件就可以操作CGroups。</p><p>下面，我们通过实验学习一下CGroups的用法。首先，我们挂载一个cgroup虚拟文件系统，该文件系统不与任何subsystem关联，仅仅是将进程进行分类。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">mkdir</span> -p cg/test
<span class="token comment"># -o none,name=test 表示该cgroup文件系统不与任何子系统关联</span>
<span class="token comment"># 该文件系统用name=test来标识</span>
phl@kernelnewbies:~$ <span class="token function">sudo</span> <span class="token function">mount</span> -t cgroup -o none,name<span class="token operator">=</span>test <span class="token builtin class-name">test</span> cg/test
phl@kernelnewbies:~$ tree cg/test
cg/test
├── cgroup.clone_children
├── cgroup.procs
├── cgroup.sane_behavior
├── notify_on_release
├── release_agent
└── tasks
<span class="token number">0</span> directories, <span class="token number">6</span> files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>挂载cgroup文件系统后，该cgroup文件系统的根目录下会生成许多文件，该根目录被称为root cgroup。cgroup.procs里面存放的是当前cgroup中的所有进程id，由于该hierarchy中只有一个cgroup，所以这个文件包含了系统中所有的进程id。其他的文件与cgroups基本功能关系不大，暂时可以忽略。</p><p>在cgroup文件系统中，创建一个目录就会创建一个cgroup。下面我们将会演示如何创建下面这样的hierarchy：</p><p><img src="https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2022/03/1820220318143054.png" alt="使用 Shell 脚本实现 Docker"></p><p>命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">sudo</span> <span class="token function">mkdir</span> -p cg/test/test1/test11
phl@kernelnewbies:~$ <span class="token function">sudo</span> <span class="token function">mkdir</span> -p cg/test/test2/test22
phl@kernelnewbies:~$ tree cg/test
cg/test
├── cgroup.clone_children
├── cgroup.procs
├── cgroup.sane_behavior
├── notify_on_release
├── release_agent
├── tasks
├── test1
│   ├── cgroup.clone_children
│   ├── cgroup.procs
│   ├── notify_on_release
│   ├── tasks
│   └── test11
│       ├── cgroup.clone_children
│       ├── cgroup.procs
│       ├── notify_on_release
│       └── tasks
└── test2
    ├── cgroup.clone_children
    ├── cgroup.procs
    ├── notify_on_release
    ├── tasks
    └── test22
        ├── cgroup.clone_children
        ├── cgroup.procs
        ├── notify_on_release
        └── tasks

<span class="token number">4</span> directories, <span class="token number">22</span> files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从结果我们可以看到，我们创建了相应的目录后，这些目录下自动出现了包含cgroup信息的目录及文件。</p><p>删除cgroup时只需删除该cgroup所在的目录即可。下面我们将删除test11 cgroup，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">sudo</span> <span class="token function">rmdir</span> cg/test/test1/test11
phl@kernelnewbies:~$ tree cg/test
cg/test
├── cgroup.clone_children
├── cgroup.procs
├── cgroup.sane_behavior
├── notify_on_release
├── release_agent
├── tasks
├── test1
│   ├── cgroup.clone_children
│   ├── cgroup.procs
│   ├── notify_on_release
│   └── tasks
└── test2
    ├── cgroup.clone_children
    ├── cgroup.procs
    ├── notify_on_release
    ├── tasks
    └── test22
        ├── cgroup.clone_children
        ├── cgroup.procs
        ├── notify_on_release
        └── tasks

<span class="token number">3</span> directories, <span class="token number">18</span> files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每个cgroup下面都有一个cgroup.procs文件，该文件里面包含当前cgroup里面的所有进程id。只要将某个进程的id写入该文件，即可将该进程加入到该cgroup中。下面，我们将当前的bash加入到test22 cgroup中，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token builtin class-name">echo</span> <span class="token variable">$$</span>
<span class="token number">3894</span>
phl@kernelnewbies:~$ <span class="token function">sudo</span> <span class="token function">sh</span> -c <span class="token string">"echo 3894 &gt; cg/test/test2/test22/cgroup.procs"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>/proc/[pid]/cgroup包含了某个进程所在的cgroup信息。下面，我们查看一下当前bash进程所在的cgroup信息，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">cat</span> /proc/3894/cgroup
<span class="token number">13</span>:name<span class="token operator">=</span>test:/test2/test22
<span class="token number">12</span>:freezer:/
<span class="token number">11</span>:perf_event:/
<span class="token number">10</span>:blkio:/user.slice
<span class="token number">9</span>:devices:/user.slice
<span class="token number">8</span>:hugetlb:/
<span class="token number">7</span>:cpu,cpuacct:/user.slice
<span class="token number">6</span>:net_cls,net_prio:/
<span class="token number">5</span>:memory:/user.slice
<span class="token number">4</span>:rdma:/
<span class="token number">3</span>:pids:/user.slice/user-1001.slice/session-4.scope
<span class="token number">2</span>:cpuset:/
<span class="token number">1</span>:name<span class="token operator">=</span>systemd:/user.slice/user-1001.slice/session-4.scope
<span class="token number">0</span>::/user.slice/user-1001.slice/session-4.scope<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从结果我们可以看到，当前bash进程加入了多个cgroup，其中带下划线的行为我们刚刚加入的cgroup。</p><p>要想将hierarchy与子系统关联起来，需要在-o选项中指定子系统名称。下面演示了如何将memory子系统与新挂载的cgroup文件系统关联起来。代码如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">sudo</span> <span class="token function">mkdir</span> cg/memory
phl@kernelnewbies:~$ <span class="token function">sudo</span> <span class="token function">mount</span> -t cgroup -o memory memcg cg/memory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>由于很多发行版的操作系统已经为我们配置好了这些cgroup文件系统，我们应当直接使用这些已经挂在好的文件系统，不需要自己去挂载。</p><p>另外，当创建子进程时，子进程会自动加入父进程所在的cgroup。</p><h3 id="2-2-限制内存">2.2.限制内存</h3><h4 id="2-2-1-用CGroups限制内存">2.2.1.用CGroups限制内存</h4><p>下面我们将介绍演示CGroups如何限制进程使用的内存资源，我们以内存为例进行讲解。</p><p>Ubuntu18.04已经为我们挂载了一个关联memory子系统的cgroup虚拟文件系统。我们用mount命令查看一下该系统挂载到了何处，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">mount</span> <span class="token operator">|</span> <span class="token function">grep</span> cgroup
tmpfs on /sys/fs/cgroup <span class="token builtin class-name">type</span> tmpfs <span class="token punctuation">(</span>ro,nosuid,nodev,noexec,mode<span class="token operator">=</span><span class="token number">755</span><span class="token punctuation">)</span>
cgroup on /sys/fs/cgroup/unified <span class="token builtin class-name">type</span> cgroup2 <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,nsdelegate<span class="token punctuation">)</span>
cgroup on /sys/fs/cgroup/systemd <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,xattr,name<span class="token operator">=</span>systemd<span class="token punctuation">)</span>
cgroup on /sys/fs/cgroup/cpuset <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,cpuset<span class="token punctuation">)</span>
cgroup on /sys/fs/cgroup/pids <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,pids<span class="token punctuation">)</span>
cgroup on /sys/fs/cgroup/rdma <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,rdma<span class="token punctuation">)</span>
cgroup on /sys/fs/cgroup/memory <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,memory<span class="token punctuation">)</span>
cgroup on /sys/fs/cgroup/net_cls,net_prio <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,net_cls,net_prio<span class="token punctuation">)</span>
cgroup on /sys/fs/cgroup/cpu,cpuacct <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,cpu,cpuacct<span class="token punctuation">)</span>
cgroup on /sys/fs/cgroup/hugetlb <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,hugetlb<span class="token punctuation">)</span>
cgroup on /sys/fs/cgroup/devices <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,devices<span class="token punctuation">)</span>
cgroup on /sys/fs/cgroup/blkio <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,blkio<span class="token punctuation">)</span>
cgroup on /sys/fs/cgroup/perf_event <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,perf_event<span class="token punctuation">)</span>
cgroup on /sys/fs/cgroup/freezer <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,freezer<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该系统挂载到了/sys/fs/cgroup/memory目录下。我们在该hierarchy中创建一个test cgroup并查看该cgroup的目录结构，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">sudo</span> <span class="token function">mkdir</span> /sys/fs/cgroup/memory/test
phl@kernelnewbies:~$ tree /sys/fs/cgroup/memory/test
/sys/fs/cgroup/memory/test
├── cgroup.clone_children
├── cgroup.event_control
├── cgroup.procs
├── memory.failcnt
├── memory.force_empty
├── memory.kmem.failcnt
├── memory.kmem.limit_in_bytes
├── memory.kmem.max_usage_in_bytes
├── memory.kmem.slabinfo
├── memory.kmem.tcp.failcnt
├── memory.kmem.tcp.limit_in_bytes
├── memory.kmem.tcp.max_usage_in_bytes
├── memory.kmem.tcp.usage_in_bytes
├── memory.kmem.usage_in_bytes
├── memory.limit_in_bytes
├── memory.max_usage_in_bytes
├── memory.move_charge_at_immigrate
├── memory.numa_stat
├── memory.oom_control
├── memory.pressure_level
├── memory.soft_limit_in_bytes
├── memory.stat
├── memory.swappiness
├── memory.usage_in_bytes
├── memory.use_hierarchy
├── notify_on_release
└── tasks
<span class="token number">0</span> directories, <span class="token number">27</span> files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从结果我们可以看到，新建的test cgroup中有许多文件，这些文件中存放着资源限制信息。其中memory.limit_in_bytes里面存放的是该cgroup中的进程能够使用的内存额度。</p><p>下面，我们将当前bash加入到test cgroup中并查看当前bash所属的cgroup信息。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token builtin class-name">echo</span> <span class="token variable">$$</span>
<span class="token number">2984</span>
phl@kernelnewbies:~$ <span class="token function">sudo</span> <span class="token function">sh</span> -c <span class="token string">"echo 2984 &gt; /sys/fs/cgroup/memory/test/cgroup.procs"</span>
phl@kernelnewbies:~$ <span class="token function">cat</span> /proc/2984/cgroup
<span class="token number">12</span>:devices:/user.slice
<span class="token number">11</span>:hugetlb:/
<span class="token number">10</span>:memory:/test
<span class="token number">9</span>:rdma:/
<span class="token number">8</span>:perf_event:/
<span class="token number">7</span>:blkio:/user.slice
<span class="token number">6</span>:cpu,cpuacct:/user.slice
<span class="token number">5</span>:pids:/user.slice/user-1001.slice/session-4.scope
<span class="token number">4</span>:freezer:/
<span class="token number">3</span>:cpuset:/
<span class="token number">2</span>:net_cls,net_prio:/
<span class="token number">1</span>:name<span class="token operator">=</span>systemd:/user.slice/user-1001.slice/session-4.scope
<span class="token number">0</span>::/user.slice/user-1001.slice/session-4.scope<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从结果我们可以看到，当前bash所属的memory cgroup变为了/test，该目录为一个相对于root cgroup的相对路径。</p><p>然后，将100M写入test cgroup中的memory.limit_in_bytes文件中，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">sudo</span> <span class="token function">sh</span> -c <span class="token string">"echo 100M &gt; /sys/fs/cgroup/memory/test/memory.limit_in_bytes"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们在当前bash中启动一个占用300M进程的stress进程，该stress进程是bash的子进程，其与bash进程都在test cgroup中。命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ stress --vm <span class="token number">1</span> --vm-bytes 300M --vm-keep<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动一个新的Shell窗口，执行top命令查看stress进程占用的内存。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND
<span class="token number">14216</span> root      <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">315440</span> <span class="token number">101224</span>    <span class="token number">264</span> D <span class="token number">27.7</span>  <span class="token number">2.5</span>   <span class="token number">0</span>:02.66 stress<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>从结果我们可以看到，stress进程占用了2.5%的内存。我的电脑的内存为4G，4G * 2.5% = 100M，stress进程确实受到了cgroup中设置的内存额度的限制。</p><h4 id="2-2-2-docker-sh">2.2.2.docker.sh</h4><p>下有了以上关于CGroups的知识，我们就可以将限制内存的功能加入到docker.sh中了。限制内存的功能将放在container.sh中，带下划线的行是我们为实现限制内存而新添的代码。修改后的container.sh脚本如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">hostname</span> <span class="token variable">$container</span>
<span class="token function">mkdir</span> -p /sys/fs/cgroup/memory/<span class="token variable">$container</span>
<span class="token builtin class-name">echo</span> <span class="token variable">$$</span> <span class="token operator">&gt;</span> /sys/fs/cgroup/memory/<span class="token variable">$container</span>/cgroup.procs
<span class="token builtin class-name">echo</span> <span class="token variable">$memory</span> <span class="token operator">&gt;</span> /sys/fs/cgroup/memory/<span class="token variable">$container</span>/memory.limit_in_bytes
<span class="token function">mount</span> -t proc proc /proc
<span class="token builtin class-name">exec</span> <span class="token variable">$program</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，我们根据容器的名字创建cgroup，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> -p /sys/fs/cgroup/memory/<span class="token variable">$container</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后，我们将当前bash加入到我们创建的cgroup中，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token variable">$$</span> <span class="token operator">&gt;</span> /sys/fs/cgroup/memory/<span class="token variable">$container</span>/cgroup.procs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后，我们将内存限制写入新cgroup的memory.limit_in_bytes文件中，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token variable">$memory</span> <span class="token operator">&gt;</span> /sys/fs/cgroup/memory/<span class="token variable">$container</span>/memory.limit_in_bytes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在，我们运行docker.sh，并启动一个占用300M进程的stress进程。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/docker.sh$ <span class="token function">sudo</span> ./docker.sh -c run -m 100M -C dreamland -I ubuntu1604 -V data1 -P /bin/bash
root@dreamland:~/docker.sh<span class="token comment"># stress --vm 1 --vm-bytes 300M --vm-keep</span>
stress: info: <span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span> dispatching hogs: <span class="token number">0</span> cpu, <span class="token number">0</span> io, <span class="token number">1</span> vm, <span class="token number">0</span> hdd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>启动一个新的Shell窗口，执行top命令查看stress进程占用的内存。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND
<span class="token number">14216</span> root      <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">315440</span> <span class="token number">101224</span>    <span class="token number">264</span> D <span class="token number">27.7</span>  <span class="token number">2.5</span>   <span class="token number">0</span>:02.66 stress<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>从结果我们可以看到，容器内的stress进程只使用了100M的内存。</p><h2 id="3-切换根文件系统">3.切换根文件系统</h2><h3 id="3-1-根文件系统">3.1.根文件系统</h3><p>在容器技术中，根文件系统可为容器进程提供一个与主机不一致的文件系统环境。举个例子，主机为Ubuntu 18.04，创建的容器采用Ubuntu 16.04的根文件系统，那么容器运行时所用的软件及其依赖库、配置文件等都是Ubuntu 16.04的。尽管该容器使用的内核是仍旧是Ubuntu 18.04的，但应用软件的表现却与Ubuntu 16.04一致，从虚拟化的角度来说该容器就是一个Ubuntu 16.04系统。</p><p>debootstrap是Ubuntu下的一个工具，用来构建根文件系统。生成的目录符合Linux文件系统标准，即包含了/boot、/etc、/bin、/usr等目录。debootstrap的安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> <span class="token function">debootstrap</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面我们通过debootstrap构建Ubuntu 16.04的根文件系统。为了清晰，我们在images目录下生成根文件系统。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/docker.sh$ <span class="token function">mkdir</span> images
phl@kernelnewbies:~/docker.sh$ <span class="token builtin class-name">cd</span> images
phl@kernelnewbies:~/docker.sh/images$ <span class="token function">sudo</span> <span class="token function">debootstrap</span> --arch amd64 xenial ./ubuntu1604<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>制作根文件系统需要从服务器下载很多文件，很耗时，请耐心等待。当文件系统制作好后，可以使用tree命令查看生成的根文件系统。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/docker.sh/images$ tree -L <span class="token number">1</span> ubuntu1604/
ubuntu1604/
├── bin
├── boot
├── dev
├── etc
├── home
├── lib
├── lib64
├── media
├── mnt
├── old_root
├── opt
├── proc
├── root
├── run
├── sbin
├── srv
├── sys
├── tmp
├── usr
└── var
<span class="token number">20</span> directories, <span class="token number">0</span> files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个根文件系统与Linux系统目录很相近，我们后续的实验将使用该根文件系统。</p><h3 id="3-2-pivot-root">3.2.pivot_root</h3><p>pivot_root命令用于切换根文件系统，其使用方式如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pivot_root new_root put_old<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>pivot_root将当前进程的根文件系统移至put_old目录并使new_root目录成为新的根文件系统。</p><p>下面我们将通过实验学习pivot_root的使用方法。为了简单，我们在一个新的mount namespace下进行实验。首先，我们创建一个新的mount namespace，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/docker.sh/images$ <span class="token function">sudo</span> unshare --mount /bin/bash
root@kernelnewbies:~/docker.sh/images<span class="token comment">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在我们的实验中，我们的根文件系统将挂载在ubuntu1604目录，而老的根文件系统将被移动到ubuntu1604/old_root目录下。我们先创建old_root目录，命令如下：</p><p>root@kernelnewbies:~/docker.sh/images# mkdir -p ubuntu1604/old_root/</p><p>由于pivot_root命令要求老的根目录和新的根目录不能在同一个挂载点下，因此我们通过bind mount将ubuntu1604目录变成一个挂载点。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@kernelnewbies:~/docker.sh/images<span class="token comment"># mount --bind ubuntu1604 ubuntu1604</span>
root@kernelnewbies:~/docker.sh/images<span class="token comment"># cat /proc/self/mountinfo | grep ubuntu1604</span>
<span class="token number">624</span> <span class="token number">382</span> <span class="token number">8</span>:1 /home/phl/docker.sh/images/ubuntu1604 /home/phl/docker.sh/images/ubuntu1604 rw,relatime - ext4 /dev/sda1 rw,errors<span class="token operator">=</span>remount-ro<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>准备好切换根文件系统所需要的条件后，我们调用pivot_root切换根文件系统。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@kernelnewbies:~/docker.sh/images<span class="token comment"># cd ubuntu1604/</span>
root@kernelnewbies:~/docker.sh/images/ubuntu1604<span class="token comment"># pivot_root . old_root/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此时，已完成根文件系统的切换，/proc文件系统也被挪到了<br> /home/phl/docker.sh/images/ubuntu1604/old_root/proc，也就是说当前没有/proc文件系统，因此，我们无法查看挂载点信息，自然也无法执行一些依赖于/proc文件系统的操作。我们需要重新挂载/proc文件系统。命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@kernelnewbies:~/docker.sh/images/ubuntu1604<span class="token comment"># mount -t proc proc /proc</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重新挂载/proc文件系统后，我们就可以查看当前的挂载点信息了。通过读取/proc/self/mountinfo文件来查看系统的挂载点信息。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@kernelnewbies:~/docker.sh/images/ubuntu1604<span class="token comment"># cat /proc/self/mountinfo</span>
<span class="token number">382</span> <span class="token number">624</span> <span class="token number">8</span>:1 / /old_root rw,relatime - ext4 /dev/sda1 rw,errors<span class="token operator">=</span>remount-ro
<span class="token punctuation">..</span>.
<span class="token number">624</span> <span class="token number">381</span> <span class="token number">8</span>:1 /home/phl/docker.sh/images/ubuntu1604 / rw,relatime - ext4 /dev/sda1 rw,errors<span class="token operator">=</span>remount-ro
<span class="token number">625</span> <span class="token number">624</span> <span class="token number">0</span>:5 / /proc rw,relatime - proc proc rw<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时的挂载点很多，为了方便查看，此处只保留了一些主要的挂载点信息。这些挂载点信息包括/、/proc、/old_root。/old_root为老的根文件系统，我们需要将其卸载。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@kernelnewbies:~/docker.sh/images/ubuntu1604<span class="token comment"># umount -l /old_root/</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>卸载掉老的根文件系统后，我们再查看系统的挂载点信息。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@kernelnewbies:~/docker.sh/images/ubuntu1604<span class="token comment"># cat /proc/self/mountinfo</span>
<span class="token number">624</span> <span class="token number">381</span> <span class="token number">8</span>:1 /home/phl/docker.sh/images/ubuntu1604 / rw,relatime - ext4 /dev/sda1 rw,errors<span class="token operator">=</span>remount-ro
<span class="token number">625</span> <span class="token number">624</span> <span class="token number">0</span>:5 / /proc rw,relatime - proc proc rw<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此时，挂载点信息中只有/、/proc，不再有主机的挂载点信息。</p><h3 id="3-3-docker-sh">3.3.docker.sh</h3><p>有了以上关于切换根文件系统的知识，我们就可以将切换根文件系统的功能加入到docker.sh中了。切换根文件系统的功能将放在container.sh中，带下划线的行是我们为实现切换根文件系统而新添的代码。修改后的container.sh脚本如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token function">hostname</span> <span class="token variable">$container</span>

<span class="token function">mkdir</span> -p /sys/fs/cgroup/memory/<span class="token variable">$container</span>
<span class="token builtin class-name">echo</span> <span class="token variable">$$</span> <span class="token operator">&gt;</span> /sys/fs/cgroup/memory/<span class="token variable">$container</span>/cgroup.procs
<span class="token builtin class-name">echo</span> <span class="token variable">$memory</span> <span class="token operator">&gt;</span> /sys/fs/cgroup/memory/<span class="token variable">$container</span>/memory.limit_in_bytes

<span class="token function">mkdir</span> -p images/<span class="token variable">$image</span>/old_root
<span class="token function">mount</span> --bind images/<span class="token variable">$image</span> images/<span class="token variable">$image</span>

<span class="token builtin class-name">cd</span> images/<span class="token variable">$image</span>
pivot_root <span class="token builtin class-name">.</span> ./old_root

<span class="token function">mount</span> -t proc proc /proc
<span class="token function">umount</span> -l /old_root

<span class="token builtin class-name">exec</span> <span class="token variable">$program</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，我们在新的根文件系统目录中创建挂载老的根文件系统的目录。命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> -p images/<span class="token variable">$image</span>/old_root<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后，我们将新根文件系统目录bind mount成一个挂载点。命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mount</span> --bind images/<span class="token variable">$image</span> images/<span class="token variable">$image</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后，我们切换根文件系统。命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> images/<span class="token variable">$image</span>
pivot_root <span class="token builtin class-name">.</span> ./old_root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>最后，我们重新挂载/proc文件系统，然后卸载掉老的根文件系统。命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mount</span> -t proc proc /proc
<span class="token function">umount</span> -l /old_root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在，我们运行docker.sh，并查看当前的发行版信息。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/docker.sh$ <span class="token function">sudo</span> ./docker.sh -c run -m 100M -C dreamland -I ubuntu1604 -V data1 -P /bin/bash
root@dreamland:/<span class="token comment"># cat /etc/issue</span>
Ubuntu <span class="token number">16.04</span> LTS <span class="token punctuation">\</span>n <span class="token punctuation">\</span>l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>从结果我们可以看出，读出的发行版信息是Ubuntu 16.04 LTS \n \l，而非主机的Ubuntu 18.04.3 LTS \n \l。这说明当前使用的根文件系统确实是ubuntu16.04目录下的根文件系统，而非主机的根文件系统。</p><p>我们再查看一下当前的挂载点信息，看看是否只有/与/proc。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@dreamland:/<span class="token comment"># cat /proc/self/mountinfo</span>
<span class="token number">625</span> <span class="token number">381</span> <span class="token number">8</span>:1 /home/phl/docker.sh/images/ubuntu1604 / rw,relatime - ext4 /dev/sda1 rw,errors<span class="token operator">=</span>remount-ro
<span class="token number">626</span> <span class="token number">625</span> <span class="token number">0</span>:52 / /proc rw,relatime - proc proc rw<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>从结果我们可看出，当前挂载点信息中只有/、/proc，不再有主机的挂载点信息。</p><p>通过根文件系统，我们实现了在容器中虚拟出与主机不一样的操作系统的功能。</p><h2 id="4-联合加载">4.联合加载</h2><h3 id="4-1-联合加载简介">4.1.联合加载简介</h3><p>联合加载指的是一次同时加载多个文件系统，但是在外面看起来只能看到 一个文件系统。联合加载会将各层文件系统叠加到一起，这样最终的文件系统会 包含所有底层的文件和目录。</p><p>联合加载的多个文件系统中有一个是可读写文件系统，称为读写层，其他文件系统是只读的，称为只读层。当联合加载的文件系统发生变化时，这些变化都应用到这个读写层。比如，如果想修改一个文件，这个文件首先会从只读层复制到读写层。原只读层中的文件依然存在，但是被读写层中的该文件副本所隐藏。我们以后读写该文件时，都是读写的该文件在读写层中的副本。这种机制被称为 写时复制。</p><p>我们之前实现的docker.sh，有一个很大的缺陷。那就是，如果使用相同的根文件系统同时启动多个容器的实例，那么，这些容器实例使用的根文件系统位于同一个目录。我们在不同的容器实例对根文件系统所作的修改，这些容器彼此之间都可以看到，甚至一个容器可以覆覆盖另一个容器所作的修改。同时，容器实例退出时，对根文件系统所作的修改也直接作用于其所使用的根文件系统。当我们使用该根文件系统再次启动容器实例时，新启动的容器实例也可以看到以前的这些修改。例如，我们用ubuntu1604根文件系统启动两个容器实例，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/docker.sh$ <span class="token function">sudo</span> ./docker.sh -c run -m 100M -C dreamland -I ubuntu1604 -V data1 -P /bin/bash
phl@kernelnewbies:~/docker.sh$ <span class="token function">sudo</span> ./docker.sh -c run -m 100M -C dreamland2 -I ubuntu1604 -V data1 -P /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两个容器实例对根文件系统做的修改彼此都可以看到。容器实例退出时，这些修改也被保存了下来，当用ubuntu1604根文件系统启动新的容器实例时，新实例也可看到以前实例所做的修改。</p><p>如果容器使用的根文件系统是一个联合加载的文件系统，原先的根文件系统作为一个只读层，再添加一个读写层，那么，在容器内所作的修改都将只作用于读写层。为了区分，我们以后称ubuntu1604目录下的根文件系统为镜像。而我们可以为每一个容器实例指定一个唯一的读写层目录，这样的话，多个容器实例就可以使用同一个镜像，容器内所作的修改不会影响彼此，也不会影响到以后启动的容器实例。例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/docker.sh$ <span class="token function">sudo</span> ./docker.sh -c run -m 100M -C dreamland -I ubuntu1604 -V data1 -P /bin/bash
phl@kernelnewbies:~/docker.sh$ <span class="token function">sudo</span> ./docker.sh -c run -m 100M -C dreamland2 -I ubuntu1604 -V data1 -P /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们使用ubuntu1604镜像启动了两个容器示例，并在容器实例里进行读写操作。这两个容器实例的读写层目录是不一样的，在容器实例中所作的修改只作用于各自的读写层，彼此之间不会影响，当然更不会影响到后续启动的容器实例。</p><h3 id="4-2-AUFS">4.2. AUFS</h3><p>AUFS是一个实现了联合加载功能的文件系统。我们将采用AUFS实现docker.sh中的联合加载功能。</p><p>下面，我们将通过实验演示一下AUFS文件系统的用法。首先，我们准备需要用到的目录及文件。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">mkdir</span> aufs
phl@kernelnewbies:~$ <span class="token builtin class-name">cd</span> aufs/
phl@kernelnewbies:~/aufs$ <span class="token function">mkdir</span> rw r1 r2 union
phl@kernelnewbies:~/aufs$ <span class="token builtin class-name">echo</span> hello r1 <span class="token operator">&gt;</span> r1/hellor1.txt
phl@kernelnewbies:~/aufs$ <span class="token builtin class-name">echo</span> hello r2 <span class="token operator">&gt;</span> r2/hellor2.txt
phl@kernelnewbies:~/aufs$ <span class="token builtin class-name">echo</span> hello rw <span class="token operator">&gt;</span> rw/hellorw.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下表列出了各个目录的作用。列表如下：</p><ul><li>rw为aufs文件系统的读写层目录</li><li>r1为aufs文件系统的只读层目录</li><li>r2为aufs文件系统的只读层目录</li><li>union为挂载点，联合加载的aufs文件系统挂载于此目录</li></ul><p>下面我们将rw、r1、r2联合加载到union目录。命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/aufs$ <span class="token function">sudo</span> <span class="token function">mount</span> -t aufs -o <span class="token assign-left variable">dirs</span><span class="token operator">=</span>rw:r1:r2 none union<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>-t aufs表示要挂载的文件系统类型为AUFS</li><li>-o dirs=rw:r1:r2表示要将哪些目录加载到afus文件系统中，多个目录之间以:分隔。目录列表中的第一个目录表示读写层目录</li><li>union表示aufs文件系统要挂载的目录</li></ul><p>挂载好AUFS文件系统后，我们进入该文件系统，查看其内容。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/aufs$ <span class="token builtin class-name">cd</span> union/
phl@kernelnewbies:~/aufs/union$ <span class="token function">ls</span>
hellor1.txt hellor2.txt hellorw.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>从输出结果来看，rw、r1、r2目录下的内容全部出现在了AUFS文件系统中，该文件系统由rw、r1、r2目录叠加而成。</p><p>然后，我们修改这些文件，看看原始的rw、r1、r2目录下的文件是否更改。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/aufs/union$ <span class="token builtin class-name">echo</span> hello to r1 from union <span class="token operator">&gt;</span> hellor1.txt
phl@kernelnewbies:~/aufs/union$ <span class="token builtin class-name">echo</span> hello to r2 from union <span class="token operator">&gt;</span> hellor2.txt
phl@kernelnewbies:~/aufs/union$ <span class="token builtin class-name">echo</span> hello to rw from union <span class="token operator">&gt;</span> hellorw.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们返回到aufs目录，直接查看aufs目录下的内容。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/aufs$ tree <span class="token builtin class-name">.</span>
<span class="token builtin class-name">.</span>
├── r1
│   └── hellor1.txt
├── r2
│   └── hellor2.txt
├── rw
│   ├── hellor1.txt
│   ├── hellor2.txt
│   └── hellorw.txt
└── union
    ├── hellor1.txt
    ├── hellor2.txt
    └── hellorw.txt

<span class="token number">4</span> directories, <span class="token number">8</span> files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从输出结果我们可以看到，我们修改的hellor1.txt和hellor2.txt文件分别被拷贝了一份放在读写层目录rw中。我们查看一下这些文件的内容，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/aufs$ <span class="token function">cat</span> r1/hellor1.txt
hello r1
phl@kernelnewbies:~/aufs$ <span class="token function">cat</span> r2/hellor2.txt
hello r2
phl@kernelnewbies:~/aufs$ <span class="token function">cat</span> rw/hellor1.txt
hello to r1 from union
phl@kernelnewbies:~/aufs$ <span class="token function">cat</span> rw/hellor2.txt
hello to r2 from union
phl@kernelnewbies:~/aufs$ <span class="token function">cat</span> rw/hellorw.txt
hello to rw from union<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从输出结果我们看到，用户修改只读层r1、r2中的文件时，这些文件被复制到了读写层，我们修改的是读写层的副本，原只读层中的文件没有变化。用户修改读写层rw中的文件时，修改直接作用于这些文件本身。</p><h3 id="4-3-docker-sh">4.3.docker.sh</h3><p>在继续之前，我们需要将上一章在ubuntu1604根文件系统中创建的old_root目录删除掉，以保证该根文件系统跟刚制作好时一样。命令及结果如下：</p><p>phl@kernelnewbies:~/docker.sh$ sudo rm -rf images/ubuntu1604/old_root</p><p>有了以上关于联合加载的介绍，我们就可以将联合加载功能加入到docker.sh中了。联合加载功能将放在container.sh脚本中，带下划线的行是我们为实现联合加载功能而新添的代码。修改后的container.sh如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token function">hostname</span> <span class="token variable">$container</span>

<span class="token function">mkdir</span> -p /sys/fs/cgroup/memory/<span class="token variable">$container</span>
<span class="token builtin class-name">echo</span> <span class="token variable">$$</span> <span class="token operator">&gt;</span> /sys/fs/cgroup/memory/<span class="token variable">$container</span>/cgroup.procs
<span class="token builtin class-name">echo</span> <span class="token variable">$memory</span> <span class="token operator">&gt;</span> /sys/fs/cgroup/memory/<span class="token variable">$container</span>/memory.limit_in_bytes

<span class="token function">mkdir</span> -p <span class="token variable">$container</span>/rwlayer
<span class="token function">mount</span> -t aufs -o <span class="token assign-left variable">dirs</span><span class="token operator">=</span><span class="token variable">$container</span>/rwlayer:./images/<span class="token variable">$image</span> none <span class="token variable">$container</span>

<span class="token function">mkdir</span> -p <span class="token variable">$container</span>/old_root
<span class="token builtin class-name">cd</span> <span class="token variable">$container</span>
pivot_root <span class="token builtin class-name">.</span> ./old_root

<span class="token function">mount</span> -t proc proc /proc
<span class="token function">umount</span> -l /old_root

<span class="token builtin class-name">exec</span> <span class="token variable">$program</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，我们根据容器的名字创建联合加载需要的读写层目录及文件系统挂载目录。命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> -p <span class="token variable">$container</span>/rwlayer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>假如我们传递的容器的名字为dreamland，将创建以下目录：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/docker.sh$ tree dreamland/
dreamland/
└── rwlayer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中dreamland/rwlayer目录为创建的AUFS文件系统的读写层，dreamland目录为AUFS文件系统的挂载点。</p><p>然后我们将镜像目录、读写层目录联合加载到挂载点目录。命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mount</span> -t aufs -o <span class="token assign-left variable">dirs</span><span class="token operator">=</span><span class="token variable">$container</span>/rwlayer:./images/<span class="token variable">$image</span> none <span class="token variable">$container</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>假如容器名字为dreamland，使用的镜像为ubuntu1604根文件系统，dreamland/rwlayer、images/ubuntu1604将被联合加载的dreamland目录。其中，dreamland/rwlayer为AUFS文件系统的读写层，images/ubuntu1604为AUFS文件系统的只读层。</p><p>之前我们将老的根文件系统挪到了rootfs/old_root，rootfs代表一个具体的镜像目录。创建old_root目录时直接修改了该镜像。下面我们将老的根文件系统的挂载点目录放在AUFS文件系统中，并将老的根文件系统挪到此处。命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> -p <span class="token variable">$container</span>/old_root
<span class="token builtin class-name">cd</span> <span class="token variable">$container</span>
pivot_root <span class="token builtin class-name">.</span> ./old_root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此时，$container目录本身就是一个挂载点，挂载了AUFS文件系统。因此下面的代码就被移除了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mount</span> --bind images/<span class="token variable">$image</span> images/<span class="token variable">$image</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在，我们运行docker.sh，并在/root下创建一个文件。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/docker.sh$ <span class="token function">sudo</span> ./docker.sh -c run -m 100M -C dreamland -I ubuntu1604 -V data1 -P /bin/bash
root@dreamland:/<span class="token comment"># cd /root</span>
root@dreamland:/root<span class="token comment"># ls</span>
root@dreamland:/root<span class="token comment"># cat /etc/issue &gt; hello.txt</span>
root@dreamland:/root<span class="token comment"># cat hello.txt</span>
Ubuntu <span class="token number">16.04</span> LTS <span class="token punctuation">\</span>n <span class="token punctuation">\</span>l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动一个新的Shell窗口，查看一下该容器使用的AUFS文件系统。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/docker.sh$ <span class="token function">sudo</span> tree dreamland/
dreamland/
└── rwlayer
    ├── old_root
    └── root
        └── hello.txt

<span class="token number">2</span> directories, <span class="token number">1</span> <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从结果我们可以看到，我们新建的文件及创建的老根文件系统的挂载点目录都出现在了读写层。我们再查看一下新创建的文件。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/docker.sh$ <span class="token function">sudo</span> <span class="token function">cat</span> dreamland/rwlayer/root/hello.txt
Ubuntu <span class="token number">16.04</span> LTS <span class="token punctuation">\</span>n <span class="token punctuation">\</span>l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>文件内容是Ubuntu 16.04的发行版信息。</p><p>通过联合加载，我们实现了在容器中的读写不会影响使用的镜像。这样使用ubuntu1604镜像创建多个容器时，彼此之间就不会相互影响了。</p><h2 id="5-卷">5.卷</h2><h3 id="5-1-卷简介">5.1.卷简介</h3><p>卷是容器内的一个目录，这个目录可以绕过联合文件系统，提供数据共享（容器所使用的的联合文件系统不应该被主机或其他容器访问）与数据持久化的功能。</p><p>举个例子，假如容器有个目录为/data的卷，我们向这个卷写入的内容不会出现在联合文件系统的读写层，而是直接出现在这个目录里。主机与其他容器也可以访问该目录，从而达到数据共享与数据持久化的目的。</p><p>卷位于联合文件系统中，通常来说写入该目录的内容会被写入容器的读写层中，那么怎样才能是写入卷的目录直接出现在该目录中，而不是容器读写层呢？其实方法很简单，只要我们将该目录变成一个挂载点就行，变成挂载点后，这个目录中的内容就不属于联合文件系统了，写入该目录的内容自然会保存在挂载到该挂载点的设备中。</p><h3 id="5-2-docker-sh">5.2 docker.sh</h3><p>有了以上关于卷的介绍，我们就可以将卷功能加入到docker.sh中了。卷功能将放在container.sh脚本中，带下划线的行是我们为实现卷功能而新添的代码。修改后的container.sh脚本如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token function">hostname</span> <span class="token variable">$container</span>

<span class="token function">mkdir</span> -p /sys/fs/cgroup/memory/<span class="token variable">$container</span>
<span class="token builtin class-name">echo</span> <span class="token variable">$$</span> <span class="token operator">&gt;</span> /sys/fs/cgroup/memory/<span class="token variable">$container</span>/cgroup.procs
<span class="token builtin class-name">echo</span> <span class="token variable">$memory</span> <span class="token operator">&gt;</span> /sys/fs/cgroup/memory/<span class="token variable">$container</span>/memory.limit_in_bytes

<span class="token function">mkdir</span> -p <span class="token variable">$container</span>/rwlayer
<span class="token function">mount</span> -t aufs -o <span class="token assign-left variable">dirs</span><span class="token operator">=</span><span class="token variable">$container</span>/rwlayer:./images/<span class="token variable">$image</span> none <span class="token variable">$container</span>

<span class="token function">mkdir</span> -p <span class="token variable">$volume</span>
<span class="token function">mkdir</span> -p <span class="token variable">$container</span>/<span class="token variable">$volume</span>
<span class="token function">mount</span> --bind <span class="token variable">$volume</span> <span class="token variable">$container</span>/<span class="token variable">$volume</span>

<span class="token function">mkdir</span> -p <span class="token variable">$container</span>/old_root
<span class="token builtin class-name">cd</span> <span class="token variable">$container</span>
pivot_root <span class="token builtin class-name">.</span> ./old_root

<span class="token function">mount</span> -t proc proc /proc
<span class="token function">umount</span> -l /old_root

<span class="token builtin class-name">exec</span> <span class="token variable">$program</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，我们根据卷的名字创建主机卷目录，我们在容器内部对卷的修改，都将作用于此目录。命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> -p <span class="token variable">$volume</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后，我们在容器内部创建同名卷目录，该目录本身会出现在容器的读写层中，因为该目录是在AUFS文件系统中创建的。因为<img src="https://math.now.sh?inline=container%E7%9B%AE%E5%BD%95%E4%B8%BA%E5%AE%B9%E5%99%A8%E7%9A%84%E6%A0%B9%E7%9B%AE%E5%BD%95%EF%BC%8C%E6%89%80%E4%BB%A5%E5%AE%B9%E5%99%A8%E5%86%85%E9%83%A8%E5%8D%B7%E7%9B%AE%E5%BD%95%E7%9A%84%E8%B7%AF%E5%BE%84%E4%B8%BA%2F" style="filter:opacity(90%);transform:scale(.85);text-align:center;display:inline-block;margin:0">volume。命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> -p <span class="token variable">$container</span>/<span class="token variable">$volume</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将主机上的卷目录bind mount到容器内部的卷目录上，这样容器内部对卷目录的修改，都将作用于主机卷目录。命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mount</span> --bind <span class="token variable">$volume</span> <span class="token variable">$container</span>/<span class="token variable">$volume</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在，我们运行docker.sh，并在卷目录（/data1）中创建一个文件。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/docker.sh$ <span class="token function">sudo</span> ./docker.sh -c run -m 100M -C dreamland -I ubuntu1604 -V data1 -P /bin/bash
root@dreamland:/<span class="token comment"># cd /data1</span>
root@dreamland:/data1<span class="token comment"># echo "hello to data1 volume from ubuntu16.04" &gt;&gt; hello.txt</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>启动一个新的Shell窗口，查看一下该容器使用的AUFS文件系统中的内容。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/docker.sh$ <span class="token function">sudo</span> tree dreamland/
dreamland/
└── rwlayer
    ├── data1
    ├── old_root
    └── root
        └── hello.txt

<span class="token number">4</span> directories, <span class="token number">1</span> <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从结果我们可以看到，我们使用的卷目录被创建在了容器的读写层，但是我们在卷目录中新建的文件却没有出现在读写层中。</p><p>我们再来查看一下主机卷目录的内容。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/docker.sh$ <span class="token function">sudo</span> tree data1/
data1/
└── hello.txt

<span class="token number">0</span> directories, <span class="token number">1</span> <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从结果我们可以看到，在容器内部对卷目录的修改直接作用在了主机上的卷目录。我们再来查看一下主机卷目录下hello.txt中的内容。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/docker.sh$ <span class="token function">sudo</span> <span class="token function">cat</span> data1/hello.txt
hello to data1 volume from ubuntu16.04<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>从结果我们可以看到，该文件的内容与我们在容器内部写入hello.txt的内容一致。</p><p>通过卷目录，我们实现了容器之间数据共享与数据持久化的功能。</p><h2 id="6-后记">6.后记</h2><p>至此，我们通过一系列的实验对docker的底层技术有了一个感性的认识。我们在使用docker时，也能够对其是如何运作的有了一个大致的了解。当然，这对于掌握docker技术来说还远远不够，有很多知识我们没有涉及，例如user namespace、容器安全、其他的CGroups、虚拟网络等。</p><p>编辑整理 <a target="_blank" rel="noopener" href="https://www.toutiao.com/i6890898988879315468/?tt_from=weixin&amp;utm_campaign=client_share&amp;wxshare_count=1&amp;timestamp=1647576105&amp;app=news_article&amp;utm_source=weixin&amp;utm_medium=toutiao_android&amp;use_new_style=1&amp;req_id=202203181201440101511900790A2CBE46&amp;share_token=b2d9351e-4cb1-4a25-ae82-f70543ce2a3b&amp;group_id=6890898988879315468">ScratchLab</a></p><link rel="stylesheet" href="/css/bilicard.css" type="text/css"></div><hr><div class="reprint" id="reprint-statement"><div class="reprint__author"> <span class="reprint-meta" style="font-weight:700"><i class="fas fa-user">文章作者:</i></span> <span class="reprint-info"><a href="https://blog.17lai.site" rel="external nofollow noreferrer">夜法之书</a></span></div><div class="reprint__type"> <span class="reprint-meta" style="font-weight:700"><i class="fas fa-link">文章链接:</i></span> <span class="reprint-info"><a href="https://blog.17lai.site/posts/90e60aac/">https://blog.17lai.site/posts/90e60aac/</a></span></div><div class="reprint__notice"> <span class="reprint-meta" style="font-weight:700"><i class="fas fa-copyright">版权声明:</i></span> <span class="reprint-info">本博客所有文章除特別声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.17lai.site" target="_blank">夜法之书</a> !</span></div></div><script async defer="defer">
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"> <a href="/tags/linux/"><span class="chip bg-color">linux</span></a> <a href="/tags/docker/"><span class="chip bg-color">docker</span></a> <a href="/tags/shell/"><span class="chip bg-color">shell</span></a></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="/libs/share/js/social-share.min.js"></script></div></div></div><style>#reward{margin:40px 0;text-align:center}#reward .reward-link{font-size:1.4rem;line-height:38px}#reward .btn-floating:hover{box-shadow:0 6px 12px rgba(0,0,0,.2),0 5px 15px rgba(0,0,0,.2)}#rewardModal{width:320px;height:350px}#rewardModal .reward-title{margin:15px auto;padding-bottom:5px}#rewardModal .modal-content{padding:10px}#rewardModal .close{position:absolute;right:15px;top:15px;color:rgba(0,0,0,.5);font-size:1.3rem;line-height:20px;cursor:pointer}#rewardModal .close:hover{color:#ef5350;transform:scale(1.3);-moz-transform:scale(1.3);-webkit-transform:scale(1.3);-o-transform:scale(1.3)}#rewardModal .reward-tabs{margin:0 auto;width:210px}.reward-tabs .tabs{height:38px;margin:10px auto;padding-left:0}.reward-content ul{padding-left:0!important}.reward-tabs .tabs .tab{height:38px;line-height:38px}.reward-tabs .tab a{color:#fff;background-color:#ccc}.reward-tabs .tab a:hover{background-color:#ccc;color:#fff}.reward-tabs .wechat-tab .active{color:#fff!important;background-color:#22ab38!important}.reward-tabs .alipay-tab .active{color:#fff!important;background-color:#019fe8!important}.reward-tabs .reward-img{width:210px;height:210px}</style><div id="reward"> <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a><div id="rewardModal" class="modal"><div class="modal-content"><a class="close modal-close"><i class="fas fa-times"></i></a><h4 class="reward-title">码字辛苦，打赏作者！</h4><div class="reward-content"><div class="reward-tabs"><ul class="tabs row"><li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li><li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li></ul><div id="alipay"> <img src="/medias_webp/reward/alipay.webp" class="reward-img" alt="支付宝打赏二维码"></div><div id="wechat"> <img src="/medias_webp/reward/wechat.webp" class="reward-img" alt="微信打赏二维码"></div></div></div></div></div></div><script>$(function(){$(".tabs").tabs()})</script></div></div><style>.fa-chrome:before{color:#f14f05}.fa-windows:before{color:#3f8cd9}.fa-macos:before{color:#000}.fa-edge:before{color:#1a2bdc}.fa-safari:before{color:#26a69a}.fa-qq:before{content:"\f1d6"}.fa-android:before{content:"\f17b";color:#0c9850}.fa-wechat:before,.fa-weixin:before{content:"\f1d7"}.fa-firefox:before{color:#f53a3a}.valine-card{margin:1.5rem auto}.valine-card .card-content{padding:20px 20px 5px 20px}.v[data-class="v"] .vwrap .vheader .vinput{width:32%;border-bottom:1px dashed #dedede}#vcomments textarea{box-sizing:border-box;background:url(https://cdn.jsdelivr.net/gh/appotry/hexo@latest/medias_webp/hongmiaosi.webp) 100% 100% no-repeat;background-size:contain;background-position:right;background-color:rgba(255,255,255,0);resize:vertical;caret-color:red;color:#1a2bdc;white-space:pre-line}#vcomments p{margin:2px 2px 10px;font-size:1.05rem;line-height:1.78rem}#vcomments blockquote p{text-indent:.2rem}#vcomments a{padding:0 2px;color:#4cbf30;font-weight:500;text-decoration:none}#vcomments img{max-width:100%;height:auto;cursor:pointer}#vcomments ol li{list-style-type:decimal}#vcomments ol,ul{display:block;padding-left:2em;word-spacing:.05rem}#vcomments ul li,ol li{display:list-item;line-height:1.8rem;font-size:1rem}#vcomments ul li{list-style-type:disc}#vcomments ul ul li{list-style-type:circle}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}#vcomments table,td,th{border:0}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments h1{font-size:1.85rem;font-weight:700;line-height:2.2rem}#vcomments h2{font-size:1.65rem;font-weight:700;line-height:1.9rem}#vcomments h3{font-size:1.45rem;font-weight:700;line-height:1.7rem}#vcomments h4{font-size:1.25rem;font-weight:700;line-height:1.5rem}#vcomments h5{font-size:1.1rem;font-weight:700;line-height:1.4rem}#vcomments h6{font-size:1rem;line-height:1.3rem}#vcomments p{font-size:1rem;line-height:1.5rem}#vcomments hr{margin:12px 0;border:0;border-top:1px solid #ccc}#vcomments blockquote{margin:15px 0;border-left:5px solid #42b983;padding:1rem .8rem .3rem .8rem;color:#666;background-color:rgba(66,185,131,.1)}#vcomments pre{font-family:monospace,monospace;padding:1.2em;margin:.5em 0;background:#272822;overflow:auto;border-radius:.3em;tab-size:4}#vcomments code{font-family:monospace,monospace;padding:1px 3px;font-size:.92rem;color:#e96900;background-color:#f8f8f8;border-radius:2px}#vcomments pre code{font-family:monospace,monospace;padding:0;color:#e8eaf6;background-color:#272822}#vcomments pre[class*=language-]{padding:1.2em;margin:.5em 0}#vcomments code[class*=language-],pre[class*=language-]{color:#e8eaf6}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}#vcomments b,strong{font-weight:700}#vcomments dfn{font-style:italic}#vcomments small{font-size:85%}#vcomments cite{font-style:normal}#vcomments mark{background-color:#fcf8e3;padding:.2em}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}</style><div class="card valine-card" data-aos="fade-up"><div class="comment_headling" style="font-size:20px;font-weight:700;position:relative;padding-left:20px;top:15px;padding-bottom:5px"><i class="fas fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div id="vcomments" class="card-content" style="display:grid"></div></div><script src="/libs/valine/av-min.js"></script><script src="/libs/valine/Valine.min.js"></script><script>
    let metaPlaceholder = {"nick":"昵称/QQ号(必填)","mail":"邮箱(必填)","link":"网址(https://)"} ;

    new Valine({
        el: '#vcomments', 
        appId: 'v2hJTCLDHLnGF4iSJkBJ8mga-MdYXbMMI', 
        appKey: 'Hu4UNHLVERHkhfH6G5xqdqN3', 
        serverURLs: 'https://v2hjtcld.api.lncldglobal.com',
        notify: 'false' === 'true', 
        verify: 'false' === 'true', 
        visitor: 'true' === 'true', 
        avatar: 'monsterid', 
        pageSize: '10', 
        lang: 'zh-CN', 
        placeholder: '🤣一起来玩，留下你的足迹吧~。评论支持📧邮箱回复通知！\r\n 🚀昵称使用QQ号可以自动补全邮箱和显示头像昵称等信息呢 \r\n 💣请文明评论哦禁止恶意评论\r\n ⚠️公开网络空间，请不要发表任何包含个人或其他人的隐私信息', 
        meta: ["nick", "mail", "link"], 
        recordIP: 'true' === 'true', 
        enableQQ: 'monsterid', 
        requiredFields: ["034f6b6a1d9b52722c151726bcfd5ead"], 
        master: ["034f6b6a1d9b52722c151726bcfd5ead"], 
        friends: ["641A8095D4AA5757C24D7D06E97A6314", "901345d4c91ddfd8db0f175bbcfff0c8", "1512958e18378c98b498d5effe3e76ff"], 
        tagMeta: ["博主", "小伙伴", "访客"], 
        metaPlaceholder: metaPlaceholder,
    });

    document.body.addEventListener('click', function (e) {
        if (e.target.classList.contains('vsubmit')) {
            const email = document.querySelector('input[type=email]');
            const nick = document.querySelector('input[name=nick]');
            const reg = /^[A-Za-z0-9_-\u4e00-\u9fa5]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$/;
            if (!email.value || !nick.value || !reg.test(email.value)) {
                const str = `<div class="valert txt-center"><div class="vtext">请填写正确的昵称和邮箱！</div></div>`;
                const vmark = document.querySelector('.vmark');
                vmark.innerHTML = str;
                vmark.style.display = 'block';

                e.stopPropagation();

                setTimeout(function () {
                    vmark.style.display = 'none';
                    vmark.innerHTML = '';
                }, 2500);
            }
        }
    }, true);
</script><div id="to_comment" class="comment-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#vcomments" title="直达评论"><i class="fas fa-comments"></i></a></div><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fas fa-chevron-left"></i> &nbsp;上一篇</div><div class="card"><a href="/posts/3b296307/"><div class="card-image card-image-V"><div class="box-content"><h3 class="title">阅读全文</h3> <span class="post" style="width:180px">winrar去广告和破解</span></div> <img src="/medias_webp/cover/winrar.webp" class="responsive-img" alt="winrar去广告和破解"> <span class="card-title title-V">winrar去广告和破解</span></div></a><div class="card-content article-content"><div class="summary block-with-text"> winrar国内版弹窗广告太讨人嫌了，如何去除广告了？本文一步一步教你如何破解winrar并且去除广告。还你一个清爽的使用体验</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i> 2022-03-19</span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/tools/" class="post-category">tools</a></span></div></div><div class="card-action article-tags"> <a href="/tags/crack/"><span class="chip bg-color">crack</span></a> <a href="/tags/tools/"><span class="chip bg-color">tools</span></a> <a href="/tags/winrar/"><span class="chip bg-color">winrar</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color"> 下一篇&nbsp;<i class="fas fa-chevron-right"></i></div><div class="card"><a href="/posts/68d3867d/"><div class="card-image card-image-V"><div class="box-content"><h3 class="title">阅读全文</h3> <span class="post" style="width:180px">node 项目从构建到使用 jenkins + docker + nginx + mysql + redis 自动化部署</span></div> <img src="/medias_webp/cover/web.webp" class="responsive-img" alt="node 项目从构建到使用 jenkins + docker + nginx + mysql + redis 自动化部署"> <span class="card-title title-V">node 项目从构建到使用 jenkins + docker + nginx + mysql + redis 自动化部署</span></div></a><div class="card-content article-content"><div class="summary block-with-text"> node 项目从构建到使用 jenkins + docker + nginx + mysql + redis CI/CD自动化部署全过程详解，一步一步教你完成自动化！</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i> 2022-03-16</span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/web/" class="post-category">web</a></span></div></div><div class="card-action article-tags"> <a href="/tags/docker/"><span class="chip bg-color">docker</span></a> <a href="/tags/web/"><span class="chip bg-color">web</span></a> <a href="/tags/ci-cd/"><span class="chip bg-color">ci/cd</span></a> <a href="/tags/node/"><span class="chip bg-color">node</span></a> <a href="/tags/jenkins/"><span class="chip bg-color">jenkins</span></a></div></div></div></div></article></div><script>$("#articleContent").on("copy",function(e){if(void 0!==window.getSelection){var n=window.getSelection();if(!((""+n).length<Number.parseInt("100"))){var t=document.getElementsByTagName("body")[0],o=document.createElement("div");o.style.position="absolute",o.style.left="-99999px",t.appendChild(o),o.appendChild(n.getRangeAt(0).cloneContents()),"PRE"!==n.getRangeAt(0).commonAncestorContainer.nodeName&&"CODE"!==n.getRangeAt(0).commonAncestorContainer.nodeName||(o.innerHTML="<pre>"+o.innerHTML+"</pre>");var i=document.location.href;o.innerHTML+='<br />来源: 夜法之书<br />文章作者: 夜法之书<br />文章链接: <a href="'+i+'">'+i+"</a><br />本文章著作权归作者所有，任何形式的转载都请注明出处。",n.selectAllChildren(o),window.setTimeout(function(){t.removeChild(o)},200)}}})</script><script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script><script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script><script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script><script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget card" style="background-color:#fff"><div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color" title="显示/隐藏目录"><i class="fas fa-list-ul"></i></a></div><script src="/libs/tocbot/tocbot.min.js"></script><script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4, h5, h6'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script></main><footer class="page-footer bg-color"><div class="container row center-align" style="margin-bottom:0!important"><div class="col s12 m8 l8 copy-right"> Copyright&nbsp;&copy; <span id="year">2020-2022</span> <a href="/about" target="_blank">夜法之书</a> |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a><br> &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span class="white-color">218.8k</span> <span id="busuanzi_container_site_pv">&nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv" class="white-color"></span></span> <span id="busuanzi_container_site_uv">&nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv" class="white-color"></span></span><br><br></div><div class="col s12 m4 l4 social-link social-statis"><a href="https://github.com/appotry" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fab fa-github"></i></a><a href="https://hub.docker.com/u/bloodstar" class="tooltipped" target="_blank" data-tooltip="访问我的DockerHub" data-position="top" data-delay="50"><i class="fab fa-docker"></i></a><a href="mailto:andycrusoe@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50"><i class="fas fa-envelope-open"></i></a><a href="https://twitter.com/firedingden" class="tooltipped" target="_blank" data-tooltip="关注我的Twitter: https://twitter.com/firedingden" data-position="top" data-delay="50"><i class="fab fa-twitter"></i></a><a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50"><i class="fas fa-rss"></i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fas fa-search"></i> &nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script type="text/javascript">$(function(){!function(t,a,s){"use strict";$.ajax({url:t,dataType:"xml",success:function(t){var e=$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),r=document.getElementById(a),n=document.getElementById(s);r.addEventListener("input",function(){var f='<ul class="search-result-list">',m=this.value.trim().toLowerCase().split(/[\s\-]+/);n.innerHTML="",this.value.trim().length<=0||(e.forEach(function(t){var r=!0,n=t.title.trim().toLowerCase(),a=t.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),e=t.url;e=0===e.indexOf("/")?t.url:"/"+e;var s=-1,i=-1,l=-1;if(""!==n&&""!==a&&m.forEach(function(t,e){s=n.indexOf(t),i=a.indexOf(t),s<0&&i<0?r=!1:(i<0&&(i=0),0===e&&(l=i))}),r){f+="<li><a href='"+e+"' class='search-result-title'>"+n+"</a>";var c=t.content.trim().replace(/<[^>]+>/g,"");if(0<=l){var u=l-20,o=l+80;u<0&&(u=0),0===u&&(o=100),o>c.length&&(o=c.length);var h=c.substr(u,o);m.forEach(function(t){var e=new RegExp(t,"gi");h=h.replace(e,'<em class="search-keyword">'+t+"</em>")}),f+='<p class="search-result">'+h+"...</p>"}f+="</li>"}}),f+="</ul>",n.innerHTML=f)})}})}("/search.xml","searchInput","searchResult")})</script><div class="stars-con"><div id="stars"></div><div id="stars2"></div><div id="stars3"></div></div><script>function switchNightMode(){$('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($("body")),setTimeout(function(){$("body").hasClass("DarkMode")?($("body").removeClass("DarkMode"),localStorage.setItem("isDark","0"),$("#sum-moon-icon").removeClass("fa-sun").addClass("fa-moon")):($("body").addClass("DarkMode"),localStorage.setItem("isDark","1"),$("#sum-moon-icon").addClass("fa-sun").removeClass("fa-moon")),setTimeout(function(){$(".Cuteen_DarkSky").fadeOut(1e3,function(){$(this).remove()})},2e3)})}</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!" title="回到顶部"><i class="fas fa-arrow-up"></i></a></div><script src="/libs/materialize/materialize.min.js"></script><script src="/libs/masonry/masonry.pkgd.min.js"></script><script src="/libs/aos/aos.js"></script><script src="/libs/scrollprogress/scrollProgress.min.js"></script><script src="/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="/js/matery.js"></script><script async src="/libs/others/busuanzi.pure.mini.js"></script><script src="https://live2d.17lai.site/autoload.js" defer="defer"></script><script src="/libs/instantpage/instantpage.js" type="module"></script><script>
        // init PWA
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker
            .register('/sw.js')
            .then(function () {
                console.log("Service Worker Registered");
            });
        }
        
        let deferredPrompt;
        
        window.addEventListener('beforeinstallprompt', function (e) {
            // Prevent Chrome 67 and earlier from automatically showing the prompt
            e.preventDefault();
            // Stash the event so it can be triggered later.
            deferredPrompt = e;
            showAddToHomeScreen();
        });
        
        function showAddToHomeScreen() {
            let toastHTML = '<span>使<b> 夜法之书 </b>可以离线访问？</span><button class="btn-flat toast-action" onclick="addToHomeScreen()">Yes</button>';
            M.toast({html: toastHTML});
        }
        
        function addToHomeScreen() {
            deferredPrompt.prompt();  // Wait for the user to respond to the prompt
            deferredPrompt.userChoice
            .then(function (choiceResult) {
                if (choiceResult.outcome === 'accepted') {
                console.log('User accepted the A2HS prompt');
                } else {
                console.log('User dismissed the A2HS prompt');
                }
                deferredPrompt = null;
            });
        }
    </script><script>"1"===localStorage.getItem("isDark")?(document.body.classList.add("DarkMode"),$("#sum-moon-icon").addClass("fa-sun").removeClass("fa-moon")):(document.body.classList.remove("DarkMode"),$("#sum-moon-icon").removeleClass("fa-sun").addClass("fa-moon"))</script><script>if(window.location.hash)var checkExist=setInterval(function(){$(window.location.hash).length&&($("html, body").animate({scrollTop:$(window.location.hash).offset().top-90},1e3),clearInterval(checkExist))},100)</script><script src="https://cdn.jsdelivr.net/npm/hexo-tag-common@0.0.5/js/index.js"></script><script>!function(e,s,p,r){if(void 0===e.webpushr){e.webpushr=e.webpushr||function(){(e.webpushr.q=e.webpushr.q||[]).push(arguments)};var n,w=s.getElementsByTagName(p)[0];(n=s.createElement(p)).id="webpushr-jssdk",n.async=1,n.src="https://cdn.webpushr.com/app.min.js",w.parentNode.appendChild(n)}}(window,document,"script"),webpushr("setup",{key:"BDHamjevXR9yPJrttxl80MjCYEwm3CKzwsi3rwMXxq4Lnbzhr2fNQARqXJVhfBn_ucmy9QHixa3qps8eEFXBwmw"})</script></body></html>