<!DOCTYPE html>
<html>
<head>
<meta charset='utf-8'>
<title>FSharp</title>
<link href='style.css' rel='stylesheet'>
<link href='//dash_ref/Category/Basics/1'>
<link href='//dash_ref_Basics/Entry/Comments/0'>
<link href='//dash_ref_Basics/Entry/Strings/0'>
<link href='//dash_ref_Basics/Entry/Basic Types and Literals/0'>
<link href='//dash_ref_Basics/Entry/Tuples and Records/0'>
<link href='//dash_ref_Basics/Entry/Discriminated Unions/0'>
<link href='//dash_ref_Basics/Entry/Exceptions/0'>
<link href='//dash_ref/Category/Functions/1'>
<link href='//dash_ref_Functions/Entry/Definition/0'>
<link href='//dash_ref_Functions/Entry/Pipe and composition operators/0'>
<link href='//dash_ref_Functions/Entry/Recursive functions/0'>
<link href='//dash_ref/Category/Collections/1'>
<link href='//dash_ref_Collections/Entry/Lists/0'>
<link href='//dash_ref_Collections/Entry/Arrays/0'>
<link href='//dash_ref_Collections/Entry/Sequences/0'>
<link href='//dash_ref_Collections/Entry/Higher-order functions on collections/0'>
<link href='//dash_ref/Category/Pattern Matching/1'>
<link href='//dash_ref_Pattern Matching/Entry/Pattern Matching/0'>
<link href='//dash_ref_Pattern Matching/Entry/Active Patterns/0'>
<link href='//dash_ref/Category/Scripting/1'>
<link href='//dash_ref_Scripting/Entry/Compiler Directives/0'>
</head>
<body>
<header>
<h1>FSharp</h1>
</header>
<article>
<p></p>
<section class='category'>
<h2 id='//dash_ref/Category/Basics/1'>
Basics
</h2>
<div class='scrollable'>
<table>
<tr id='//dash_ref_Basics/Entry/Comments/0'>
<td class='description' colspan='2'>
<div class='name'><p>Comments</p>
</div>
<div class='notes'><p>Block comments are placed between <code>(*</code> and <code>*)</code>. Line comments start from <code>//</code> and continue until the end of the line.</p>
<pre class="highlight fsharp"><span class="c">(* This is block comment *)</span>&#x000A;&#x000A;<span class="c1">// And this is line comment</span></pre>
<p>XML doc comments come after <code>///</code> allowing us to use XML tags to generate documentation.</p>
<pre class="highlight fsharp"><span class="c1">/// The `let` keyword defines an (immutable) value</span>&#x000A;<span class="k">let</span> <span class="n">result</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">=</span> <span class="mi">2</span></pre></div>
</td>
</tr>
<tr id='//dash_ref_Basics/Entry/Strings/0'>
<td class='description' colspan='2'>
<div class='name'><p>Strings</p>
</div>
<div class='notes'><p>F# <code>string</code> type is an alias for <code>System.String</code> type.</p>
<pre class="highlight fsharp"><span class="c1">/// Create a string using string concatenation</span>&#x000A;<span class="k">let</span> <span class="n">hello</span> <span class="p">=</span> <span class="s2">"Hello"</span> <span class="o">+</span> <span class="s2">" World"</span></pre>
<p>Use <em>verbatim strings</em> preceded by <code>@</code> symbol to avoid escaping control characters (except escaping <code>&quot;</code> by <code>&quot;&quot;</code>).</p>
<pre class="highlight fsharp"><span class="k">let</span> <span class="n">verbatimXml</span> <span class="p">=</span> <span class="o">@</span><span class="s2">"&lt;book title=""Paradise Lost""&gt;"</span></pre>
<p>We don&#39;t even have to escape <code>&quot;</code> with <em>triple-quoted strings</em>.</p>
<pre class="highlight fsharp"><span class="k">let</span> <span class="n">tripleXml</span> <span class="p">=</span> <span class="s2">"""&lt;book title="</span><span class="nc">Paradise</span> <span class="nc">Lost</span><span class="s2">"&gt;"""</span></pre>
<p><em>Backslash strings</em> indent string contents by stripping leading spaces.</p>
<pre class="highlight fsharp"><span class="k">let</span> <span class="n">poem</span> <span class="p">=</span>&#x000A;  <span class="s2">"The lesser world was daubed</span><span class="se">\n</span><span class="s2">\&#x000A;    By a colorist of modest skill</span><span class="se">\n</span><span class="s2">\&#x000A;    A master limned you in the finest inks</span><span class="se">\n</span><span class="s2">\&#x000A;    And with a fresh-cut quill."</span></pre></div>
</td>
</tr>
<tr id='//dash_ref_Basics/Entry/Basic Types and Literals/0'>
<td class='description' colspan='2'>
<div class='name'><p>Basic Types and Literals</p>
</div>
<div class='notes'><p>Most numeric types have associated suffixes, e.g., <code>uy</code> for unsigned 8-bit integers and <code>L</code> for signed 64-bit integer.</p>
<pre class="highlight fsharp"><span class="k">let</span> <span class="n">b</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="p">=</span> <span class="mi">86</span><span class="n">uy</span><span class="p">,</span> <span class="mi">86</span><span class="p">,</span> <span class="mi">86</span><span class="nc">L</span>&#x000A;&#x000A;<span class="c1">// [fsi:val b : byte = 86uy]</span>&#x000A;<span class="c1">// [fsi:val i : int = 86]</span>&#x000A;<span class="c1">// [fsi:val l : int64 = 86L]</span></pre>
<p>Other common examples are <code>F</code> or <code>f</code> for 32-bit floating-point numbers, <code>M</code> or <code>m</code> for decimals, and <code>I</code> for big integers.</p>
<pre class="highlight fsharp"><span class="k">let</span> <span class="n">s</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">bi</span> <span class="p">=</span> <span class="mi">4</span><span class="p">.</span><span class="mi">14</span><span class="nc">F</span><span class="p">,</span> <span class="mi">4</span><span class="p">.</span><span class="mi">14</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">7833</span><span class="nc">M</span><span class="p">,</span> <span class="mi">9999</span><span class="nc">I</span>&#x000A;&#x000A;<span class="c1">// [fsi:val s : float32 = 4.14f]</span>&#x000A;<span class="c1">// [fsi:val f : float = 4.14]</span>&#x000A;<span class="c1">// [fsi:val d : decimal = 0.7833M]</span>&#x000A;<span class="c1">// [fsi:val bi : System.Numerics.BigInteger = 9999]</span></pre>
<p>See <a href="http://msdn.microsoft.com/en-us/library/dd233193.aspx">Literals (MSDN)</a> for complete reference.</p>
</div>
</td>
</tr>
<tr id='//dash_ref_Basics/Entry/Tuples and Records/0'>
<td class='description' colspan='2'>
<div class='name'><p>Tuples and Records</p>
</div>
<div class='notes'><p>A <em>tuple</em> is a grouping of unnamed but ordered values, possibly of different types:</p>
<pre class="highlight fsharp"><span class="c1">// Tuple construction</span>&#x000A;<span class="k">let</span> <span class="n">x</span> <span class="p">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">"Hello"</span><span class="p">)</span>&#x000A;&#x000A;<span class="c1">// Triple</span>&#x000A;<span class="k">let</span> <span class="n">y</span> <span class="p">=</span> <span class="p">(</span><span class="s2">"one"</span><span class="p">,</span> <span class="s2">"two"</span><span class="p">,</span> <span class="s2">"three"</span><span class="p">)</span>&#x000A;&#x000A;<span class="c1">// Tuple deconstruction / pattern</span>&#x000A;<span class="k">let</span> <span class="p">(</span><span class="n">a'</span><span class="p">,</span> <span class="n">b'</span><span class="p">)</span> <span class="p">=</span> <span class="n">x</span></pre>
<p>The first and second elements of a tuple can be obtained using <code>fst</code>, <code>snd</code>, or pattern matching:</p>
<pre class="highlight fsharp"><span class="k">let</span> <span class="n">c'</span> <span class="p">=</span> <span class="n">fst</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>&#x000A;<span class="k">let</span> <span class="n">d'</span> <span class="p">=</span> <span class="n">snd</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>&#x000A;&#x000A;<span class="k">let</span> <span class="n">print'</span> <span class="n">tuple</span> <span class="p">=</span>&#x000A;    <span class="k">match</span> <span class="n">tuple</span> <span class="k">with</span>&#x000A;    <span class="p">|</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">printfn</span> <span class="s2">"Pair %A %A"</span> <span class="n">a</span> <span class="n">b</span></pre>
<p><em>Records</em> represent simple aggregates of named values, optionally with members:</p>
<pre class="highlight fsharp"><span class="c1">// Declare a record type</span>&#x000A;<span class="k">type</span> <span class="nc">Person</span> <span class="p">=</span> <span class="p">{</span> <span class="nc">Name</span> <span class="p">:</span> <span class="kt">string</span><span class="p">;</span> <span class="nc">Age</span> <span class="p">:</span> <span class="kt">int</span> <span class="p">}</span>&#x000A;&#x000A;<span class="c1">// Create a value via record expression</span>&#x000A;<span class="k">let</span> <span class="n">paul</span> <span class="p">=</span> <span class="p">{</span> <span class="nc">Name</span> <span class="p">=</span> <span class="s2">"Paul"</span><span class="p">;</span> <span class="nc">Age</span> <span class="p">=</span> <span class="mi">28</span> <span class="p">}</span>&#x000A;&#x000A;<span class="c1">// 'Copy and update' record expression</span>&#x000A;<span class="k">let</span> <span class="n">paulsTwin</span> <span class="p">=</span> <span class="p">{</span> <span class="n">paul</span> <span class="k">with</span> <span class="nc">Name</span> <span class="p">=</span> <span class="s2">"Jim"</span> <span class="p">}</span></pre>
<p>Records can be augmented with properties and methods:</p>
<pre class="highlight fsharp"><span class="k">type</span> <span class="nc">Person</span> <span class="k">with</span>&#x000A;  <span class="k">member</span> <span class="n">x</span><span class="p">.</span><span class="nc">Info</span> <span class="p">=</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="nc">Name</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="nc">Age</span><span class="p">)</span></pre>
<p>Records are essentially sealed classes with extra topping: default immutability, structural equality, and pattern matching support.</p>
<pre class="highlight fsharp"><span class="k">let</span> <span class="n">isPaul</span> <span class="n">person</span> <span class="p">=</span>&#x000A;<span class="k">match</span> <span class="n">person</span> <span class="k">with</span>&#x000A;<span class="p">|</span> <span class="p">{</span> <span class="nc">Name</span> <span class="p">=</span> <span class="s2">"Paul"</span> <span class="p">}</span> <span class="p">-&gt;</span> <span class="bp">true</span>&#x000A;<span class="p">|</span> <span class="p">_</span> <span class="p">-&gt;</span> <span class="bp">false</span></pre></div>
</td>
</tr>
<tr id='//dash_ref_Basics/Entry/Discriminated Unions/0'>
<td class='description' colspan='2'>
<div class='name'><p>Discriminated Unions</p>
</div>
<div class='notes'><p><em>Discriminated unions</em> (DU) provide support for values that can be one of a number of named cases, each possibly with different values and types.</p>
<pre class="highlight fsharp"><span class="k">type</span> <span class="nc">Tree</span><span class="p">&lt;</span><span class="k">'</span><span class="nc">T</span><span class="p">&gt;</span> <span class="p">=</span>&#x000A;<span class="p">|</span> <span class="nc">Node</span> <span class="k">of</span> <span class="nc">Tree</span><span class="p">&lt;</span><span class="k">'</span><span class="nc">T</span><span class="p">&gt;</span> <span class="p">*</span> <span class="k">'</span><span class="nc">T</span> <span class="p">*</span> <span class="nc">Tree</span><span class="p">&lt;</span><span class="k">'</span><span class="nc">T</span><span class="p">&gt;</span>&#x000A;<span class="p">|</span> <span class="nc">Leaf</span>&#x000A;&#x000A;<span class="k">let</span> <span class="k">rec</span> <span class="n">depth</span> <span class="p">=</span> <span class="k">function</span>&#x000A;<span class="p">|</span> <span class="nc">Node</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="o">_,</span> <span class="n">r</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">max</span> <span class="p">(</span><span class="n">depth</span> <span class="n">l</span><span class="p">)</span> <span class="p">(</span><span class="n">depth</span> <span class="n">r</span><span class="p">)</span>&#x000A;<span class="p">|</span> <span class="nc">Leaf</span> <span class="p">-&gt;</span> <span class="mi">0</span></pre>
<p>They allow to wrap a type using Single case union types (<a href="https://fsharpforfunandprofit.com/posts/designing-with-types-single-case-dus/">Designing with types: Single case union types</a>:</p>
<pre class="highlight fsharp"><span class="k">type</span> <span class="nc">CustomerId</span> <span class="p">=</span> <span class="nc">CustomerId</span> <span class="k">of</span> <span class="kt">int</span>&#x000A;<span class="k">let</span> <span class="n">custId</span> <span class="p">=</span> <span class="nc">CustomerId</span> <span class="mi">1</span>&#x000A;<span class="c1">// deconstruct in the param</span>&#x000A;<span class="k">let</span> <span class="n">printCustomerId</span> <span class="p">(</span><span class="nc">CustomerId</span> <span class="n">customerIdInt</span><span class="p">)</span> <span class="p">=</span>&#x000A;  <span class="n">printfn</span> <span class="s2">"The CustomerId is %i"</span> <span class="n">customerIdInt</span>&#x000A;<span class="c1">// or deconstruct explicitly through let statement</span>&#x000A;<span class="k">let</span> <span class="n">printCustomerId2</span> <span class="n">custId</span> <span class="p">=</span>&#x000A;  <span class="k">let</span> <span class="p">(</span><span class="nc">CustomerId</span> <span class="n">customerIdInt</span><span class="p">)</span> <span class="p">=</span> <span class="n">custId</span> <span class="c1">// deconstruct here</span>&#x000A;  <span class="n">printfn</span> <span class="s2">"The CustomerId is %i"</span> <span class="n">customerIdInt</span></pre>
<p>F# Core has a few built-in discriminated unions for error handling, e.g., <a href="http://msdn.microsoft.com/en-us/library/dd233245.aspx">Option</a> and <a href="http://msdn.microsoft.com/en-us/library/ee353439.aspx">Choice</a>.</p>
<pre class="highlight fsharp"><span class="k">let</span> <span class="n">optionPatternMatch</span> <span class="n">input</span> <span class="p">=</span>&#x000A;   <span class="k">match</span> <span class="n">input</span> <span class="k">with</span>&#x000A;    <span class="p">|</span> <span class="nc">Some</span> <span class="n">i</span> <span class="p">-&gt;</span> <span class="n">printfn</span> <span class="s2">"input is an int=%d"</span> <span class="n">i</span>&#x000A;    <span class="p">|</span> <span class="nc">None</span> <span class="p">-&gt;</span> <span class="n">printfn</span> <span class="s2">"input is missing"</span></pre>
<p>Single-case discriminated unions are often used to create type-safe abstractions with pattern matching support:</p>
<pre class="highlight fsharp"><span class="k">type</span> <span class="nc">OrderId</span> <span class="p">=</span> <span class="nc">Order</span> <span class="k">of</span> <span class="kt">string</span>&#x000A;&#x000A;<span class="c1">// Create a DU value</span>&#x000A;<span class="k">let</span> <span class="n">orderId</span> <span class="p">=</span> <span class="nc">Order</span> <span class="s2">"12"</span>&#x000A;&#x000A;<span class="c1">// Use pattern matching to deconstruct single-case DU</span>&#x000A;<span class="k">let</span> <span class="p">(</span><span class="nc">Order</span> <span class="n">id</span><span class="p">)</span> <span class="p">=</span> <span class="n">orderId</span></pre></div>
</td>