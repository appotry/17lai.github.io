<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.17lai.site</id>
    <title>夜法之书 • Posts by &#34;devops&#34; category</title>
    <link href="https://blog.17lai.site" />
    <updated>2022-10-02T11:16:04.000Z</updated>
    <category term="hexo" />
    <category term="blog" />
    <category term="vercel" />
    <category term="web" />
    <category term="http" />
    <category term="github" />
    <category term="jekyll" />
    <category term="gitlab" />
    <category term="git" />
    <category term="crack" />
    <category term="linux" />
    <category term="hardlink" />
    <category term="bt" />
    <category term="pt" />
    <category term="markdown" />
    <category term="picgo" />
    <category term="wiz" />
    <category term="joplin" />
    <category term="typora" />
    <category term="qnap" />
    <category term="硬盘" />
    <category term="nas" />
    <category term="embeded" />
    <category term="3G" />
    <category term="4G" />
    <category term="3531a" />
    <category term="移植" />
    <category term="嵌入式" />
    <category term="hisilicon" />
    <category term="driver" />
    <category term="3798m" />
    <category term="mpp" />
    <category term="unf" />
    <category term="kernel" />
    <category term="宝塔" />
    <category term="vps" />
    <category term="建站" />
    <category term="nginx" />
    <category term="apache" />
    <category term="mysql" />
    <category term="docker" />
    <category term="lamp" />
    <category term="php" />
    <category term="tomcat" />
    <category term="registry" />
    <category term="教程" />
    <category term="email" />
    <category term="https" />
    <category term="ssl" />
    <category term="debian" />
    <category term="laptop" />
    <category term="ed2k" />
    <category term="ati" />
    <category term="ssd" />
    <category term="hdd" />
    <category term="pdca" />
    <category term="5w2h" />
    <category term="smart" />
    <category term="swot" />
    <category term="grow" />
    <category term="okr" />
    <category term="wbs" />
    <category term="qbittorrent" />
    <category term="transmission" />
    <category term="emby" />
    <category term="sonarr" />
    <category term="jeckett" />
    <category term="portainer" />
    <category term="启动" />
    <category term="优化" />
    <category term="tls" />
    <category term="隐私" />
    <category term="安全" />
    <category term="gitbook" />
    <category term="mariadb" />
    <category term="note" />
    <category term="mermaid" />
    <category term="webdav" />
    <category term="matery" />
    <category term="npm" />
    <category term="css" />
    <category term="js" />
    <category term="3a" />
    <category term="ae" />
    <category term="image" />
    <category term="ai" />
    <category term="face" />
    <category term="ccs" />
    <category term="vim" />
    <category term="ide" />
    <category term="music" />
    <category term="韩红" />
    <category term="thinkpad" />
    <category term="sound" />
    <category term="speaker" />
    <category term="刮削" />
    <category term="musicbrainz" />
    <category term="mp3tag" />
    <category term="tmm" />
    <category term="字幕" />
    <category term="plex" />
    <category term="cmake" />
    <category term="develop" />
    <category term="ipv6" />
    <category term="traefik" />
    <category term="proxy" />
    <category term="swarm" />
    <category term="ubuntu" />
    <category term="vscode" />
    <category term="插件" />
    <category term="编码" />
    <category term="plantuml" />
    <category term="mathjax" />
    <category term="ci/cd" />
    <category term="earthly" />
    <category term="mstream" />
    <category term="selfhost" />
    <category term="中岛美嘉" />
    <category term="node" />
    <category term="jenkins" />
    <category term="shell" />
    <category term="tools" />
    <category term="winrar" />
    <category term="emoji" />
    <category term="isp" />
    <category term="awb" />
    <category term="mywork" />
    <category term="cdn" />
    <category term="seo" />
    <category term="fitness" />
    <category term="健身" />
    <category term="运动" />
    <category term="devops" />
    <category term="k8s" />
    <category term="harbor" />
    <category term="drowio" />
    <category term="man" />
    <category term="calibre" />
    <category term="douban" />
    <category term="book" />
    <category term="框架" />
    <category term="图解" />
    <category term="doxygen" />
    <category term="bash" />
    <category term="中医" />
    <category term="西医" />
    <category term="社会观察" />
    <category term="管理" />
    <category term="竞品分析" />
    <category term="rss" />
    <category term="rsshub" />
    <category term="知识" />
    <category term="智慧" />
    <category term="编译器" />
    <category term="C" />
    <category term="compiler" />
    <category term="自制" />
    <category term="驱动" />
    <category term="sensor" />
    <category term="故事" />
    <category term="nodeppt" />
    <category term="echarts" />
    <category term="写作" />
    <category term="potplayer" />
    <category term="action" />
    <category term="workflow" />
    <category term="概率" />
    <category term="普朗克" />
    <category term="投资" />
    <category term="理财" />
    <category term="金融" />
    <category term="pmbok" />
    <category term="ipd" />
    <category term="绩效" />
    <category term="os" />
    <entry>
        <id>https://blog.17lai.site/posts/78c3371/</id>
        <title>那些有用的Github工具介绍！Action、app、workflow等</title>
        <link rel="alternate" href="https://blog.17lai.site/posts/78c3371/"/>
        <content type="html">&lt;blockquote&gt;
&lt;p&gt;Github Actoins 是 GitHub 推出的持续集成 (Con­tin­u­ous in­te­gra­tion，简称 CI) 服务，它提供了配置非常不错的虚拟服务器环境，基于它可以进行构建、测试、打包、部署项目。是CICD的强力工具！&lt;/p&gt;
&lt;p&gt;本文介绍几个常用的极为有用的Action工具！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/10/02/20221002200706.webp&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;GitHub-Actions-是什么？&#34;&gt;GitHub Actions 是什么？&lt;/h2&gt;
&lt;p&gt;大家知道，持续集成由很多操作组成，比如抓取代码、运行测试、登录远程服务器，发布到第三方服务等等。GitHub 把这些操作就称为 actions。&lt;/p&gt;
&lt;p&gt;很多操作在不同项目里面是类似的，完全可以共享。GitHub 注意到了这一点，想出了一个很妙的点子，允许开发者把每个操作写成独立的脚本文件，存放到代码仓库，使得其他开发者可以引用。&lt;/p&gt;
&lt;p&gt;如果你需要某个 action，不必自己写复杂的脚本，直接引用他人写好的 action 即可，整个持续集成过程，就变成了一个 actions 的组合。这就是 GitHub Actions 最特别的地方。&lt;/p&gt;
&lt;p&gt;GitHub 做了一个&lt;a href=&#34;https://github.com/marketplace?type=actions&#34;&gt;官方市场&lt;/a&gt;，可以搜索到他人提交的 actions。另外，还有一个 &lt;a href=&#34;https://github.com/sdras/awesome-actions&#34;&gt;awesome actions&lt;/a&gt; 的仓库，也可以找到不少 action。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/10/02/20221002200706-1.webp&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;上面说了，每个 action 就是一个独立脚本，因此可以做成代码仓库，使用&lt;code&gt;userName/repoName&lt;/code&gt;的语法引用 action。比如，&lt;code&gt;actions/setup-node&lt;/code&gt;就表示&lt;code&gt;github.com/actions/setup-node&lt;/code&gt;这个&lt;a href=&#34;https://github.com/actions/setup-node&#34;&gt;仓库&lt;/a&gt;，它代表一个 action，作用是安装 Node.js。事实上，GitHub 官方的 actions 都放在 &lt;a href=&#34;https://github.com/actions&#34;&gt;github.com/actions&lt;/a&gt; 里面。&lt;/p&gt;
&lt;p&gt;更多 Github action 介绍&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/sdras/awesome-actions&#34;&gt;awesome-actions&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;Github-Action-使用限制：&#34;&gt;Github Action 使用限制：&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.github.com/cn/actions/learn-github-actions/usage-limits-billing-and-administration&#34;&gt;官方文档：使用限制、计费和管理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;在复刻公共仓库时，默认情况下将禁用计划的工作流程。&lt;/li&gt;
&lt;li&gt;在公共仓库中，当 60 天内未发生仓库活动时，将自动禁用计划的工作流程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;每个仓库只能同时支持20个 workflow 并行。&lt;/li&gt;
&lt;li&gt;每小时可以调用1000次 GitHub API 。&lt;/li&gt;
&lt;li&gt;每个 job 最多可以执行6个小时。&lt;/li&gt;
&lt;li&gt;免费版的用户最大支持20个 job 并发执行，macOS 最大只支持5个。&lt;/li&gt;
&lt;li&gt;私有仓库每月累计使用时间为2000分钟，超过后$ 0.008/分钟，公共仓库则无限制。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Github-仓库与上游自动同步&#34;&gt;Github 仓库与上游自动同步&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;保持自己github的forks自动和上游仓库同步的&lt;/p&gt;
&lt;p&gt;信息来源于 &lt;a href=&#34;https://github.com/wei/pull&#34;&gt;https://github.com/wei/pull&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;只同步默认分支的教程&#34;&gt;只同步默认分支的教程&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;当上游的仓库仅有一个默认分支。或者上游仓库有两个分支，我们仅需要同步他的默认分支，其他分支对内容对我们来说无关紧要。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/10/02/20221002200706-2.webp&#34; alt=&#34;git1.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;a)  登录自己的github账号，另开网页打开 &lt;a href=&#34;https://github.com/wei/pull&#34;&gt;https://github.com/wei/pull&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;b)  点击Pull app进行安装。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/10/02/20221002200706-3.webp&#34; alt=&#34;git2.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;c)  安装过程中会让你选择要选择那一种方式，All repositories(就是同步已经frok的仓库以及未来fork的仓库)，Only select repositories(仅选择要自己需要同步的仓库，其他fork的仓库不会被同步)，根据自己需求选择，实在不知道怎么选择，就选All repositories；点击install，完成安装。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/10/02/20221002200706-4.webp&#34; alt=&#34;git3.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;d)  后续，如果要调整1.c中的选项，打开 &lt;a href=&#34;https://github.com/apps/pull&#34;&gt;https://github.com/apps/pull&lt;/a&gt; ，点击Configure，输入github密码进入pull的相关设置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/10/02/20221002200706-5.webp&#34; alt=&#34;git4.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;e)  进入后，找到Repository access，根据自己的需求，重新选择：All repositories(就是同步已经frok的仓库以及未来fork的仓库)，Only select repositories(仅选择要自己需要同步的仓库，其他fork的仓库不会被同步)，Save后保存生效。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/10/02/20221002200706-6.webp&#34; alt=&#34;git5.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;f)  Pull app作者虽然在项目中写道keeps your forks up-to-date with upstream via automated pull requests，但当上游仓库有更改时，自己的仓库会在3个小时内完成与上游的同步，3个小时是Pull app作者说的最长时间。当然也可以通过手动触发同步上游仓库，手动触发方式：&lt;code&gt;https://pull.git.ci/process/你的GitHub名字/你的仓库名字&lt;/code&gt; （例如：&lt;code&gt;https://pull.git.ci/process/xxxxx/test&lt;/code&gt; ），手动触发可能会进行人机验证，验证通过后会显示Success。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/10/02/20221002200706-7.webp&#34; alt=&#34;git12.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/10/02/20221002200706-8.webp&#34; alt=&#34;git13.jpg&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;同步其他分支的教程&#34;&gt;同步其他分支的教程&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/10/02/20221002200706-9.webp&#34; alt=&#34;git8.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;a)  假设你fork了上游仓库后，你fork后的地址为 &lt;code&gt;https://github.com/你的仓库名字/test&lt;/code&gt; ，首先设置完成第1部分内容，注意在1.c步骤没有设置全部同步的，要回到1.e步，确认是否设置同步了 &lt;code&gt;你的仓库名字/test&lt;/code&gt;，如果没有,请添加上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/10/02/20221002200706-10.webp&#34; alt=&#34;git9.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;b)  在默认分支下添加一个文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/10/02/20221002200706-11.webp&#34; alt=&#34;git10.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;c)  复制 &lt;code&gt;.github/pull.yml&lt;/code&gt; 粘贴后看到以下页面，注意github前面的那个.别漏掉了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/10/02/20221002200706-12.webp&#34; alt=&#34;git11.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;d)  请在https://github.com/wei/pull#advanced-setup-with-config 页复制代码，&lt;/p&gt;
&lt;p&gt;注意：upstream处要修改为上游仓库作者名字。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/10/02/20221002200706-13.webp&#34; alt=&#34;git12.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/10/02/20221002200706-14.webp&#34; alt=&#34;git13.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;e)  最终的示例如下，假设上游作者是zhangsan，所有的注意点都用红线圈出来了，保存后生效。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/10/02/20221002200706-15.webp&#34; alt=&#34;git14.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;f)  Pull app作者虽然在项目中写道keeps your forks up-to-date with upstream via automated pull requests，但当上游仓库有更改时，自己的仓库会在3个小时内完成与上游的同步，3个小时是Pull app作者说的最长时间。当然也可以通过手动触发同步上游仓库，手动触发方式：&lt;code&gt;https://pull.git.ci/process/你的GitHub名字/你的仓库名字&lt;/code&gt; （例如：&lt;code&gt;https://pull.git.ci/process/xxxxx/test&lt;/code&gt;），手动触发可能会进行人机验证，验证通过后会显示Success。具体见1.f提供的图片。&lt;/p&gt;
&lt;p&gt;g)  本人仅测试过forks一个仓库只有2个分支的项目，如果有多个分支，不能保证是否可行，请自行测试，或者是使用本教程第3部分高级玩法。&lt;/p&gt;
&lt;h3 id=&#34;高级玩法&#34;&gt;高级玩法&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;当然，作者还有其他更好的项目用于同步所有分支，例如使用 GitHub actions 进行同步。请参考原作者的项目&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/wei/git-sync&#34;&gt;https://github.com/wei/git-sync&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/repo-sync/github-sync&#34;&gt;https://github.com/repo-sync/github-sync&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Github-自动合并-PR&#34;&gt;Github 自动合并 PR&lt;/h2&gt;
&lt;h3 id=&#34;renovate&#34;&gt;renovate&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/marketplace/renovate&#34;&gt;renovate&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.renovatebot.com/&#34;&gt;使用文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.renovatebot.com/configuration-options/#automerge&#34;&gt;自动合并&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/10/02/20221002200706-16.webp&#34; alt=&#34;renovate free&#34;&gt;&lt;/p&gt;
&lt;p&gt;自动合并example  renovate.json&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-json&#34; data-language=&#34;json&#34;&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &#34;extends&#34;: [&#34;config:base&#34;],
  &#34;assignees&#34;: [&#34;17lai&#34;],
  &#34;separateMinorPatch&#34;: true,
  &#34;packageRules&#34;: [
    {
      &#34;updateTypes&#34;: [&#34;minor&#34;, &#34;patch&#34;],
      &#34;automerge&#34;: true,
      &#34;automergeType&#34;: &#34;branch&#34;
    }
  ]
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;mergify&#34;&gt;mergify&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/marketplace/mergify&#34;&gt;mergify&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;开源项目这个工具是免费使用的！&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/10/02/20221002200706-17.webp&#34; alt=&#34;mergify free for open source&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;使用-Github-Dependabot-自动更新依赖版本&#34;&gt;使用 Github Dependabot 自动更新依赖版本&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;通过将配置文件检入仓库，可启用 Dependabot 版本更新。 配置文件指定存储在仓库中的清单或其他包定义文件的位置。 Dependabot 使用此信息来检查过时的软件包和应用程序。 Dependabot 确定依赖项是否有新版本，它通过查看依赖的语义版本 (semver) 来决定是否应更新该版本。 对于某些软件包管理器，Dependabot 版本更新 也支持供应。 供应（或缓存）的依赖项是检入仓库中特定目录的依赖项，而不是在清单中引用的依赖项。 即使包服务器不可用，供应的依赖项在生成时也可用。 Dependabot 版本更新可以配置为检查为新版本供应的依赖项，并在必要时更新它们。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上内容来自 GitHub 官方文档，简单的讲 Dependabot 就是一个没有感情的依赖更新机器人，在您的项目所依赖的上游软件包或应用程序发布新版本后，它会在您的 GitHub 仓库自动创建一个 PR 来更新依赖文件，并说明依赖更新内容，用户自己选择是否 merge 该 PR，效果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/10/02/20221002200706-18.webp&#34; alt=&#34;Dependabot PR&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;开启-Dependabot&#34;&gt;开启 Dependabot&lt;/h3&gt;
&lt;p&gt;开启方式比较简单，仅需将 &lt;code&gt;dependabot.yml&lt;/code&gt; 配置文件放入仓库的 &lt;code&gt;.github&lt;/code&gt; 目录中即可开启。之后 Dependabot 就会自动提交 PR 来更新您项目中的依赖项了。您也可以在 GitHub 页面上进行操作，在仓库页面通过 &lt;code&gt;Insights&lt;/code&gt; -&amp;gt; &lt;code&gt;Dependency graph&lt;/code&gt; -&amp;gt; &lt;code&gt;Dependabot&lt;/code&gt; -&amp;gt; &lt;code&gt;Enable Dependabot&lt;/code&gt; 路径即可开启，之后就可以点击 &lt;code&gt;Create config file&lt;/code&gt; 来创建配置文件了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/10/02/20221002200706-19.webp&#34; alt=&#34;开启 Dependabot&#34;&gt;&lt;/p&gt;
&lt;p&gt;配置完成后，即可看到需要监控的依赖文件和上次检查更新的时间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/10/02/20221002200706-20.webp&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;配置-dependabot-yml&#34;&gt;配置 dependabot.yml&lt;/h3&gt;
&lt;p&gt;文件的配置也相对较为简单的直接，&lt;code&gt;version&lt;/code&gt;、&lt;code&gt;updates&lt;/code&gt;、&lt;code&gt;package-ecosystem&lt;/code&gt; 、&lt;code&gt;schedule&lt;/code&gt; 是必填的，还可以配置 &lt;code&gt;registries&lt;/code&gt; 来指定私有仓库地址及认证信息。下面这个是官方示例，该示例中为 &lt;code&gt;npm&lt;/code&gt; 和 &lt;code&gt;Docker&lt;/code&gt; 配置了依赖自动更新，同时指定其依赖文件的地址和更新频率。有意思的是，在下面这个示例中，如果 Docker 依赖项已过时很久，可能会先执行 &lt;code&gt;daily&lt;/code&gt; 安排，直到这些依赖项达到最新状态，然后降回每周安排。更多内容，可以参考&lt;a href=&#34;https://docs.github.com/en/code-security/supply-chain-security/keeping-your-dependencies-updated-automatically/configuration-options-for-dependency-updates&#34;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-yaml&#34; data-language=&#34;yaml&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;# Basic dependabot.yml file with
# minimum configuration for two package managers

version: 2
updates:
  # Enable version updates for npm
  - package-ecosystem: &#34;npm&#34;
    # Look for `package.json` and `lock` files in the `root` directory
    directory: &#34;/&#34;
    # Check the npm registry for updates every day (weekdays)
    schedule:
      interval: &#34;daily&#34;

  # Enable version updates for Docker
  - package-ecosystem: &#34;docker&#34;
    # Look for a `Dockerfile` in the `root` directory
    directory: &#34;/&#34;
    # Check for updates once a week
    schedule:
      interval: &#34;weekly&#34;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;支持的包管理器&#34;&gt;支持的包管理器&lt;/h3&gt;
&lt;p&gt;目前 Dependabot 支持很多包管理器，具体内容可以参考下表：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要用于 &lt;code&gt;dependabot.yml&lt;/code&gt; 文件中的 YAML 值&lt;/li&gt;
&lt;li&gt;支持的包管理器版本&lt;/li&gt;
&lt;li&gt;是否支持私有 GitHub 仓库或注册表中的依赖项&lt;/li&gt;
&lt;li&gt;是否支持供应的依赖项&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Package manager&lt;/th&gt;
&lt;th&gt;YAML value&lt;/th&gt;
&lt;th&gt;Supported versions&lt;/th&gt;
&lt;th&gt;Private repositories&lt;/th&gt;
&lt;th&gt;Private registries&lt;/th&gt;
&lt;th&gt;Vendoring&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Bundler&lt;/td&gt;
&lt;td&gt;&lt;code&gt;bundler&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;v1, v2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;✓&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;✓&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Cargo&lt;/td&gt;
&lt;td&gt;&lt;code&gt;cargo&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;v1&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;✓&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;✓&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Composer&lt;/td&gt;
&lt;td&gt;&lt;code&gt;composer&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;v1, v2&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;✓&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;✓&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Docker&lt;/td&gt;
&lt;td&gt;&lt;code&gt;docker&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;v1&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;✓&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;✓&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Hex&lt;/td&gt;
&lt;td&gt;&lt;code&gt;mix&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;v1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;✓&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;elm-package&lt;/td&gt;
&lt;td&gt;&lt;code&gt;elm&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;v0.19&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;✓&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;✓&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;git submodule&lt;/td&gt;
&lt;td&gt;&lt;code&gt;gitsubmodule&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;N/A (no version)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;✓&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;✓&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GitHub Actions&lt;/td&gt;
&lt;td&gt;&lt;code&gt;github-actions&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;N/A (no version)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;✓&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;✓&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Go modules&lt;/td&gt;
&lt;td&gt;&lt;code&gt;gomod&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;v1&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;✓&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;✓&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;✓&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Gradle&lt;/td&gt;
&lt;td&gt;&lt;code&gt;gradle&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;N/A (no version)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;✓&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;✓&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Maven&lt;/td&gt;
&lt;td&gt;&lt;code&gt;maven&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;N/A (no version)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;✓&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;✓&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;npm&lt;/td&gt;
&lt;td&gt;&lt;code&gt;npm&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;v6, v7&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;✓&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;✓&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NuGet&lt;/td&gt;
&lt;td&gt;&lt;code&gt;nuget&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&amp;lt;= 4.8&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;✓&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;✓&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pip&lt;/td&gt;
&lt;td&gt;&lt;code&gt;pip&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;v21.1.2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;✓&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pipenv&lt;/td&gt;
&lt;td&gt;&lt;code&gt;pip&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&amp;lt;= 2021-05-29&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;✓&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pip-compile&lt;/td&gt;
&lt;td&gt;&lt;code&gt;pip&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;6.1.0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;✓&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;poetry&lt;/td&gt;
&lt;td&gt;&lt;code&gt;pip&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;v1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;✓&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Terraform&lt;/td&gt;
&lt;td&gt;&lt;code&gt;terraform&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&amp;gt;= 0.13, &amp;lt;= 1.0&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;✓&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;✓&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;yarn&lt;/td&gt;
&lt;td&gt;&lt;code&gt;npm&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;v1&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;✓&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;✓&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;更多内容可以参考&lt;a href=&#34;https://docs.github.com/en/code-security/supply-chain-security/keeping-your-dependencies-updated-automatically/about-dependabot-version-updates#supported-repositories-and-ecosystems&#34;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;Gitlab-镜像-Github&#34;&gt;Gitlab 镜像 Github&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;这个功能需要 gitlab ee 版本，CE版本是不支持镜像的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;个人用户可以参考 &lt;a href=&#34;/posts/29a820b3/&#34;&gt;破解Gitlab EE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;企业用户去付费买授权&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/10/02/20221002200706-21.webp&#34; alt=&#34;Gitlab Mirror&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;Github-仓库备份&#34;&gt;Github 仓库备份&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;最优秀的资源，大多只在短时间内出现！&lt;/p&gt;
&lt;p&gt;平时多备份你重要的仓库，以及你使用的仓库的重要上下游仓库！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/appotry/docker-github-backup&#34;&gt;github-backup Githb&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hub.docker.com/r/lnxd/github-backup&#34;&gt;github-backup Dockerhub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-yaml&#34; data-language=&#34;yaml&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;githubback:
  image: lnxd/github-backup
  container_name: &#34;githubback&#34;
  hostname: githubback
  # ports:
    # - &#34;80:80&#34;
  volumes:
    - &#34;${USERDIR}/githubback/data:/home/docker/backups:rw&#34;
  env_file:
    - .env
  environment:
    - HTTP_PROXY=http://[ip]:[port]
    - HTTPS_PROXY=http://[ip]:[port]
  restart: always&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h2 id=&#34;后记&#34;&gt;后记&lt;/h2&gt;
&lt;p&gt;github action 太多强大，这里仅仅只能介绍一点点，有太多好东西了，太多宝藏值得去挖掘！&lt;/p&gt;
&lt;p&gt;这就是开源的力量！在被大公司白嫖的同时，创造了无与伦比的社区生态！&lt;/p&gt;
&lt;h2 id=&#34;参考-致谢&#34;&gt;参考&amp;amp;致谢&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html&#34;&gt;GitHub Actions 入门教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://guoxudong.io/post/github-dependabot/&#34;&gt;使用 Github Dependabot 自动更新依赖版本&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://p3terx.com/archives/github-actions-started-tutorial.html&#34;&gt;GitHub Actions 入门教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;i-class-fa-solid-fa-school-i-系列教程&#34;&gt;&lt;i class=&#34;fa-solid fa-school&#34;&gt;&lt;/i&gt;&lt;strong&gt;系列教程&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;/atom.xml&#34;&gt;&lt;i class=&#34;fa-solid fa-square-rss&#34;&gt;&lt;/i&gt;全部文章RSS订阅&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;i-class-fa-brands-fa-dev-i-Devops系列&#34;&gt;&lt;i class=&#34;fa-brands fa-dev&#34;&gt;&lt;/i&gt;&lt;strong&gt;Devops系列&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;/categories/devops/atom.xml&#34;&gt;&lt;i class=&#34;fa-solid fa-square-rss&#34;&gt;&lt;/i&gt;&lt;strong&gt;Devops 分类 RSS 订阅&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;/posts/ab63eb8f/&#34;&gt;自建全套开源Devops开发系统&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/d32a07a7/&#34;&gt;Git介绍以及分支模型图解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/39563241/&#34;&gt;三万字无坑搭建基于Docker+K8S+GitLab/SVN+Jenkins+Harbor持续集成交付环境&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/3437994a/&#34;&gt;DevOps系列—【Jenkinsfile+Dockerfile+nginx+vue】&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/f4c3ad41/&#34;&gt;项目开发管理工具推荐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/acc13b70/&#34;&gt;Gitlab的安装及使用教程完全版&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/d08eb7b/&#34;&gt;Gitlab的安装及使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/78c3371/&#34;&gt;那些有用的Github工具介绍！Action、app、workflow等&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;i-class-fa-solid-fa-book-i-Gitbook使用系列&#34;&gt;&lt;i class=&#34;fa-solid fa-book&#34;&gt;&lt;/i&gt;&lt;strong&gt;Gitbook使用系列&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;/categories/gitbook/atom.xml&#34;&gt;&lt;i class=&#34;fa-solid fa-square-rss&#34;&gt;&lt;/i&gt;Gitbook分类RSS订阅&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;/posts/7fe86002/&#34;&gt;GitBook+GitLab撰写发布技术文档-Part1:GitBook篇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/7790e989/&#34;&gt;GitBook+GitLab撰写发布技术文档-Part2:GitLab篇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/d6bad1e5/&#34;&gt;自己动手制作电子书的最佳方式（支持PDF、ePub、mobi等格式）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;i-class-fa-brands-fa-square-gitlab-i-Gitlab-使用系列&#34;&gt;&lt;i class=&#34;fa-brands fa-square-gitlab&#34;&gt;&lt;/i&gt;&lt;strong&gt;Gitlab 使用系列&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;/categories/gitlab/atom.xml&#34;&gt;&lt;i class=&#34;fa-solid fa-square-rss&#34;&gt;&lt;/i&gt;&lt;strong&gt;Gitlab RSS 分类订阅&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;/posts/acc13b70/&#34;&gt;&lt;strong&gt;Gitlab的安装及使用教程完全版&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/29a820b3/&#34;&gt;破解Gitlab EE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/d08eb7b/&#34;&gt;Gitlab的安装及使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/1879721e/&#34;&gt;CI/CD与Git Flow与GitLab&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="github" />
        <category term="action" />
        <category term="workflow" />
        <updated>2022-10-02T11:16:04.000Z</updated>
    </entry>
    <entry>
        <id>https://blog.17lai.site/posts/ab63eb8f/</id>
        <title>自建全套开源Devops开发系统</title>
        <link rel="alternate" href="https://blog.17lai.site/posts/ab63eb8f/"/>
        <content type="html">&lt;blockquote&gt;
&lt;p&gt;国内的Devops云平台动辄封号，删库，屏蔽，还多次发生数据泄密，项目被云平台克隆事件，国内云平台devops已死！数据安全没法保证，自建私有Devops平台才靠谱。这里采用开源项目建立一个完善的低成本Devops系统，基本运行良好！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;目标：单节点，以最低成本，最低消耗，使用开源软件实现一个可用的DevOps！满足中小企业的研发、测试、运维需求。并对后续如何扩展本套DevOps系统做了项目，成本，路线升级规划，可以一直扩展到业界最前沿最大系统。&lt;/p&gt;
&lt;p&gt;整套系统已经跑起来很长时间了！单节点Nas服务器，32G内存，共运行了约80个Docker，优化到平均负载10以下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/05/14/20220514113906.webp&#34; alt=&#34;devops&#34;&gt;&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;h2 id=&#34;Devops框架图解&#34;&gt;Devops框架图解&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;下面系统大多可以做负载平衡，多节点备份，可以扩展为一个高可用，大中央平台。&lt;/p&gt;
&lt;p&gt;珍爱生命，使用&lt;code&gt;Docker&lt;/code&gt;！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/05/09/20220509132230.webp&#34; alt=&#34;自建Devops.drawio&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;开源云平台生死连问&#34;&gt;开源云平台生死连问&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;珍爱生命，不建议使用国内云平台。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;什么是大教堂？&lt;/p&gt;
&lt;p&gt;什么是集市？&lt;/p&gt;
&lt;p&gt;什么是信任链？&lt;/p&gt;
&lt;p&gt;什么是开源生态？&lt;/p&gt;
&lt;p&gt;为什么要做开源生态？&lt;/p&gt;
&lt;p&gt;怎么做开源生态？&lt;/p&gt;
&lt;p&gt;开源生态的土壤肥力维护如何做？&lt;/p&gt;
&lt;p&gt;这些问题没想明白，没想到如何做的是没法做开源的。&lt;/p&gt;
&lt;p&gt;国内平台连种子嫩芽都要收割，到处收费，动辄删库，屏蔽，封号，注定做不了开源生态。&lt;/p&gt;
&lt;h2 id=&#34;Consul自动负载均衡&#34;&gt;&lt;code&gt;Consul&lt;/code&gt;自动负载均衡&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;基于服务自动发现和注册的负载均衡，负载均衡的方式没有变，只是多了一些&lt;strong&gt;外围组件&lt;/strong&gt;，当然这些组件对 &lt;code&gt;Client&lt;/code&gt; 是不可见的，&lt;code&gt;client&lt;/code&gt; 依然只能看到 &lt;code&gt;Nginx&lt;/code&gt; 入口，访问方式也没变化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/04/29/20220429190914-1.webp&#34; alt=&#34;Consul&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;Github仓库备份&#34;&gt;&lt;code&gt;Github&lt;/code&gt;仓库备份&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;最优秀的资源，大多只在短时间内出现！&lt;/p&gt;
&lt;p&gt;平时多备份你重要的仓库，以及你使用的仓库的重要上下游仓库！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/appotry/docker-github-backup&#34;&gt;github-backup Githb&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://hub.docker.com/r/lnxd/github-backup&#34;&gt;github-backup Dockerhub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-yaml&#34; data-language=&#34;yaml&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;githubback:
  image: lnxd/github-backup
  container_name: &#34;githubback&#34;
  hostname: githubback
  # ports:
    # - &#34;80:80&#34;
  volumes:
    - &#34;${USERDIR}/githubback/data:/home/docker/backups:rw&#34;
  env_file:
    - .env
  environment:
    - HTTP_PROXY=http://[ip]:[port]
    - HTTPS_PROXY=http://[ip]:[port]
  restart: always&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h2 id=&#34;配置要求&#34;&gt;配置要求&lt;/h2&gt;
&lt;p&gt;个人Nas配置&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;cpu j4125 4 核 14nm 2.00 GHz ~2.70 GHz&lt;/li&gt;
&lt;li&gt;SSD sata 接口的 读写 500MB/S&lt;/li&gt;
&lt;li&gt;32G DDR4. 2x16G 双通道&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;上图中介绍的系统都是上面配置的单服务器中可以运行的。&lt;/p&gt;
&lt;p&gt;如何以最低的配置，最少的内存运行起来最多的功能才是本文的追求，花费更多金钱去满足极少数情况的高压力是钱多的没处花。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;8G&lt;/code&gt;内存的nas 就可以运行 &lt;code&gt;gitea + drone&lt;/code&gt; ，&lt;code&gt;zentao&lt;/code&gt; 想用就用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gitlab&lt;/code&gt; 要跑起来至少要2核 &lt;code&gt;8G&lt;/code&gt; 内存，&lt;code&gt;jenkins&lt;/code&gt; 也是内存 &lt;code&gt;cpu&lt;/code&gt; 占用大户。大于 &lt;code&gt;16G&lt;/code&gt; 内存时考虑上这个&lt;/li&gt;
&lt;li&gt;4核 &lt;code&gt;32G&lt;/code&gt; 内存的nas，图片中介绍的可以全都跑起来！&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;可靠性&#34;&gt;可靠性&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ELK&lt;/code&gt;集群监控对于单服务器来说完全多余，&lt;code&gt;netdata&lt;/code&gt;监控也不错，&lt;code&gt;portainer&lt;/code&gt;就够用了，以后为了节约资源，&lt;code&gt;portainer&lt;/code&gt;说不定也会被干掉，大多数时候命令行监控就够了。少于200节点&lt;code&gt;K8S&lt;/code&gt;就是多余的。&lt;/p&gt;
&lt;h3 id=&#34;数据安全&#34;&gt;数据安全&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;云平台把数据交给别人，赌别人的道德不会私自偷拿你的数据？真是想多了。&lt;/p&gt;
&lt;p&gt;某垄断社交平台内部有专门的团队分析客户的数据，看有什么有价值的没有，是很多年前就爆出来的消息。&lt;/p&gt;
&lt;p&gt;自建&lt;code&gt;DevOps&lt;/code&gt;成本其实相当的低！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;整套系统可以从少到多，从小到大，慢慢优化，扩展的。硬件成本也是随着需求变化而变化的，随着业务扩展而增加成本，一开始单节点单服务器就可以满足要求了，后面业务增加慢慢扩展为集群，k8s 等。&lt;/p&gt;
&lt;p&gt;数据，代码是公司核心资产与竞争力的公司，上云赌别人的人品就是找死。你注册账户的时候，就同意了，无论别人随意删除你的数据，或者窃取你的数据都是不用付任何责任的，再说，整个系统数据都在别人手上，你要维权也没有证据。&lt;/p&gt;
&lt;h3 id=&#34;备份&#34;&gt;备份&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;UPS&lt;/code&gt;电源，防止意外断电&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rsync&lt;/code&gt; 备份，对于大多数人，已经够用了&lt;/li&gt;
&lt;li&gt;文件系统快照&lt;/li&gt;
&lt;li&gt;离线每日，或者每周冷备份&lt;/li&gt;
&lt;li&gt;大系统，多台服务器的时候可以用多节点集群备灾。&lt;code&gt;nginx&lt;/code&gt;,&lt;code&gt;harbor&lt;/code&gt;，&lt;code&gt;gitlab&lt;/code&gt;，&lt;code&gt;elasticsearch&lt;/code&gt;等都可以使用集群&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;扩展性&#34;&gt;扩展性&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;上面说的都可以单服务器搞定。多台服务器的时候可以用多节点集群备灾。&lt;code&gt;nginx&lt;/code&gt;,&lt;code&gt;harbor&lt;/code&gt;，&lt;code&gt;gitlab&lt;/code&gt;，&lt;code&gt;elasticsearch&lt;/code&gt;等都可以使用集群。&lt;/p&gt;
&lt;p&gt;多于200节点，大于3台服务器以后考虑上&lt;code&gt;K8S&lt;/code&gt;。ELK监控之类的这时候可以上了。&lt;a href=&#34;https://github.com/Tencent/bk-sops&#34;&gt;蓝鲸智云标准运维&lt;/a&gt;这时候也可以考虑了。&lt;/p&gt;
&lt;p&gt;再次扩大的时候可以考虑&lt;code&gt;Proxmox VE（PVE）&lt;/code&gt; + &lt;code&gt;ceph&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;更大的系统，或者对外提供云平台服务的时候可以考虑上&lt;code&gt;OpenStack&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;项目介绍&#34;&gt;项目介绍&lt;/h2&gt;
&lt;h3 id=&#34;ELK&#34;&gt;ELK&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;消耗资源很多，至少上百节点以上再考虑上这个&lt;/p&gt;
&lt;p&gt;&lt;code&gt;portainer&lt;/code&gt; -&amp;gt; &lt;code&gt;netdata &lt;/code&gt;-&amp;gt; &lt;code&gt;ELK&lt;/code&gt;，&lt;code&gt;zabbix &lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0520210805165405.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;cacti&#34;&gt;&lt;a href=&#34;https://www.cacti.net/&#34;&gt;cacti&lt;/a&gt;&lt;/h3&gt;
&lt;div style=&#34;text-align: center&#34;&gt;
  &lt;div class=&#34;github-card&#34; data-user=&#34;Cacti&#34; data-repo=&#34;&#34; data-height=&#34;200&#34; data-width=&#34;400&#34; data-theme=&#34;default&#34; data-target=&#34;&#34; data-client-id=&#34;&#34; data-client-secret=&#34;&#34;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;script src=&#34;/github-card-lib/githubcard.js&#34;&gt;&lt;/script&gt;

&lt;div style=&#34;text-align: center&#34;&gt;
  &lt;div class=&#34;github-card&#34; data-user=&#34;Cacti&#34; data-repo=&#34;cacti&#34; data-height=&#34;200&#34; data-width=&#34;400&#34; data-theme=&#34;default&#34; data-target=&#34;&#34; data-client-id=&#34;&#34; data-client-secret=&#34;&#34;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;script src=&#34;/github-card-lib/githubcard.js&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;zabbix&#34;&gt;zabbix&lt;/h3&gt;
&lt;div style=&#34;text-align: center&#34;&gt;
  &lt;div class=&#34;github-card&#34; data-user=&#34;zabbix&#34; data-repo=&#34;&#34; data-height=&#34;200&#34; data-width=&#34;400&#34; data-theme=&#34;default&#34; data-target=&#34;&#34; data-client-id=&#34;&#34; data-client-secret=&#34;&#34;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;script src=&#34;/github-card-lib/githubcard.js&#34;&gt;&lt;/script&gt;

&lt;div style=&#34;text-align: center&#34;&gt;
  &lt;div class=&#34;github-card&#34; data-user=&#34;zabbix&#34; data-repo=&#34;zabbix&#34; data-height=&#34;200&#34; data-width=&#34;400&#34; data-theme=&#34;default&#34; data-target=&#34;&#34; data-client-id=&#34;&#34; data-client-secret=&#34;&#34;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;script src=&#34;/github-card-lib/githubcard.js&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;ansible&#34;&gt;ansible&lt;/h3&gt;
&lt;div style=&#34;text-align: center&#34;&gt;
  &lt;div class=&#34;github-card&#34; data-user=&#34;ansible&#34; data-repo=&#34;&#34; data-height=&#34;200&#34; data-width=&#34;400&#34; data-theme=&#34;default&#34; data-target=&#34;&#34; data-client-id=&#34;&#34; data-client-secret=&#34;&#34;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;script src=&#34;/github-card-lib/githubcard.js&#34;&gt;&lt;/script&gt;

&lt;div style=&#34;text-align: center&#34;&gt;
  &lt;div class=&#34;github-card&#34; data-user=&#34;ansible&#34; data-repo=&#34;ansible&#34; data-height=&#34;200&#34; data-width=&#34;400&#34; data-theme=&#34;default&#34; data-target=&#34;&#34; data-client-id=&#34;&#34; data-client-secret=&#34;&#34;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;script src=&#34;/github-card-lib/githubcard.js&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;CMDB&#34;&gt;CMDB&lt;/h3&gt;
&lt;div style=&#34;text-align: center&#34;&gt;
  &lt;div class=&#34;github-card&#34; data-user=&#34;netbox-community&#34; data-repo=&#34;netbox&#34; data-height=&#34;200&#34; data-width=&#34;400&#34; data-theme=&#34;default&#34; data-target=&#34;&#34; data-client-id=&#34;&#34; data-client-secret=&#34;&#34;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;script src=&#34;/github-card-lib/githubcard.js&#34;&gt;&lt;/script&gt;

&lt;div style=&#34;text-align: center&#34;&gt;
  &lt;div class=&#34;github-card&#34; data-user=&#34;open-cmdb&#34; data-repo=&#34;cmdb&#34; data-height=&#34;200&#34; data-width=&#34;400&#34; data-theme=&#34;default&#34; data-target=&#34;&#34; data-client-id=&#34;&#34; data-client-secret=&#34;&#34;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;script src=&#34;/github-card-lib/githubcard.js&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;PVE&#34;&gt;PVE&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Proxmox VE（PVE）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div style=&#34;text-align: center&#34;&gt;
  &lt;div class=&#34;github-card&#34; data-user=&#34;proxmox&#34; data-repo=&#34;&#34; data-height=&#34;200&#34; data-width=&#34;400&#34; data-theme=&#34;default&#34; data-target=&#34;&#34; data-client-id=&#34;&#34; data-client-secret=&#34;&#34;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;script src=&#34;/github-card-lib/githubcard.js&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;CEPH&#34;&gt;&lt;a href=&#34;https://ceph.io/&#34;&gt;CEPH&lt;/a&gt;&lt;/h3&gt;
&lt;div style=&#34;text-align: center&#34;&gt;
  &lt;div class=&#34;github-card&#34; data-user=&#34;ceph&#34; data-repo=&#34;&#34; data-height=&#34;200&#34; data-width=&#34;400&#34; data-theme=&#34;default&#34; data-target=&#34;&#34; data-client-id=&#34;&#34; data-client-secret=&#34;&#34;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;script src=&#34;/github-card-lib/githubcard.js&#34;&gt;&lt;/script&gt;

&lt;div style=&#34;text-align: center&#34;&gt;
  &lt;div class=&#34;github-card&#34; data-user=&#34;ceph&#34; data-repo=&#34;ceph&#34; data-height=&#34;200&#34; data-width=&#34;400&#34; data-theme=&#34;default&#34; data-target=&#34;&#34; data-client-id=&#34;&#34; data-client-secret=&#34;&#34;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;script src=&#34;/github-card-lib/githubcard.js&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;OpenStack&#34;&gt;OpenStack&lt;/h3&gt;
&lt;div style=&#34;text-align: center&#34;&gt;
  &lt;div class=&#34;github-card&#34; data-user=&#34;openstack&#34; data-repo=&#34;&#34; data-height=&#34;200&#34; data-width=&#34;400&#34; data-theme=&#34;default&#34; data-target=&#34;&#34; data-client-id=&#34;&#34; data-client-secret=&#34;&#34;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;script src=&#34;/github-card-lib/githubcard.js&#34;&gt;&lt;/script&gt;

&lt;div style=&#34;text-align: center&#34;&gt;
  &lt;div class=&#34;github-card&#34; data-user=&#34;openstack&#34; data-repo=&#34;openstack&#34; data-height=&#34;200&#34; data-width=&#34;400&#34; data-theme=&#34;default&#34; data-target=&#34;&#34; data-client-id=&#34;&#34; data-client-secret=&#34;&#34;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;script src=&#34;/github-card-lib/githubcard.js&#34;&gt;&lt;/script&gt;

&lt;h2 id=&#34;其它项目&#34;&gt;其它项目&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;大家还有啥好项目建议？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;onedev&#34;&gt;onedev&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/theonedev/onedev&#34;&gt;onedev&lt;/a&gt; 是替代&lt;code&gt;Gitlab&lt;/code&gt;的极佳候补，看文档介绍，潜力无限！&lt;/p&gt;
&lt;div style=&#34;text-align: center&#34;&gt;
  &lt;div class=&#34;github-card&#34; data-user=&#34;theonedev&#34; data-repo=&#34;onedev&#34; data-height=&#34;200&#34; data-width=&#34;400&#34; data-theme=&#34;default&#34; data-target=&#34;&#34; data-client-id=&#34;&#34; data-client-secret=&#34;&#34;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;script src=&#34;/github-card-lib/githubcard.js&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;smartdns&#34;&gt;smartdns&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;一个本地DNS服务器，获取最快的网站IP，获得最佳上网体验。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div style=&#34;text-align: center&#34;&gt;
  &lt;div class=&#34;github-card&#34; data-user=&#34;pymumu&#34; data-repo=&#34;smartdns&#34; data-height=&#34;200&#34; data-width=&#34;400&#34; data-theme=&#34;default&#34; data-target=&#34;&#34; data-client-id=&#34;&#34; data-client-secret=&#34;&#34;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;script src=&#34;/github-card-lib/githubcard.js&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;awesome-selfhosted&#34;&gt;&lt;a href=&#34;https://github.com/awesome-selfhosted/awesome-selfhosted&#34;&gt;awesome-selfhosted&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;这里你能找到各种各样的自建 Docker 服务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div style=&#34;text-align: center&#34;&gt;
  &lt;div class=&#34;github-card&#34; data-user=&#34;awesome-selfhosted&#34; data-repo=&#34;awesome-selfhosted&#34; data-height=&#34;200&#34; data-width=&#34;400&#34; data-theme=&#34;default&#34; data-target=&#34;&#34; data-client-id=&#34;&#34; data-client-secret=&#34;&#34;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;script src=&#34;/github-card-lib/githubcard.js&#34;&gt;&lt;/script&gt;

&lt;h2 id=&#34;i-class-fa-solid-fa-school-i-系列教程&#34;&gt;&lt;i class=&#34;fa-solid fa-school&#34;&gt;&lt;/i&gt;&lt;strong&gt;系列教程&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;/atom.xml&#34;&gt;&lt;i class=&#34;fa-solid fa-square-rss&#34;&gt;&lt;/i&gt;全部文章RSS订阅&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;i-class-fa-brands-fa-dev-i-Devops系列&#34;&gt;&lt;i class=&#34;fa-brands fa-dev&#34;&gt;&lt;/i&gt;&lt;strong&gt;Devops系列&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;/categories/devops/atom.xml&#34;&gt;&lt;i class=&#34;fa-solid fa-square-rss&#34;&gt;&lt;/i&gt;&lt;strong&gt;Devops 分类 RSS 订阅&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;/posts/ab63eb8f/&#34;&gt;自建全套开源Devops开发系统&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/d32a07a7/&#34;&gt;Git介绍以及分支模型图解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/39563241/&#34;&gt;三万字无坑搭建基于Docker+K8S+GitLab/SVN+Jenkins+Harbor持续集成交付环境&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/3437994a/&#34;&gt;DevOps系列—【Jenkinsfile+Dockerfile+nginx+vue】&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/f4c3ad41/&#34;&gt;项目开发管理工具推荐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/acc13b70/&#34;&gt;Gitlab的安装及使用教程完全版&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/d08eb7b/&#34;&gt;Gitlab的安装及使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/78c3371/&#34;&gt;那些有用的Github工具介绍！Action、app、workflow等&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;相关文档&#34;&gt;相关文档&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://dbaselife.com/project-3/&#34;&gt;Devops&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="docker" />
        <category term="devops" />
        <category term="框架" />
        <category term="图解" />
        <updated>2022-05-09T05:00:25.000Z</updated>
    </entry>
    <entry>
        <id>https://blog.17lai.site/posts/d32a07a7/</id>
        <title>Git介绍以及分支模型图解</title>
        <link rel="alternate" href="https://blog.17lai.site/posts/d32a07a7/"/>
        <content type="html">&lt;blockquote&gt;
&lt;p&gt;不废话，直接上图。&lt;/p&gt;
&lt;p&gt;由 Drawio 绘制&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/04/1920220419221343.svg&#34; alt=&#34;git使用&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;GIT架构&#34;&gt;&lt;strong&gt;GIT架构&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;GIT的架构，可以分为几个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本地工作区(working directory)&lt;/li&gt;
&lt;li&gt;暂存区(stage area, 又称为索引区, index)、&lt;/li&gt;
&lt;li&gt;本地仓库(local repository)、&lt;/li&gt;
&lt;li&gt;远程仓库副本&lt;/li&gt;
&lt;li&gt;远程仓库(remote repository)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;工作区(working directory)&lt;/strong&gt; 简言之就是你工作的区域。对于git而言，就是的本地工作目录。工作区的内容会包含提交到暂存区和版本库(当前提交点)的内容，同时也包含自己的修改内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;暂存区(stage area, 又称为索引区index)&lt;/strong&gt; 是git中一个非常重要的概念。是我们把修改提交版本库前的一个过渡阶段。查看GIT自带帮助手册的时候，通常以index来表示暂存区。在工作目录下有一个.git的目录，里面有个index文件，存储着关于暂存区的内容。git add命令将工作区内容添加到暂存区。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本地仓库(local repository)&lt;/strong&gt; 版本控制系统的仓库，存在于本地。当执行git commit命令后，会将暂存区内容提交到仓库之中。在工作区下面有.git的目录，这个目录下的内容不属于工作区，里面便是仓库的数据信息，暂存区相关内容也在其中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;远程版本库(remote repository)&lt;/strong&gt; 与本地仓库概念基本一致，不同之处在于一个存在远程，可用于远程协作，一个却是存在于本地。通过push/pull可实现本地与远程的交互；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;远程仓库副本&lt;/strong&gt; 可以理解为存在于本地的远程仓库缓存。如需更新，可通过git fetch/pull命令获取远程仓库内容。使用fech获取时，并未合并到本地仓库，此时可使用git merge实现远程仓库副本与本地仓库的合并。&lt;/p&gt;
&lt;h2 id=&#34;git介绍&#34;&gt;&lt;code&gt;.git&lt;/code&gt;介绍&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;.git&lt;/code&gt;目录下各个文件中所存放的内容信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;HEAD&lt;/strong&gt; 当前所在位置，其实就是工作区的在版本库中的那个提交点，最终会指向一个40位的HASH值；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;config&lt;/strong&gt; 当前版本库的专有配置文件，如使用命令git config &lt;a href=&#34;http://user.name&#34;&gt;user.name&lt;/a&gt; poloxue便会记录在此文件；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;description&lt;/strong&gt; 被gitweb (Github的原型)用来显示对repo的描述。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;hooks&lt;/strong&gt; git有可自动运行在 git 任有意义阶段的脚本hooks, 如commit/release/pull/push等状态之前或者之后。个人思考的一个用处，如pre-push可以用来强制进行代码检查。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;index&lt;/strong&gt; 存放暂存区(stage area)的相关信息；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;info/exclue&lt;/strong&gt; 可以做到和.gitignore相同的事情，用于排除不要包含进版本库的文件。区别就是，此文件不会被共享。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;refs/heads&lt;/strong&gt; 目录下有关于本地仓库的所有分支；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;refs/remote&lt;/strong&gt; 目录下有关于远程仓库的所有分支；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;object&lt;/strong&gt; 目录下存放的就是实际的数据文件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考&#34;&gt;&lt;strong&gt;参考&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&#34;&gt;Git 教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://git-scm.com/book/zh/v2&#34;&gt;Git book&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;i-class-fa-solid-fa-school-i-系列教程&#34;&gt;&lt;i class=&#34;fa-solid fa-school&#34;&gt;&lt;/i&gt;&lt;strong&gt;系列教程&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;/atom.xml&#34;&gt;&lt;i class=&#34;fa-solid fa-square-rss&#34;&gt;&lt;/i&gt;全部文章RSS订阅&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;i-class-fa-brands-fa-dev-i-Devops系列&#34;&gt;&lt;i class=&#34;fa-brands fa-dev&#34;&gt;&lt;/i&gt;&lt;strong&gt;Devops系列&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;/categories/devops/atom.xml&#34;&gt;&lt;i class=&#34;fa-solid fa-square-rss&#34;&gt;&lt;/i&gt;&lt;strong&gt;Devops 分类 RSS 订阅&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;/posts/ab63eb8f/&#34;&gt;自建全套开源Devops开发系统&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/d32a07a7/&#34;&gt;Git介绍以及分支模型图解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/39563241/&#34;&gt;三万字无坑搭建基于Docker+K8S+GitLab/SVN+Jenkins+Harbor持续集成交付环境&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/3437994a/&#34;&gt;DevOps系列—【Jenkinsfile+Dockerfile+nginx+vue】&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/f4c3ad41/&#34;&gt;项目开发管理工具推荐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/acc13b70/&#34;&gt;Gitlab的安装及使用教程完全版&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/d08eb7b/&#34;&gt;Gitlab的安装及使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/78c3371/&#34;&gt;那些有用的Github工具介绍！Action、app、workflow等&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="git" />
        <category term="devops" />
        <category term="drowio" />
        <updated>2022-04-19T12:07:16.000Z</updated>
    </entry>
    <entry>
        <id>https://blog.17lai.site/posts/39563241/</id>
        <title>三万字无坑搭建基于Docker+K8S+GitLab/SVN+Jenkins+Harbor持续集成交付环境</title>
        <link rel="alternate" href="https://blog.17lai.site/posts/39563241/"/>
        <content type="html">&lt;blockquote&gt;
&lt;p&gt;最近在 K8S 1.18.2 版本的集群上搭建DevOps环境，期间遇到了各种坑。目前，搭建环境的过程中出现的各种坑均已被填平，特此记录，并分享给大家！&lt;/p&gt;
&lt;p&gt;文章和搭建环境所需要的yml文件已收录到：&lt;a href=&#34;https://github.com/sunshinelyz/technology-binghe&#34;&gt;https://github.com/sunshinelyz/technology-binghe&lt;/a&gt; 和 &lt;a href=&#34;https://gitee.com/binghe001/technology-binghe&#34;&gt;https://gitee.com/binghe001/technology-binghe&lt;/a&gt; 。如果文件对你有点帮助，别忘记给个Star哦！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;服务器规划&#34;&gt;服务器规划&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;IP&lt;/th&gt;
&lt;th&gt;主机名&lt;/th&gt;
&lt;th&gt;节点&lt;/th&gt;
&lt;th&gt;操作系统&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;192.168.175.101&lt;/td&gt;
&lt;td&gt;binghe101&lt;/td&gt;
&lt;td&gt;K8S Master&lt;/td&gt;
&lt;td&gt;CentOS 8.0.1905&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;192.168.175.102&lt;/td&gt;
&lt;td&gt;binghe102&lt;/td&gt;
&lt;td&gt;K8S Worker&lt;/td&gt;
&lt;td&gt;CentOS 8.0.1905&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;192.168.175.103&lt;/td&gt;
&lt;td&gt;binghe103&lt;/td&gt;
&lt;td&gt;K8S Worker&lt;/td&gt;
&lt;td&gt;CentOS 8.0.1905&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;安装环境版本&#34;&gt;安装环境版本&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;软件名称&lt;/th&gt;
&lt;th&gt;软件版本&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Docker&lt;/td&gt;
&lt;td&gt;19.03.8&lt;/td&gt;
&lt;td&gt;提供容器环境&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker-compose&lt;/td&gt;
&lt;td&gt;1.25.5&lt;/td&gt;
&lt;td&gt;定义和运行由多个容器组成的应用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;K8S&lt;/td&gt;
&lt;td&gt;1.8.12&lt;/td&gt;
&lt;td&gt;是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes的目标是让部署容器化的应用简单并且高效（powerful）,Kubernetes提供了应用部署，规划，更新，维护的一种机制。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;GitLab&lt;/td&gt;
&lt;td&gt;12.1.6&lt;/td&gt;
&lt;td&gt;代码仓库（与SVN安装一个即可）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Harbor&lt;/td&gt;
&lt;td&gt;1.10.2&lt;/td&gt;
&lt;td&gt;私有镜像仓库&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Jenkins&lt;/td&gt;
&lt;td&gt;2.89.3&lt;/td&gt;
&lt;td&gt;持续集成交付&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SVN&lt;/td&gt;
&lt;td&gt;1.10.2&lt;/td&gt;
&lt;td&gt;代码仓库（与GitLab安装一个即可）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JDK&lt;/td&gt;
&lt;td&gt;1.8.0_202&lt;/td&gt;
&lt;td&gt;Java运行基础环境&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;maven&lt;/td&gt;
&lt;td&gt;3.6.3&lt;/td&gt;
&lt;td&gt;构建项目的基础插件&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;服务器免密码登录&#34;&gt;服务器免密码登录&lt;/h2&gt;
&lt;p&gt;在各服务器执行如下命令。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;ssh-keygen -t rsa
cat ~/.ssh/id_rsa.pub &amp;gt;&amp;gt; ~/.ssh/authorized_keys 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;将binghe102和binghe103服务器上的id_rsa.pub文件复制到binghe101服务器。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@binghe102 ~]# scp .ssh/id_rsa.pub binghe101:/root/.ssh/102
[root@binghe103 ~]# scp .ssh/id_rsa.pub binghe101:/root/.ssh/103
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;在binghe101服务器上执行如下命令。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;cat ~/.ssh/102 &amp;gt;&amp;gt; ~/.ssh/authorized_keys
cat ~/.ssh/103 &amp;gt;&amp;gt; ~/.ssh/authorized_keys
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;然后将authorized_keys文件分别复制到binghe102、binghe103服务器。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@binghe101 ~]# scp .ssh/authorized_keys binghe102:/root/.ssh/authorized_keys
[root@binghe101 ~]# scp .ssh/authorized_keys binghe103:/root/.ssh/authorized_keys
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;删除binghe101节点上~/.ssh下的102和103文件。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;rm ~/.ssh/102
rm ~/.ssh/103
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h2 id=&#34;安装JDK&#34;&gt;安装JDK&lt;/h2&gt;
&lt;p&gt;需要在每台服务器上安装JDK环境。到Oracle官方下载JDK，我这里下的JDK版本为1.8.0_202，下载后解压并配置系统环境变量。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;tar -zxvf jdk1.8.0_212.tar.gz
mv jdk1.8.0_212 /usr/local
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;接下来，配置系统环境变量。&lt;/p&gt;
&lt;p&gt;配置项内容如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;JAVA_HOME=/usr/local/jdk1.8.0_212
CLASS_PATH=.:$JAVA_HOME/lib
PATH=$JAVA_HOME/bin:$PATH
export JAVA_HOME CLASS_PATH PATH
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;接下来执行如下命令使系统环境变量生效。&lt;/p&gt;
&lt;h2 id=&#34;安装Maven&#34;&gt;安装Maven&lt;/h2&gt;
&lt;p&gt;到Apache官方下载Maven，我这里下载的Maven版本为3.6.3。下载后直接解压并配置系统环境变量。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;tar -zxvf apache-maven-3.6.3-bin.tar.gz
mv apache-maven-3.6.3-bin /usr/local
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;接下来，就是配置系统环境变量。&lt;/p&gt;
&lt;p&gt;配置项内容如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;JAVA_HOME=/usr/local/jdk1.8.0_212
MAVEN_HOME=/usr/local/apache-maven-3.6.3-bin
CLASS_PATH=.:$JAVA_HOME/lib
PATH=$MAVEN_HOME/bin:$JAVA_HOME/bin:$PATH
export JAVA_HOME CLASS_PATH MAVEN_HOME PATH
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;接下来执行如下命令使系统环境变量生效。&lt;/p&gt;
&lt;p&gt;接下来，修改Maven的配置文件，如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;&amp;lt;localRepository&amp;gt;/home/repository&amp;lt;/localRepository&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;将Maven下载的Jar包存储到/home/repository目录下。&lt;/p&gt;
&lt;h2 id=&#34;安装Docker环境&#34;&gt;安装Docker环境&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;本文档基于Docker 19.03.8 版本搭建Docker环境。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在所有服务器上创建install_docker.sh脚本，脚本内容如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;export REGISTRY_MIRROR=https://registry.cn-hangzhou.aliyuncs.com
dnf install yum*
yum install -y yum-utils device-mapper-persistent-data lvm2
yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
dnf install https://mirrors.aliyun.com/docker-ce/linux/centos/7/x86_64/stable/Packages/containerd.io-1.2.13-3.1.el7.x86_64.rpm
yum install -y docker-ce-19.03.8 docker-ce-cli-19.03.8
systemctl enable docker.service
systemctl start docker.service
docker version
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;在每台服务器上为install_docker.sh脚本赋予可执行权限，并执行脚本即可。&lt;/p&gt;
&lt;h2 id=&#34;安装docker-compose&#34;&gt;安装docker-compose&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;注意：在每台服务器上安装docker-compose&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.下载docker-compose文件&lt;/strong&gt;&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;curl -L https://github.com/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;2-为docker-compose文件赋予可执行权限&#34;&gt;2.为docker-compose文件赋予可执行权限&lt;/h3&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;chmod a+x /usr/local/bin/docker-compose
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;3-查看docker-compose版本&#34;&gt;3.查看docker-compose版本&lt;/h3&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@binghe ~]# docker-compose version
docker-compose version 1.25.5, build 8a1c60f6
docker-py version: 4.1.0
CPython version: 3.7.5
OpenSSL version: OpenSSL 1.1.0l  10 Sep 2019
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h2 id=&#34;安装K8S集群环境&#34;&gt;安装K8S集群环境&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;本文档基于K8S 1.8.12版本来搭建K8S集群&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;安装K8S基础环境&#34;&gt;安装K8S基础环境&lt;/h3&gt;
&lt;p&gt;在所有服务器上创建install_k8s.sh脚本文件，脚本文件的内容如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;#配置阿里云镜像加速器
mkdir -p /etc/docker
tee /etc/docker/daemon.json &amp;lt;&amp;lt;-&#39;EOF&#39;
{
  &#34;registry-mirrors&#34;: [&#34;https://zz3sblpi.mirror.aliyuncs.com&#34;]
}
EOF
systemctl daemon-reload
systemctl restart docker

#安装nfs-utils
yum install -y nfs-utils
yum install -y wget

#启动nfs-server
systemctl start nfs-server
systemctl enable nfs-server

#关闭防火墙
systemctl stop firewalld
systemctl disable firewalld

#关闭SeLinux
setenforce 0
sed -i &#34;s/SELINUX=enforcing/SELINUX=disabled/g&#34; /etc/selinux/config

# 关闭 swap
swapoff -a
yes | cp /etc/fstab /etc/fstab_bak
cat /etc/fstab_bak |grep -v swap &amp;gt; /etc/fstab

#修改 /etc/sysctl.conf
# 如果有配置，则修改
sed -i &#34;s#^net.ipv4.ip_forward.*#net.ipv4.ip_forward=1#g&#34;  /etc/sysctl.conf
sed -i &#34;s#^net.bridge.bridge-nf-call-ip6tables.*#net.bridge.bridge-nf-call-ip6tables=1#g&#34;  /etc/sysctl.conf
sed -i &#34;s#^net.bridge.bridge-nf-call-iptables.*#net.bridge.bridge-nf-call-iptables=1#g&#34;  /etc/sysctl.conf
sed -i &#34;s#^net.ipv6.conf.all.disable_ipv6.*#net.ipv6.conf.all.disable_ipv6=1#g&#34;  /etc/sysctl.conf
sed -i &#34;s#^net.ipv6.conf.default.disable_ipv6.*#net.ipv6.conf.default.disable_ipv6=1#g&#34;  /etc/sysctl.conf
sed -i &#34;s#^net.ipv6.conf.lo.disable_ipv6.*#net.ipv6.conf.lo.disable_ipv6=1#g&#34;  /etc/sysctl.conf
sed -i &#34;s#^net.ipv6.conf.all.forwarding.*#net.ipv6.conf.all.forwarding=1#g&#34;  /etc/sysctl.conf
# 可能没有，追加
echo &#34;net.ipv4.ip_forward = 1&#34; &amp;gt;&amp;gt; /etc/sysctl.conf
echo &#34;net.bridge.bridge-nf-call-ip6tables = 1&#34; &amp;gt;&amp;gt; /etc/sysctl.conf
echo &#34;net.bridge.bridge-nf-call-iptables = 1&#34; &amp;gt;&amp;gt; /etc/sysctl.conf
echo &#34;net.ipv6.conf.all.disable_ipv6 = 1&#34; &amp;gt;&amp;gt; /etc/sysctl.conf
echo &#34;net.ipv6.conf.default.disable_ipv6 = 1&#34; &amp;gt;&amp;gt; /etc/sysctl.conf
echo &#34;net.ipv6.conf.lo.disable_ipv6 = 1&#34; &amp;gt;&amp;gt; /etc/sysctl.conf
echo &#34;net.ipv6.conf.all.forwarding = 1&#34;  &amp;gt;&amp;gt; /etc/sysctl.conf
# 执行命令以应用
sysctl -p

# 配置K8S的yum源
cat &amp;lt;&amp;lt;EOF &amp;gt; /etc/yum.repos.d/kubernetes.repo
[kubernetes]
name=Kubernetes
baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64
enabled=1
gpgcheck=0
repo_gpgcheck=0
gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg
       http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg
EOF

# 卸载旧版本K8S
yum remove -y kubelet kubeadm kubectl

# 安装kubelet、kubeadm、kubectl，这里我安装的是1.18.2版本，你也可以安装1.17.2版本
yum install -y kubelet-1.18.2 kubeadm-1.18.2 kubectl-1.18.2

# 修改docker Cgroup Driver为systemd
# # 将/usr/lib/systemd/system/docker.service文件中的这一行 ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock
# # 修改为 ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --exec-opt native.cgroupdriver=systemd
# 如果不修改，在添加 worker 节点时可能会碰到如下错误
# [WARNING IsDockerSystemdCheck]: detected &#34;cgroupfs&#34; as the Docker cgroup driver. The recommended driver is &#34;systemd&#34;. 
# Please follow the guide at https://kubernetes.io/docs/setup/cri/
sed -i &#34;s#^ExecStart=/usr/bin/dockerd.*#ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --exec-opt native.cgroupdriver=systemd#g&#34; /usr/lib/systemd/system/docker.service

# 设置 docker 镜像，提高 docker 镜像下载速度和稳定性
# 如果访问 https://hub.docker.io 速度非常稳定，亦可以跳过这个步骤
# curl -sSL https://kuboard.cn/install-script/set_mirror.sh | sh -s ${REGISTRY_MIRROR}

# 重启 docker，并启动 kubelet
systemctl daemon-reload
systemctl restart docker
systemctl enable kubelet &amp;amp;&amp;amp; systemctl start kubelet

docker version
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;在每台服务器上为install_k8s.sh脚本赋予可执行权限，并执行脚本即可。&lt;/p&gt;
&lt;h3 id=&#34;初始化Master节点&#34;&gt;初始化Master节点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;只在binghe101服务器上执行的操作。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.初始化Master节点的网络环境&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注意：下面的命令需要在命令行手动执行。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;# 只在 master 节点执行
# export 命令只在当前 shell 会话中有效，开启新的 shell 窗口后，如果要继续安装过程，请重新执行此处的 export 命令
export MASTER_IP=192.168.175.101
# 替换 k8s.master 为 您想要的 dnsName
export APISERVER_NAME=k8s.master
# Kubernetes 容器组所在的网段，该网段安装完成后，由 kubernetes 创建，事先并不存在于物理网络中
export POD_SUBNET=172.18.0.1/16
echo &#34;${MASTER_IP}    ${APISERVER_NAME}&#34; &amp;gt;&amp;gt; /etc/hosts
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;2.初始化Master节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在binghe101服务器上创建init_master.sh脚本文件，文件内容如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
# 脚本出错时终止执行
set -e

if [ ${#POD_SUBNET} -eq 0 ] || [ ${#APISERVER_NAME} -eq 0 ]; then
  echo -e &#34;\033[31;1m请确保您已经设置了环境变量 POD_SUBNET 和 APISERVER_NAME \033[0m&#34;
  echo 当前POD_SUBNET=$POD_SUBNET
  echo 当前APISERVER_NAME=$APISERVER_NAME
  exit 1
fi


# 查看完整配置选项 https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta2
rm -f ./kubeadm-config.yaml
cat &amp;lt;&amp;lt;EOF &amp;gt; ./kubeadm-config.yaml
apiVersion: kubeadm.k8s.io/v1beta2
kind: ClusterConfiguration
kubernetesVersion: v1.18.2
imageRepository: registry.cn-hangzhou.aliyuncs.com/google_containers
controlPlaneEndpoint: &#34;${APISERVER_NAME}:6443&#34;
networking:
  serviceSubnet: &#34;10.96.0.0/16&#34;
  podSubnet: &#34;${POD_SUBNET}&#34;
  dnsDomain: &#34;cluster.local&#34;
EOF

# kubeadm init
# 根据服务器网速的情况，您需要等候 3 - 10 分钟
kubeadm init --config=kubeadm-config.yaml --upload-certs

# 配置 kubectl
rm -rf /root/.kube/
mkdir /root/.kube/
cp -i /etc/kubernetes/admin.conf /root/.kube/config

# 安装 calico 网络插件
# 参考文档 https://docs.projectcalico.org/v3.13/getting-started/kubernetes/self-managed-onprem/onpremises
echo &#34;安装calico-3.13.1&#34;
rm -f calico-3.13.1.yaml
wget https://kuboard.cn/install-script/calico/calico-3.13.1.yaml
kubectl apply -f calico-3.13.1.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;赋予init_master.sh脚本文件可执行权限并执行脚本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.查看Master节点的初始化结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）确保所有容器组处于Running状态&lt;/strong&gt;&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;# 执行如下命令，等待 3-10 分钟，直到所有的容器组处于 Running 状态
watch kubectl get pod -n kube-system -o wide
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;具体执行如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@binghe101 ~]# watch kubectl get pod -n kube-system -o wide
Every 2.0s: kubectl get pod -n kube-system -o wide                                                                                                                          binghe101: Sun May 10 11:01:32 2020

NAME                                       READY   STATUS    RESTARTS   AGE    IP                NODE        NOMINATED NODE   READINESS GATES          
calico-kube-controllers-5b8b769fcd-5dtlp   1/1     Running   0          118s   172.18.203.66     binghe101   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;          
calico-node-fnv8g                          1/1     Running   0          118s   192.168.175.101   binghe101   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;          
coredns-546565776c-27t7h                   1/1     Running   0          2m1s   172.18.203.67     binghe101   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;          
coredns-546565776c-hjb8z                   1/1     Running   0          2m1s   172.18.203.65     binghe101   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;          
etcd-binghe101                             1/1     Running   0          2m7s   192.168.175.101   binghe101   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;          
kube-apiserver-binghe101                   1/1     Running   0          2m7s   192.168.175.101   binghe101   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;          
kube-controller-manager-binghe101          1/1     Running   0          2m7s   192.168.175.101   binghe101   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;          
kube-proxy-dvgsr                           1/1     Running   0          2m1s   192.168.175.101   binghe101   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;          
kube-scheduler-binghe101                   1/1     Running   0          2m7s   192.168.175.101   binghe101   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;（2） 查看 Master 节点初始化结果&lt;/strong&gt;&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl get nodes -o wide
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;具体执行如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@binghe101 ~]# kubectl get nodes -o wide
NAME        STATUS   ROLES    AGE     VERSION   INTERNAL-IP       EXTERNAL-IP   OS-IMAGE                KERNEL-VERSION         CONTAINER-RUNTIME
binghe101   Ready    master   3m28s   v1.18.2   192.168.175.101   &amp;lt;none&amp;gt;        CentOS Linux 8 (Core)   4.18.0-80.el8.x86_64   docker://19.3.8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;初始化Worker节点&#34;&gt;初始化Worker节点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1.获取join命令参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Master节点（binghe101服务器）上执行如下命令获取join命令参数。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;kubeadm token create --print-join-command
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;具体执行如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@binghe101 ~]# kubeadm token create --print-join-command
W0510 11:04:34.828126   56132 configset.go:202] WARNING: kubeadm cannot validate component configs for API groups [kubelet.config.k8s.io kubeproxy.config.k8s.io]
kubeadm join k8s.master:6443 --token 8nblts.62xytoqufwsqzko2     --discovery-token-ca-cert-hash sha256:1717cc3e34f6a56b642b5751796530e367aa73f4113d09994ac3455e33047c0d 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;其中，有如下一行输出。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;kubeadm join k8s.master:6443 --token 8nblts.62xytoqufwsqzko2     --discovery-token-ca-cert-hash sha256:1717cc3e34f6a56b642b5751796530e367aa73f4113d09994ac3455e33047c0d 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;这行代码就是获取到的join命令。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：join命令中的token的有效时间为 2 个小时，2小时内，可以使用此 token 初始化任意数量的 worker 节点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;2.初始化Worker节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;针对所有的 worker 节点执行，在这里，就是在binghe102服务器和binghe103服务器上执行。&lt;/p&gt;
&lt;p&gt;在命令分别手动执行如下命令。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;# 只在 worker 节点执行
# 192.168.175.101 为 master 节点的内网 IP
export MASTER_IP=192.168.175.101
# 替换 k8s.master 为初始化 master 节点时所使用的 APISERVER_NAME
export APISERVER_NAME=k8s.master
echo &#34;${MASTER_IP}    ${APISERVER_NAME}&#34; &amp;gt;&amp;gt; /etc/hosts

# 替换为 master 节点上 kubeadm token create 命令输出的join
kubeadm join k8s.master:6443 --token 8nblts.62xytoqufwsqzko2     --discovery-token-ca-cert-hash sha256:1717cc3e34f6a56b642b5751796530e367aa73f4113d09994ac3455e33047c0d 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;具体执行如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@binghe102 ~]# export MASTER_IP=192.168.175.101
[root@binghe102 ~]# export APISERVER_NAME=k8s.master
[root@binghe102 ~]# echo &#34;${MASTER_IP}    ${APISERVER_NAME}&#34; &amp;gt;&amp;gt; /etc/hosts
[root@binghe102 ~]# kubeadm join k8s.master:6443 --token 8nblts.62xytoqufwsqzko2     --discovery-token-ca-cert-hash sha256:1717cc3e34f6a56b642b5751796530e367aa73f4113d09994ac3455e33047c0d 
W0510 11:08:27.709263   42795 join.go:346] [preflight] WARNING: JoinControlPane.controlPlane settings will be ignored when control-plane flag is not set.
[preflight] Running pre-flight checks
        [WARNING FileExisting-tc]: tc not found in system path
[preflight] Reading configuration from the cluster...
[preflight] FYI: You can look at this config file with &#39;kubectl -n kube-system get cm kubeadm-config -oyaml&#39;
[kubelet-start] Downloading configuration for the kubelet from the &#34;kubelet-config-1.18&#34; ConfigMap in the kube-system namespace
[kubelet-start] Writing kubelet configuration to file &#34;/var/lib/kubelet/config.yaml&#34;
[kubelet-start] Writing kubelet environment file with flags to file &#34;/var/lib/kubelet/kubeadm-flags.env&#34;
[kubelet-start] Starting the kubelet
[kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap...

This node has joined the cluster:
* Certificate signing request was sent to apiserver and a response was received.
* The Kubelet was informed of the new secure connection details.

Run &#39;kubectl get nodes&#39; on the control-plane to see this node join the cluster.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;根据输出结果可以看出，Worker节点加入了K8S集群。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：kubeadm join…就是master 节点上 kubeadm token create 命令输出的join。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;3.查看初始化结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Master节点（binghe101服务器）执行如下命令查看初始化结果。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl get nodes -o wide
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;具体执行如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@binghe101 ~]# kubectl get nodes
NAME        STATUS   ROLES    AGE     VERSION
binghe101   Ready    master   20m     v1.18.2
binghe102   Ready    &amp;lt;none&amp;gt;   2m46s   v1.18.2
binghe103   Ready    &amp;lt;none&amp;gt;   2m46s   v1.18.2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：kubectl get nodes命令后面加上-o wide参数可以输出更多的信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;重启K8S集群引起的问题&#34;&gt;重启K8S集群引起的问题&lt;/h2&gt;
&lt;h3 id=&#34;1-Worker节点故障不能启动&#34;&gt;1.Worker节点故障不能启动&lt;/h3&gt;
&lt;p&gt;Master 节点的 IP 地址发生变化，导致 worker 节点不能启动。需要重新安装K8S集群，并确保所有节点都有固定的内网 IP 地址。&lt;/p&gt;
&lt;h3 id=&#34;2-Pod崩溃或不能正常访问&#34;&gt;2.Pod崩溃或不能正常访问&lt;/h3&gt;
&lt;p&gt;重启服务器后使用如下命令查看Pod的运行状态。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl get pods --all-namespaces
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;发现很多 Pod 不在 Running 状态，此时，需要使用如下命令删除运行不正常的Pod。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl delete pod &amp;lt;pod-name&amp;gt; -n &amp;lt;pod-namespece&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：如果Pod 是使用 Deployment、StatefulSet 等控制器创建的，K8S 将创建新的 Pod 作为替代，重新启动的 Pod 通常能够正常工作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;K8S安装ingress-nginx&#34;&gt;K8S安装ingress-nginx&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;注意：在Master节点（binghe101服务器上执行）&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-创建ingress-nginx命名空间&#34;&gt;1.创建ingress-nginx命名空间&lt;/h3&gt;
&lt;p&gt;创建ingress-nginx-namespace.yaml文件，文件内容如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-yaml&#34; data-language=&#34;yaml&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: Namespace
metadata:
  name: ingress-nginx
  labels:
    name: ingress-nginx
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;执行如下命令创建ingress-nginx命名空间。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl apply -f ingress-nginx-namespace.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;2-安装ingress-controller&#34;&gt;2.安装ingress controller&lt;/h3&gt;
&lt;p&gt;创建ingress-nginx-mandatory.yaml文件，文件内容如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-yaml&#34; data-language=&#34;yaml&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: Namespace
metadata:
  name: ingress-nginx

---

apiVersion: apps/v1
kind: Deployment
metadata:
  name: default-http-backend
  labels:
    app.kubernetes.io/name: default-http-backend
    app.kubernetes.io/part-of: ingress-nginx
  namespace: ingress-nginx
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: default-http-backend
      app.kubernetes.io/part-of: ingress-nginx
  template:
    metadata:
      labels:
        app.kubernetes.io/name: default-http-backend
        app.kubernetes.io/part-of: ingress-nginx
    spec:
      terminationGracePeriodSeconds: 60
      containers:
        - name: default-http-backend
          
          
          
          image: registry.cn-qingdao.aliyuncs.com/kubernetes_xingej/defaultbackend-amd64:1.5
          livenessProbe:
            httpGet:
              path: /healthz
              port: 8080
              scheme: HTTP
            initialDelaySeconds: 30
            timeoutSeconds: 5
          ports:
            - containerPort: 8080
          resources:
            limits:
              cpu: 10m
              memory: 20Mi
            requests:
              cpu: 10m
              memory: 20Mi

---
apiVersion: v1
kind: Service
metadata:
  name: default-http-backend
  namespace: ingress-nginx
  labels:
    app.kubernetes.io/name: default-http-backend
    app.kubernetes.io/part-of: ingress-nginx
spec:
  ports:
    - port: 80
      targetPort: 8080
  selector:
    app.kubernetes.io/name: default-http-backend
    app.kubernetes.io/part-of: ingress-nginx

---

kind: ConfigMap
apiVersion: v1
metadata:
  name: nginx-configuration
  namespace: ingress-nginx
  labels:
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx

---

kind: ConfigMap
apiVersion: v1
metadata:
  name: tcp-services
  namespace: ingress-nginx
  labels:
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx

---

kind: ConfigMap
apiVersion: v1
metadata:
  name: udp-services
  namespace: ingress-nginx
  labels:
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx

---

apiVersion: v1
kind: ServiceAccount
metadata:
  name: nginx-ingress-serviceaccount
  namespace: ingress-nginx
  labels:
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx

---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRole
metadata:
  name: nginx-ingress-clusterrole
  labels:
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
rules:
  - apiGroups:
      - &#34;&#34;
    resources:
      - configmaps
      - endpoints
      - nodes
      - pods
      - secrets
    verbs:
      - list
      - watch
  - apiGroups:
      - &#34;&#34;
    resources:
      - nodes
    verbs:
      - get
  - apiGroups:
      - &#34;&#34;
    resources:
      - services
    verbs:
      - get
      - list
      - watch
  - apiGroups:
      - &#34;extensions&#34;
    resources:
      - ingresses
    verbs:
      - get
      - list
      - watch
  - apiGroups:
      - &#34;&#34;
    resources:
      - events
    verbs:
      - create
      - patch
  - apiGroups:
      - &#34;extensions&#34;
    resources:
      - ingresses/status
    verbs:
      - update

---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: Role
metadata:
  name: nginx-ingress-role
  namespace: ingress-nginx
  labels:
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
rules:
  - apiGroups:
      - &#34;&#34;
    resources:
      - configmaps
      - pods
      - secrets
      - namespaces
    verbs:
      - get
  - apiGroups:
      - &#34;&#34;
    resources:
      - configmaps
    resourceNames:
      
      
      
      
      - &#34;ingress-controller-leader-nginx&#34;
    verbs:
      - get
      - update
  - apiGroups:
      - &#34;&#34;
    resources:
      - configmaps
    verbs:
      - create
  - apiGroups:
      - &#34;&#34;
    resources:
      - endpoints
    verbs:
      - get

---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: RoleBinding
metadata:
  name: nginx-ingress-role-nisa-binding
  namespace: ingress-nginx
  labels:
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: nginx-ingress-role
subjects:
  - kind: ServiceAccount
    name: nginx-ingress-serviceaccount
    namespace: ingress-nginx

---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRoleBinding
metadata:
  name: nginx-ingress-clusterrole-nisa-binding
  labels:
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: nginx-ingress-clusterrole
subjects:
  - kind: ServiceAccount
    name: nginx-ingress-serviceaccount
    namespace: ingress-nginx

---

apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-ingress-controller
  namespace: ingress-nginx
  labels:
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: ingress-nginx
      app.kubernetes.io/part-of: ingress-nginx
  template:
    metadata:
      labels:
        app.kubernetes.io/name: ingress-nginx
        app.kubernetes.io/part-of: ingress-nginx
      annotations:
        prometheus.io/port: &#34;10254&#34;
        prometheus.io/scrape: &#34;true&#34;
    spec:
      serviceAccountName: nginx-ingress-serviceaccount
      containers:
        - name: nginx-ingress-controller
          image: registry.cn-qingdao.aliyuncs.com/kubernetes_xingej/nginx-ingress-controller:0.20.0
          args:
            - /nginx-ingress-controller
            - --default-backend-service=$(POD_NAMESPACE)/default-http-backend
            - --configmap=$(POD_NAMESPACE)/nginx-configuration
            - --tcp-services-configmap=$(POD_NAMESPACE)/tcp-services
            - --udp-services-configmap=$(POD_NAMESPACE)/udp-services
            - --publish-service=$(POD_NAMESPACE)/ingress-nginx
            - --annotations-prefix=nginx.ingress.kubernetes.io
          securityContext:
            capabilities:
              drop:
                - ALL
              add:
                - NET_BIND_SERVICE
            
            runAsUser: 33
          env:
            - name: POD_NAME
              valueFrom:
                fieldRef:
                  fieldPath: metadata.name
            - name: POD_NAMESPACE
              valueFrom:
                fieldRef:
                  fieldPath: metadata.namespace
          ports:
            - name: http
              containerPort: 80
            - name: https
              containerPort: 443
          livenessProbe:
            failureThreshold: 3
            httpGet:
              path: /healthz
              port: 10254
              scheme: HTTP
            initialDelaySeconds: 10
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 1
          readinessProbe:
            failureThreshold: 3
            httpGet:
              path: /healthz
              port: 10254
              scheme: HTTP
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 1

---
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;执行如下命令安装ingress controller。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl apply -f ingress-nginx-mandatory.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;3-安装K8S-SVC：ingress-nginx&#34;&gt;3.安装K8S SVC：ingress-nginx&lt;/h3&gt;
&lt;p&gt;主要是用来用于暴露pod：nginx-ingress-controller。&lt;/p&gt;
&lt;p&gt;创建service-nodeport.yaml文件，文件内容如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-yaml&#34; data-language=&#34;yaml&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: Service
metadata:
  name: ingress-nginx
  namespace: ingress-nginx
  labels:
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
spec:
  type: NodePort
  ports:
    - name: http
      port: 80
      targetPort: 80
      protocol: TCP
      nodePort: 30080
    - name: https
      port: 443
      targetPort: 443
      protocol: TCP
      nodePort: 30443
  selector:
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;执行如下命令安装。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl apply -f service-nodeport.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;4-访问K8S-SVC：ingress-nginx&#34;&gt;4.访问K8S SVC：ingress-nginx&lt;/h3&gt;
&lt;p&gt;查看ingress-nginx命名空间的部署情况，如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@binghe101 k8s]# kubectl get pod -n ingress-nginx
NAME                                        READY   STATUS    RESTARTS   AGE
default-http-backend-796ddcd9b-vfmgn        1/1     Running   1          10h
nginx-ingress-controller-58985cc996-87754   1/1     Running   2          10h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;在命令行服务器命令行输入如下命令查看ingress-nginx的端口映射情况。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl get svc -n ingress-nginx 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;具体如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@binghe101 k8s]# kubectl get svc -n ingress-nginx 
NAME                   TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)                      AGE
default-http-backend   ClusterIP   10.96.247.2   &amp;lt;none&amp;gt;        80/TCP                       7m3s
ingress-nginx          NodePort    10.96.40.6    &amp;lt;none&amp;gt;        80:30080/TCP,443:30443/TCP   4m35s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;所以，可以通过Master节点（binghe101服务器）的IP地址和30080端口号来访问ingress-nginx，如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@binghe101 k8s]# curl 192.168.175.101:30080       
default backend - 404
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;也可以在浏览器打开http://192.168.175.101:30080 来访问ingress-nginx，如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/04/1620220416011231.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;K8S安装gitlab代码仓库&#34;&gt;K8S安装gitlab代码仓库&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;注意：在Master节点（binghe101服务器上执行）&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-创建k8s-ops命名空间&#34;&gt;1.创建k8s-ops命名空间&lt;/h3&gt;
&lt;p&gt;创建k8s-ops-namespace.yaml文件，文件内容如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-yaml&#34; data-language=&#34;yaml&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: Namespace
metadata:
  name: k8s-ops
  labels:
    name: k8s-ops
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;执行如下命令创建命名空间。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl apply -f k8s-ops-namespace.yaml 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;2-安装gitlab-redis&#34;&gt;2.安装gitlab-redis&lt;/h3&gt;
&lt;p&gt;创建gitlab-redis.yaml文件，文件的内容如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-yaml&#34; data-language=&#34;yaml&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: apps/v1
kind: Deployment
metadata:
  name: redis
  namespace: k8s-ops
  labels:
    name: redis
spec:
  selector:
    matchLabels:
      name: redis
  template:
    metadata:
      name: redis
      labels:
        name: redis
    spec:
      containers:
      - name: redis
        image: sameersbn/redis
        imagePullPolicy: IfNotPresent
        ports:
        - name: redis
          containerPort: 6379
        volumeMounts:
        - mountPath: /var/lib/redis
          name: data
        livenessProbe:
          exec:
            command:
            - redis-cli
            - ping
          initialDelaySeconds: 30
          timeoutSeconds: 5
        readinessProbe:
          exec:
            command:
            - redis-cli
            - ping
          initialDelaySeconds: 10
          timeoutSeconds: 5
      volumes:
      - name: data
        hostPath:
          path: /data1/docker/xinsrv/redis

---
apiVersion: v1
kind: Service
metadata:
  name: redis
  namespace: k8s-ops
  labels:
    name: redis
spec:
  ports:
    - name: redis
      port: 6379
      targetPort: redis
  selector:
    name: redis
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;首先，在命令行执行如下命令创建/data1/docker/xinsrv/redis目录。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir -p /data1/docker/xinsrv/redis
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;执行如下命令安装gitlab-redis。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl apply -f gitlab-redis.yaml 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;3-安装gitlab-postgresql&#34;&gt;3.安装gitlab-postgresql&lt;/h3&gt;
&lt;p&gt;创建gitlab-postgresql.yaml，文件内容如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-yaml&#34; data-language=&#34;yaml&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: apps/v1
kind: Deployment
metadata:
  name: postgresql
  namespace: k8s-ops
  labels:
    name: postgresql
spec:
  selector:
    matchLabels:
      name: postgresql
  template:
    metadata:
      name: postgresql
      labels:
        name: postgresql
    spec:
      containers:
      - name: postgresql
        image: sameersbn/postgresql
        imagePullPolicy: IfNotPresent
        env:
        - name: DB_USER
          value: gitlab
        - name: DB_PASS
          value: passw0rd
        - name: DB_NAME
          value: gitlab_production
        - name: DB_EXTENSION
          value: pg_trgm
        ports:
        - name: postgres
          containerPort: 5432
        volumeMounts:
        - mountPath: /var/lib/postgresql
          name: data
        livenessProbe:
          exec:
            command:
            - pg_isready
            - -h
            - localhost
            - -U
            - postgres
          initialDelaySeconds: 30
          timeoutSeconds: 5
        readinessProbe:
          exec:
            command:
            - pg_isready
            - -h
            - localhost
            - -U
            - postgres
          initialDelaySeconds: 5
          timeoutSeconds: 1
      volumes:
      - name: data
        hostPath:
          path: /data1/docker/xinsrv/postgresql
---
apiVersion: v1
kind: Service
metadata:
  name: postgresql
  namespace: k8s-ops
  labels:
    name: postgresql
spec:
  ports:
    - name: postgres
      port: 5432
      targetPort: postgres
  selector:
    name: postgresql
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;首先，执行如下命令创建/data1/docker/xinsrv/postgresql目录。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir -p /data1/docker/xinsrv/postgresql
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;接下来，安装gitlab-postgresql，如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl apply -f gitlab-postgresql.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;4-安装gitlab&#34;&gt;4.安装gitlab&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;（1）配置用户名和密码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，在命令行使用base64编码为用户名和密码进行转码，本示例中，使用的用户名为admin，密码为admin.1231&lt;/p&gt;
&lt;p&gt;转码情况如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@binghe101 k8s]# echo -n &#39;admin&#39; | base64 
YWRtaW4=
[root@binghe101 k8s]# echo -n &#39;admin.1231&#39; | base64 
YWRtaW4uMTIzMQ==
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;转码后的用户名为：YWRtaW4= 密码为：YWRtaW4uMTIzMQ==&lt;/p&gt;
&lt;p&gt;也可以对base64编码后的字符串解码，例如，对密码字符串解码，如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@binghe101 k8s]# echo &#39;YWRtaW4uMTIzMQ==&#39; | base64 --decode 
admin.1231
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;接下来，创建secret-gitlab.yaml文件，主要是用户来配置GitLab的用户名和密码，文件内容如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-yaml&#34; data-language=&#34;yaml&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: Secret
metadata:
  namespace: k8s-ops
  name: git-user-pass
type: Opaque
data:
  username: YWRtaW4=
  password: YWRtaW4uMTIzMQ==
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;执行配置文件的内容，如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl create -f ./secret-gitlab.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;（2）安装GitLab&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建gitlab.yaml文件，文件的内容如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-yaml&#34; data-language=&#34;yaml&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: apps/v1
kind: Deployment
metadata:
  name: gitlab
  namespace: k8s-ops
  labels:
    name: gitlab
spec:
  selector:
    matchLabels:
      name: gitlab
  template:
    metadata:
      name: gitlab
      labels:
        name: gitlab
    spec:
      containers:
      - name: gitlab
        image: sameersbn/gitlab:12.1.6
        imagePullPolicy: IfNotPresent
        env:
        - name: TZ
          value: Asia/Shanghai
        - name: GITLAB_TIMEZONE
          value: Beijing
        - name: GITLAB_SECRETS_DB_KEY_BASE
          value: long-and-random-alpha-numeric-string
        - name: GITLAB_SECRETS_SECRET_KEY_BASE
          value: long-and-random-alpha-numeric-string
        - name: GITLAB_SECRETS_OTP_KEY_BASE
          value: long-and-random-alpha-numeric-string
        - name: GITLAB_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: git-user-pass
              key: password
        - name: GITLAB_ROOT_EMAIL
          value: 12345678@qq.com
        - name: GITLAB_HOST
          value: gitlab.binghe.com
        - name: GITLAB_PORT
          value: &#34;80&#34;
        - name: GITLAB_SSH_PORT
          value: &#34;30022&#34;
        - name: GITLAB_NOTIFY_ON_BROKEN_BUILDS
          value: &#34;true&#34;
        - name: GITLAB_NOTIFY_PUSHER
          value: &#34;false&#34;
        - name: GITLAB_BACKUP_SCHEDULE
          value: daily
        - name: GITLAB_BACKUP_TIME
          value: 01:00
        - name: DB_TYPE
          value: postgres
        - name: DB_HOST
          value: postgresql
        - name: DB_PORT
          value: &#34;5432&#34;
        - name: DB_USER
          value: gitlab
        - name: DB_PASS
          value: passw0rd
        - name: DB_NAME
          value: gitlab_production
        - name: REDIS_HOST
          value: redis
        - name: REDIS_PORT
          value: &#34;6379&#34;
        ports:
        - name: http
          containerPort: 80
        - name: ssh
          containerPort: 22
        volumeMounts:
        - mountPath: /home/git/data
          name: data
        livenessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 180
          timeoutSeconds: 5
        readinessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 5
          timeoutSeconds: 1
      volumes:
      - name: data
        hostPath:
          path: /data1/docker/xinsrv/gitlab
---
apiVersion: v1
kind: Service
metadata:
  name: gitlab
  namespace: k8s-ops
  labels:
    name: gitlab
spec:
  ports:
    - name: http
      port: 80
      nodePort: 30088
    - name: ssh
      port: 22
      targetPort: ssh
      nodePort: 30022
  type: NodePort
  selector:
    name: gitlab

---
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: gitlab
  namespace: k8s-ops
  annotations:
    kubernetes.io/ingress.class: traefik
spec:
  rules:
  - host: gitlab.binghe.com
    http:
      paths:
      - backend:
          serviceName: gitlab
          servicePort: http
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;注意：在配置GitLab时，监听主机时，不能使用IP地址，需要使用主机名或者域名，上述配置中，我使用的是gitlab.binghe.com主机名。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在命令行执行如下命令创建/data1/docker/xinsrv/gitlab目录。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir -p /data1/docker/xinsrv/gitlab
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;安装GitLab，如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl apply -f gitlab.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;5-安装完成&#34;&gt;5.安装完成&lt;/h3&gt;
&lt;p&gt;查看k8s-ops命名空间部署情况，如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@binghe101 k8s]# kubectl get pod -n k8s-ops
NAME                          READY   STATUS    RESTARTS   AGE
gitlab-7b459db47c-5vk6t       0/1     Running   0          11s
postgresql-79567459d7-x52vx   1/1     Running   0          30m
redis-67f4cdc96c-h5ckz        1/1     Running   1          10h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;也可以使用如下命令查看。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@binghe101 k8s]# kubectl get pod --namespace=k8s-ops
NAME                          READY   STATUS    RESTARTS   AGE
gitlab-7b459db47c-5vk6t       0/1     Running   0          36s
postgresql-79567459d7-x52vx   1/1     Running   0          30m
redis-67f4cdc96c-h5ckz        1/1     Running   1          10h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;二者效果一样。&lt;/p&gt;
&lt;p&gt;接下来，查看GitLab的端口映射，如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@binghe101 k8s]# kubectl get svc -n k8s-ops
NAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)                     AGE
gitlab       NodePort    10.96.153.100   &amp;lt;none&amp;gt;        80:30088/TCP,22:30022/TCP   2m42s
postgresql   ClusterIP   10.96.203.119   &amp;lt;none&amp;gt;        5432/TCP                    32m
redis        ClusterIP   10.96.107.150   &amp;lt;none&amp;gt;        6379/TCP                    10h
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;此时，可以看到，可以通过Master节点（binghe101）的主机名gitlab.binghe.com和端口30088就能够访问GitLab。由于我这里使用的是虚拟机来搭建相关的环境，在本机访问虚拟机映射的gitlab.binghe.com时，需要配置本机的hosts文件，在本机的hosts文件中加入如下配置项。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-ini&#34; data-language=&#34;ini&#34;&gt;&lt;code class=&#34;language-ini&#34;&gt;192.168.175.101 gitlab.binghe.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;注意：在Windows操作系统中，hosts文件所在的目录如下。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-ini&#34; data-language=&#34;ini&#34;&gt;&lt;code class=&#34;language-ini&#34;&gt;C:\Windows\System32\drivers\etc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;接下来，就可以在浏览器中通过链接：&lt;a href=&#34;https://gitlab.binghe.com/30088&#34;&gt;http://gitlab.binghe.com:30088&lt;/a&gt; 来访问GitLab了，如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/04/1620220416011231-1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;此时，可以通过用户名root和密码admin.1231来登录GitLab了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：这里的用户名是root而不是admin，因为root是GitLab默认的超级用户。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/04/1620220416011231-2.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;登录后的界面如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/04/1620220416011231-3.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;到此，K8S安装gitlab完成。&lt;/p&gt;
&lt;h2 id=&#34;安装Harbor私有仓库&#34;&gt;安装Harbor私有仓库&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;注意：这里将Harbor私有仓库安装在Master节点（binghe101服务器）上，实际生产环境中建议安装在其他服务器。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-下载Harbor的离线安装版本&#34;&gt;1.下载Harbor的离线安装版本&lt;/h3&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;wget https://github.com/goharbor/harbor/releases/download/v1.10.2/harbor-offline-installer-v1.10.2.tgz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;2-解压Harbor的安装包&#34;&gt;2.解压Harbor的安装包&lt;/h3&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;tar -zxvf harbor-offline-installer-v1.10.2.tgz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;解压成功后，会在服务器当前目录生成一个harbor目录。&lt;/p&gt;
&lt;h3 id=&#34;3-配置Harbor&#34;&gt;3.配置Harbor&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;注意：这里，我将Harbor的端口修改成了1180，如果不修改Harbor的端口，默认的端口是80。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）修改harbor.yml文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;修改的配置项如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-yaml&#34; data-language=&#34;yaml&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;hostname: 192.168.175.101
http:
  port: 1180
harbor_admin_password: binghe123
###并把https注释掉，不然在安装的时候会报错：ERROR:root:Error: The protocol is https but attribute ssl_cert is not set
#https:
  #port: 443
  #certificate: /your/certificate/path
  #private_key: /your/private/key/path
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;（2）修改daemon.json文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;修改/etc/docker/daemon.json文件，没有的话就创建，在/etc/docker/daemon.json文件中添加如下内容。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-json&#34; data-language=&#34;json&#34;&gt;&lt;code class=&#34;language-json&#34;&gt;[root@binghe~]# cat /etc/docker/daemon.json
{
  &#34;registry-mirrors&#34;: [&#34;https://zz3sblpi.mirror.aliyuncs.com&#34;],
  &#34;insecure-registries&#34;:[&#34;192.168.175.101:1180&#34;]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;也可以在服务器上使用 &lt;strong&gt;ip addr&lt;/strong&gt; 命令查看本机所有的IP地址段，将其配置到/etc/docker/daemon.json文件中。这里，我配置后的文件内容如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-json&#34; data-language=&#34;json&#34;&gt;&lt;code class=&#34;language-json&#34;&gt;{
    &#34;registry-mirrors&#34;: [&#34;https://zz3sblpi.mirror.aliyuncs.com&#34;],
    &#34;insecure-registries&#34;:[&#34;192.168.175.0/16&#34;,&#34;172.17.0.0/16&#34;, &#34;172.18.0.0/16&#34;, &#34;172.16.29.0/16&#34;, &#34;192.168.175.101:1180&#34;]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;4-安装并启动harbor&#34;&gt;4.安装并启动harbor&lt;/h3&gt;
&lt;p&gt;配置完成后，输入如下命令即可安装并启动Harbor&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@binghe harbor]# ./install.sh 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;5-登录Harbor并添加账户&#34;&gt;5.登录Harbor并添加账户&lt;/h3&gt;
&lt;p&gt;安装成功后，在浏览器地址栏输入http://192.168.175.101:1180打开链接，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/04/1620220416011231-4.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;输入用户名admin和密码binghe123，登录系统，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/04/1620220416011231-5.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们选择用户管理，添加一个管理员账户，为后续打包Docker镜像和上传Docker镜像做准备。添加账户的步骤如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/04/1620220416011231-6.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/04/1620220416011231-7.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;此处填写的密码为Binghe123。&lt;/p&gt;
&lt;p&gt;点击确定后，如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/04/1620220416011231-8.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;此时，账户binghe还不是管理员，此时选中binghe账户，点击“设置为管理员”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/04/1620220416011231-9.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/04/1620220416011231-10.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;此时，binghe账户就被设置为管理员了。到此，Harbor的安装就完成了。&lt;/p&gt;
&lt;h3 id=&#34;6-修改Harbor端口&#34;&gt;6.修改Harbor端口&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;如果安装Harbor后，大家需要修改Harbor的端口，可以按照如下步骤修改Harbor的端口，这里，我以将80端口修改为1180端口为例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）修改harbor.yml文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;修改的配置项如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-yaml&#34; data-language=&#34;yaml&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;hostname: 192.168.175.101
http:
  port: 1180
harbor_admin_password: binghe123
###并把https注释掉，不然在安装的时候会报错：ERROR:root:Error: The protocol is https but attribute ssl_cert is not set
#https:
  #port: 443
  #certificate: /your/certificate/path
  #private_key: /your/private/key/path
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;（2）修改docker-compose.yml文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;修改的配置项如下所示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）修改config.yml文件&lt;/strong&gt;&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;cd common/config/registry
vim config.yml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;修改的配置项如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;realm: http://192.168.175.101:1180/service/token
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;（4）重启Docker&lt;/strong&gt;&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;systemctl daemon-reload
systemctl restart docker.service
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;（5）重启Harbor&lt;/strong&gt;&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@binghe harbor]# docker-compose down
Stopping harbor-log ... done
Removing nginx             ... done
Removing harbor-portal     ... done
Removing harbor-jobservice ... done
Removing harbor-core       ... done
Removing redis             ... done
Removing registry          ... done
Removing registryctl       ... done
Removing harbor-db         ... done
Removing harbor-log        ... done
Removing network harbor_harbor
 
[root@binghe harbor]# ./prepare
prepare base dir is set to /mnt/harbor
Clearing the configuration file: /config/log/logrotate.conf
Clearing the configuration file: /config/nginx/nginx.conf
Clearing the configuration file: /config/core/env
Clearing the configuration file: /config/core/app.conf
Clearing the configuration file: /config/registry/root.crt
Clearing the configuration file: /config/registry/config.yml
Clearing the configuration file: /config/registryctl/env
Clearing the configuration file: /config/registryctl/config.yml
Clearing the configuration file: /config/db/env
Clearing the configuration file: /config/jobservice/env
Clearing the configuration file: /config/jobservice/config.yml
Generated configuration file: /config/log/logrotate.conf
Generated configuration file: /config/nginx/nginx.conf
Generated configuration file: /config/core/env
Generated configuration file: /config/core/app.conf
Generated configuration file: /config/registry/config.yml
Generated configuration file: /config/registryctl/env
Generated configuration file: /config/db/env
Generated configuration file: /config/jobservice/env
Generated configuration file: /config/jobservice/config.yml
loaded secret from file: /secret/keys/secretkey
Generated configuration file: /compose_location/docker-compose.yml
Clean up the input dir
 
[root@binghe harbor]# docker-compose up -d
Creating network &#34;harbor_harbor&#34; with the default driver
Creating harbor-log ... done
Creating harbor-db   ... done
Creating redis       ... done
Creating registry    ... done
Creating registryctl ... done
Creating harbor-core ... done
Creating harbor-jobservice ... done
Creating harbor-portal     ... done
Creating nginx             ... done
 
[root@binghe harbor]# docker ps -a
CONTAINER ID        IMAGE                                               COMMAND                  CREATED             STATUS                             PORTS
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h2 id=&#34;安装Jenkins（一般的做法）&#34;&gt;安装Jenkins（一般的做法）&lt;/h2&gt;
&lt;h3 id=&#34;1-安装nfs（之前安装过的话，可以省略此步）&#34;&gt;1.安装nfs（之前安装过的话，可以省略此步）&lt;/h3&gt;
&lt;p&gt;使用 nfs 最大的问题就是写权限，可以使用 kubernetes 的 securityContext/runAsUser 指定 jenkins 容器中运行 jenkins 的用户 uid，以此来指定 nfs 目录的权限，让 jenkins 容器可写；也可以不限制，让所有用户都可以写。这里为了简单，就让所有用户可写了。&lt;/p&gt;
&lt;p&gt;如果之前已经安装过nfs，则这一步可以省略。找一台主机，安装 nfs，这里，我以在Master节点（binghe101服务器）上安装nfs为例。&lt;/p&gt;
&lt;p&gt;在命令行输入如下命令安装并启动nfs。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;yum install nfs-utils -y
systemctl start nfs-server
systemctl enable nfs-server
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;2-创建nfs共享目录&#34;&gt;2.创建nfs共享目录&lt;/h3&gt;
&lt;p&gt;在Master节点（binghe101服务器）上创建 &lt;code&gt;/opt/nfs/jenkins-data&lt;/code&gt;目录作为nfs的共享目录，如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir -p /opt/nfs/jenkins-data
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;接下来，编辑/etc/exports文件，如下所示。&lt;/p&gt;
&lt;p&gt;在/etc/exports文件文件中添加如下一行配置。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-ini&#34; data-language=&#34;ini&#34;&gt;&lt;code class=&#34;language-ini&#34;&gt;/opt/nfs/jenkins-data 192.168.175.0/24(rw,all_squash)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;这里的 ip 使用 kubernetes node 节点的 ip 范围，后面的 &lt;code&gt;all_squash&lt;/code&gt; 选项会将所有访问的用户都映射成 nfsnobody 用户，不管你是什么用户访问，最终都会压缩成 nfsnobody，所以只要将 &lt;code&gt;/opt/nfs/jenkins-data&lt;/code&gt; 的属主改为 nfsnobody，那么无论什么用户来访问都具有写权限。&lt;/p&gt;
&lt;p&gt;这个选项在很多机器上由于用户 uid 不规范导致启动进程的用户不同，但是同时要对一个共享目录具有写权限时很有效。&lt;/p&gt;
&lt;p&gt;接下来，为 &lt;code&gt;/opt/nfs/jenkins-data&lt;/code&gt;目录授权，并重新加载nfs，如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;chown -R 1000 /opt/nfs/jenkins-data/
systemctl reload nfs-server
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;在K8S集群中任意一个节点上使用如下命令进行验证：&lt;/p&gt;
&lt;p&gt;如果能够看到 /opt/nfs/jenkins-data 就表示 ok 了。&lt;/p&gt;
&lt;p&gt;具体如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@binghe101 ~]# showmount -e 192.168.175.101
Export list for 192.168.175.101:
/opt/nfs/jenkins-data 192.168.175.0/24

[root@binghe102 ~]# showmount -e 192.168.175.101
Export list for 192.168.175.101:
/opt/nfs/jenkins-data 192.168.175.0/24
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;3-创建PV&#34;&gt;3.创建PV&lt;/h3&gt;
&lt;p&gt;Jenkins 其实只要加载对应的目录就可以读取之前的数据，但是由于 deployment 无法定义存储卷，因此我们只能使用 StatefulSet。&lt;/p&gt;
&lt;p&gt;首先创建 pv，pv 是给 StatefulSet 使用的，每次 StatefulSet 启动都会通过 volumeClaimTemplates 这个模板去创建 pvc，因此必须得有 pv，才能供 pvc 绑定。&lt;/p&gt;
&lt;p&gt;创建jenkins-pv.yaml文件，文件内容如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-yaml&#34; data-language=&#34;yaml&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: PersistentVolume
metadata:
  name: jenkins
spec:
  nfs:
    path: /opt/nfs/jenkins-data
    server: 192.168.175.101
  accessModes: [&#34;ReadWriteOnce&#34;]
  capacity:
    storage: 1Ti
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;我这里给了 1T存储空间，可以根据实际配置。&lt;/p&gt;
&lt;p&gt;执行如下命令创建pv。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl apply -f jenkins-pv.yaml 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;4-创建serviceAccount&#34;&gt;4.创建serviceAccount&lt;/h3&gt;
&lt;p&gt;创建service account，因为 jenkins 后面需要能够动态创建 slave，因此它必须具备一些权限。&lt;/p&gt;
&lt;p&gt;创建jenkins-service-account.yaml文件，文件内容如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-yaml&#34; data-language=&#34;yaml&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: ServiceAccount
metadata:
  name: jenkins

---
kind: Role
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: jenkins
rules:
  - apiGroups: [&#34;&#34;]
    resources: [&#34;pods&#34;]
    verbs: [&#34;create&#34;, &#34;delete&#34;, &#34;get&#34;, &#34;list&#34;, &#34;patch&#34;, &#34;update&#34;, &#34;watch&#34;]
  - apiGroups: [&#34;&#34;]
    resources: [&#34;pods/exec&#34;]
    verbs: [&#34;create&#34;, &#34;delete&#34;, &#34;get&#34;, &#34;list&#34;, &#34;patch&#34;, &#34;update&#34;, &#34;watch&#34;]
  - apiGroups: [&#34;&#34;]
    resources: [&#34;pods/log&#34;]
    verbs: [&#34;get&#34;, &#34;list&#34;, &#34;watch&#34;]
  - apiGroups: [&#34;&#34;]
    resources: [&#34;secrets&#34;]
    verbs: [&#34;get&#34;]

---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: RoleBinding
metadata:
  name: jenkins
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: jenkins
subjects:
  - kind: ServiceAccount
    name: jenkins
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;上述配置中，创建了一个 RoleBinding 和一个 ServiceAccount，并且将 RoleBinding 的权限绑定到这个用户上。所以，jenkins 容器必须使用这个 ServiceAccount 运行才行，不然 RoleBinding 的权限它将不具备。&lt;/p&gt;
&lt;p&gt;RoleBinding 的权限很容易就看懂了，因为 jenkins 需要创建和删除 slave，所以才需要上面这些权限。至于 secrets 权限，则是 https 证书。&lt;/p&gt;
&lt;p&gt;执行如下命令创建serviceAccount。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl apply -f jenkins-service-account.yaml 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;5-安装Jenkins&#34;&gt;5.安装Jenkins&lt;/h3&gt;
&lt;p&gt;创建jenkins-statefulset.yaml文件，文件内容如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-yaml&#34; data-language=&#34;yaml&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: jenkins
  labels:
    name: jenkins
spec:
  selector:
    matchLabels:
      name: jenkins
  serviceName: jenkins
  replicas: 1
  updateStrategy:
    type: RollingUpdate
  template:
    metadata:
      name: jenkins
      labels:
        name: jenkins
    spec:
      terminationGracePeriodSeconds: 10
      serviceAccountName: jenkins
      containers:
        - name: jenkins
          image: docker.io/jenkins/jenkins:lts
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 8080
            - containerPort: 32100
          resources:
            limits:
              cpu: 4
              memory: 4Gi
            requests:
              cpu: 4
              memory: 4Gi
          env:
            - name: LIMITS_MEMORY
              valueFrom:
                resourceFieldRef:
                  resource: limits.memory
                  divisor: 1Mi
            - name: JAVA_OPTS
              
              value: -Xmx$(LIMITS_MEMORY)m -XshowSettings:vm -Dhudson.slaves.NodeProvisioner.initialDelay=0 -Dhudson.slaves.NodeProvisioner.MARGIN=50 -Dhudson.slaves.NodeProvisioner.MARGIN0=0.85
          volumeMounts:
            - name: jenkins-home
              mountPath: /var/jenkins_home
          livenessProbe:
            httpGet:
              path: /login
              port: 8080
            initialDelaySeconds: 60
            timeoutSeconds: 5
            failureThreshold: 12 
          readinessProbe:
            httpGet:
              path: /login
              port: 8080
            initialDelaySeconds: 60
            timeoutSeconds: 5
            failureThreshold: 12 
  
  volumeClaimTemplates:
    - metadata:
        name: jenkins-home
      spec:
        accessModes: [&#34;ReadWriteOnce&#34;]
        resources:
          requests:
            storage: 1Ti
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;jenkins 部署时需要注意它的副本数，你的副本数有多少就要有多少个 pv，同样，存储会有多倍消耗。这里我只使用了一个副本，因此前面也只创建了一个 pv。&lt;/p&gt;
&lt;p&gt;使用如下命令安装Jenkins。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl apply -f jenkins-statefulset.yaml 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;6-创建Service&#34;&gt;6.创建Service&lt;/h3&gt;
&lt;p&gt;创建jenkins-service.yaml文件，文件内容如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-yaml&#34; data-language=&#34;yaml&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: Service
metadata:
  name: jenkins
spec:
  
  selector:
    name: jenkins
  
  
  ports:
    - name: http
      port: 80
      nodePort: 31888
      targetPort: 8080
      protocol: TCP
    - name: jenkins-agent
      port: 32100
      nodePort: 32100
      targetPort: 32100
      protocol: TCP
  type: NodePort
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;使用如下命令安装Service。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl apply -f jenkins-service.yaml 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;7-安装-ingress&#34;&gt;7.安装 ingress&lt;/h3&gt;
&lt;p&gt;jenkins 的 web 界面需要从集群外访问，这里我们选择的是使用 ingress。创建jenkins-ingress.yaml文件，文件内容如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-yaml&#34; data-language=&#34;yaml&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: jenkins
spec:
  rules:
    - http:
        paths:
          - path: /
            backend:
              serviceName: jenkins
              servicePort: 31888
      host: jekins.binghe.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;这里，需要注意的是host必须配置为域名或者主机名，否则会报错，如下所示。&lt;/strong&gt;&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;The Ingress &#34;jenkins&#34; is invalid: spec.rules[0].host: Invalid value: &#34;192.168.175.101&#34;: must be a DNS name, not an IP address
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;使用如下命令安装ingress。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;kubectl apply -f jenkins-ingress.yaml 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;最后，由于我这里使用的是虚拟机来搭建相关的环境，在本机访问虚拟机映射的jekins.binghe.com时，需要配置本机的hosts文件，在本机的hosts文件中加入如下配置项。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-ini&#34; data-language=&#34;ini&#34;&gt;&lt;code class=&#34;language-ini&#34;&gt;192.168.175.101 jekins.binghe.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;注意：在Windows操作系统中，hosts文件所在的目录如下。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-ini&#34; data-language=&#34;ini&#34;&gt;&lt;code class=&#34;language-ini&#34;&gt;C:\Windows\System32\drivers\etc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;接下来，就可以在浏览器中通过链接：&lt;a href=&#34;https://jekins.binghe.com/31888&#34;&gt;http://jekins.binghe.com:31888&lt;/a&gt; 来访问Jekins了。&lt;/p&gt;
&lt;h2 id=&#34;物理机安装SVN&#34;&gt;物理机安装SVN&lt;/h2&gt;
&lt;p&gt;这里，以在Master节点（binghe101服务器）上安装SVN为例。&lt;/p&gt;
&lt;h3 id=&#34;1-使用yum安装SVN&#34;&gt;1.使用yum安装SVN&lt;/h3&gt;
&lt;p&gt;在命令行执行如下命令安装SVN。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;yum -y install subversion 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;2-创建SVN库&#34;&gt;2.创建SVN库&lt;/h3&gt;
&lt;p&gt;依次执行如下命令。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;#创建/data/svn
mkdir -p /data/svn 
#初始化svn
svnserve -d -r /data/svn
#创建代码仓库
svnadmin create /data/svn/test
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;3-配置SVN&#34;&gt;3.配置SVN&lt;/h3&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;mkdir /data/svn/conf
cp /data/svn/test/conf/* /data/svn/conf/
cd /data/svn/conf/
[root@binghe101 conf]# ll
总用量 20
-rw-r--r-- 1 root root 1080 5月  12 02:17 authz
-rw-r--r-- 1 root root  885 5月  12 02:17 hooks-env.tmpl
-rw-r--r-- 1 root root  309 5月  12 02:17 passwd
-rw-r--r-- 1 root root 4375 5月  12 02:17 svnserve.conf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;配置authz文件，&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;配置后的内容如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-ini&#34; data-language=&#34;ini&#34;&gt;&lt;code class=&#34;language-ini&#34;&gt;[aliases]
# joe = /C=XZ/ST=Dessert/L=Snake City/O=Snake Oil, Ltd./OU=Research Institute/CN=Joe Average

[groups]
# harry_and_sally = harry,sally
# harry_sally_and_joe = harry,sally,&amp;amp;joe
SuperAdmin = admin
binghe = admin,binghe

# [/foo/bar]
# harry = rw
# &amp;amp;joe = r
# * =

# [repository:/baz/fuz]
# @harry_and_sally = rw
# * = r

[test:/]
@SuperAdmin=rw
@binghe=rw
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;配置passwd文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;配置后的内容如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-ini&#34; data-language=&#34;ini&#34;&gt;&lt;code class=&#34;language-ini&#34;&gt;[users]
# harry = harryssecret
# sally = sallyssecret
admin = admin123
binghe = binghe123
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;配置 svnserve.conf&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;配置后的文件如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-ini&#34; data-language=&#34;ini&#34;&gt;&lt;code class=&#34;language-ini&#34;&gt;### This file controls the configuration of the svnserve daemon, if you
### use it to allow access to this repository.  (If you only allow
### access through http: and/or file: URLs, then this file is
### irrelevant.)

### Visit http://subversion.apache.org/ for more information.

[general]
### The anon-access and auth-access options control access to the
### repository for unauthenticated (a.k.a. anonymous) users and
### authenticated users, respectively.
### Valid values are &#34;write&#34;, &#34;read&#34;, and &#34;none&#34;.
### Setting the value to &#34;none&#34; prohibits both reading and writing;
### &#34;read&#34; allows read-only access, and &#34;write&#34; allows complete 
### read/write access to the repository.
### The sample settings below are the defaults and specify that anonymous
### users have read-only access to the repository, while authenticated
### users have read and write access to the repository.
anon-access = none
auth-access = write
### The password-db option controls the location of the password
### database file.  Unless you specify a path starting with a /,
### the file&#39;s location is relative to the directory containing
### this configuration file.
### If SASL is enabled (see below), this file will NOT be used.
### Uncomment the line below to use the default password file.
password-db = /data/svn/conf/passwd
### The authz-db option controls the location of the authorization
### rules for path-based access control.  Unless you specify a path
### starting with a /, the file&#39;s location is relative to the
### directory containing this file.  The specified path may be a
### repository relative URL (^/) or an absolute file:// URL to a text
### file in a Subversion repository.  If you don&#39;t specify an authz-db,
### no path-based access control is done.
### Uncomment the line below to use the default authorization file.
authz-db = /data/svn/conf/authz
### The groups-db option controls the location of the file with the
### group definitions and allows maintaining groups separately from the
### authorization rules.  The groups-db file is of the same format as the
### authz-db file and should contain a single [groups] section with the
### group definitions.  If the option is enabled, the authz-db file cannot
### contain a [groups] section.  Unless you specify a path starting with
### a /, the file&#39;s location is relative to the directory containing this
### file.  The specified path may be a repository relative URL (^/) or an
### absolute file:// URL to a text file in a Subversion repository.
### This option is not being used by default.
# groups-db = groups
### This option specifies the authentication realm of the repository.
### If two repositories have the same authentication realm, they should
### have the same password database, and vice versa.  The default realm
### is repository&#39;s uuid.
realm = svn
### The force-username-case option causes svnserve to case-normalize
### usernames before comparing them against the authorization rules in the
### authz-db file configured above.  Valid values are &#34;upper&#34; (to upper-
### case the usernames), &#34;lower&#34; (to lowercase the usernames), and
### &#34;none&#34; (to compare usernames as-is without case conversion, which
### is the default behavior).
# force-username-case = none
### The hooks-env options specifies a path to the hook script environment 
### configuration file. This option overrides the per-repository default
### and can be used to configure the hook script environment for multiple 
### repositories in a single file, if an absolute path is specified.
### Unless you specify an absolute path, the file&#39;s location is relative
### to the directory containing this file.
# hooks-env = hooks-env

[sasl]
### This option specifies whether you want to use the Cyrus SASL
### library for authentication. Default is false.
### Enabling this option requires svnserve to have been built with Cyrus
### SASL support; to check, run &#39;svnserve --version&#39; and look for a line
### reading &#39;Cyrus SASL authentication is available.&#39;
# use-sasl = true
### These options specify the desired strength of the security layer
### that you want SASL to provide. 0 means no encryption, 1 means
### integrity-checking only, values larger than 1 are correlated
### to the effective key length for encryption (e.g. 128 means 128-bit
### encryption). The values below are the defaults.
# min-encryption = 0
# max-encryption = 256
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;接下来，将/data/svn/conf目录下的svnserve.conf文件复制到/data/svn/test/conf/目录下。如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@binghe101 conf]# cp /data/svn/conf/svnserve.conf /data/svn/test/conf/
cp：是否覆盖&#39;/data/svn/test/conf/svnserve.conf&#39;？ y
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;4-启动SVN服务&#34;&gt;4.启动SVN服务&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;（1）创建svnserve.service服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建svnserve.service文件&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;vim /usr/lib/systemd/system/svnserve.service
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;文件的内容如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-ini&#34; data-language=&#34;ini&#34;&gt;&lt;code class=&#34;language-ini&#34;&gt;[Unit]
Description=Subversion protocol daemon
After=syslog.target network.target
Documentation=man:svnserve(8)

[Service]
Type=forking
EnvironmentFile=/etc/sysconfig/svnserve
#ExecStart=/usr/bin/svnserve --daemon --pid-file=/run/svnserve/svnserve.pid $OPTIONS
ExecStart=/usr/bin/svnserve --daemon $OPTIONS
PrivateTmp=yes

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;接下来执行如下命令使配置生效。&lt;/p&gt;
&lt;p&gt;命令执行成功后，修改 /etc/sysconfig/svnserve 文件。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;vim /etc/sysconfig/svnserve 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;修改后的文件内容如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-ini&#34; data-language=&#34;ini&#34;&gt;&lt;code class=&#34;language-ini&#34;&gt;# OPTIONS is used to pass command-line arguments to svnserve.
# 
# Specify the repository location in -r parameter:
OPTIONS=&#34;-r /data/svn&#34;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;（2）启动SVN&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先查看SVN状态，如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@itence10 conf]# systemctl status svnserve.service
● svnserve.service - Subversion protocol daemon
   Loaded: loaded (/usr/lib/systemd/system/svnserve.service; disabled; vendor preset: disabled)
   Active: inactive (dead)
     Docs: man:svnserve(8)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;可以看到，此时SVN并没有启动，接下来，需要启动SVN。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;systemctl start svnserve.service
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;设置SVN服务开机自启动。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;systemctl enable svnserve.service
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;接下来，就可以下载安装TortoiseSVN，输入链接&lt;a href=&#34;svn://192.168.0.10/test&#34;&gt;svn://192.168.0.10/test&lt;/a&gt; 并输入用户名binghe，密码binghe123来连接SVN了。&lt;/p&gt;
&lt;h2 id=&#34;物理机安装Jenkins&#34;&gt;物理机安装Jenkins&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;注意：安装Jenkins之前需要安装JDK和Maven，我这里同样将Jenkins安装在Master节点（binghe101服务器）。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-启用Jenkins库&#34;&gt;1.启用Jenkins库&lt;/h3&gt;
&lt;p&gt;运行以下命令以下载repo文件并导入GPG密钥：&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat-stable/jenkins.repo
rpm --import https://jenkins-ci.org/redhat/jenkins-ci.org.key
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;2-安装Jenkins&#34;&gt;2.安装Jenkins&lt;/h3&gt;
&lt;p&gt;执行如下命令安装Jenkis。&lt;/p&gt;
&lt;p&gt;接下来，修改Jenkins默认端口，如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;vim /etc/sysconfig/jenkins
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;修改后的两项配置如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-ini&#34; data-language=&#34;ini&#34;&gt;&lt;code class=&#34;language-ini&#34;&gt;JENKINS_JAVA_CMD=&#34;/usr/local/jdk1.8.0_212/bin/java&#34;
JENKINS_PORT=&#34;18080&#34;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;此时，已经将Jenkins的端口由8080修改为18080&lt;/p&gt;
&lt;h3 id=&#34;3-启动Jenkins&#34;&gt;3.启动Jenkins&lt;/h3&gt;
&lt;p&gt;在命令行输入如下命令启动Jenkins。&lt;/p&gt;
&lt;p&gt;配置Jenkins开机自启动。&lt;/p&gt;
&lt;p&gt;查看Jenkins的运行状态。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@itence10 ~]# systemctl status jenkins
● jenkins.service - LSB: Jenkins Automation Server
   Loaded: loaded (/etc/rc.d/init.d/jenkins; generated)
   Active: active (running) since Tue 2020-05-12 04:33:40 EDT; 28s ago
     Docs: man:systemd-sysv-generator(8)
    Tasks: 71 (limit: 26213)
   Memory: 550.8M
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;说明，Jenkins启动成功。&lt;/p&gt;
&lt;h2 id=&#34;配置Jenkins运行环境&#34;&gt;配置Jenkins运行环境&lt;/h2&gt;
&lt;h3 id=&#34;1-登录Jenkins&#34;&gt;1.登录Jenkins&lt;/h3&gt;
&lt;p&gt;首次安装后，需要配置Jenkins的运行环境。首先，在浏览器地址栏访问链接http://192.168.0.10:18080，打开Jenkins界面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/04/1620220416011231-11.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;根据提示使用如下命令到服务器上找密码值，如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@binghe101 ~]# cat /var/lib/jenkins/secrets/initialAdminPassword
71af861c2ab948a1b6efc9f7dde90776
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;将密码71af861c2ab948a1b6efc9f7dde90776复制到文本框，点击继续。会跳转到自定义Jenkins页面，如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/04/1620220416011231-12.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;这里，可以直接选择“安装推荐的插件”。之后会跳转到一个安装插件的页面，如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/04/1620220416011231-13.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;此步骤可能有下载失败的情况，可直接忽略。&lt;/p&gt;
&lt;h3 id=&#34;2-安装插件&#34;&gt;2.安装插件&lt;/h3&gt;
&lt;p&gt;需要安装的插件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Kubernetes Cli Plugin：该插件可直接在Jenkins中使用kubernetes命令行进行操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Kubernetes plugin： 使用kubernetes则需要安装该插件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Kubernetes Continuous Deploy Plugin：kubernetes部署插件，可根据需要使用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有更多的插件可供选择，可点击 系统管理-&amp;gt;管理插件进行管理和添加，安装相应的Docker插件、SSH插件、Maven插件。其他的插件可以根据需要进行安装。如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/04/1620220416011231-14.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/04/1620220416011231-15.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-配置Jenkins&#34;&gt;3.配置Jenkins&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;（1）配置JDK和Maven&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Global Tool Configuration中配置JDK和Maven，如下所示，打开Global Tool Configuration界面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/04/1620220416011231-16.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;接下来就开始配置JDK和Maven了。&lt;/p&gt;
&lt;p&gt;由于我在服务器上将Maven安装在/usr/local/maven-3.6.3目录下，所以，需要在“Maven 配置”中进行配置，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/04/1620220416011231-17.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;接下来，配置JDK，如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/04/1620220416011231-18.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：不要勾选“Install automatically”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来，配置Maven，如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/04/1620220416011231-19.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：不要勾选“Install automatically”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）配置SSH&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进入Jenkins的Configure System界面配置SSH，如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/04/1620220416011231-20.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;找到 SSH remote hosts 进行配置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/04/1620220416011231-21.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/04/1620220416011231-22.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;配置完成后，点击Check connection按钮，会显示 Successfull connection。如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/04/1620220416011231-23.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;至此，Jenkins的基本配置就完成了。&lt;/p&gt;
&lt;h2 id=&#34;Jenkins发布Docker项目到K8s集群&#34;&gt;Jenkins发布Docker项目到K8s集群&lt;/h2&gt;
&lt;h3 id=&#34;1-调整SpringBoot项目的配置&#34;&gt;1.调整SpringBoot项目的配置&lt;/h3&gt;
&lt;p&gt;实现，SpringBoot项目中启动类所在的模块的pom.xml需要引入打包成Docker镜像的配置，如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-markup&#34; data-language=&#34;markup&#34;&gt;&lt;code class=&#34;language-markup&#34;&gt;  &amp;lt;properties&amp;gt;
        &amp;lt;docker.repostory&amp;gt;192.168.0.10:1180&amp;lt;/docker.repostory&amp;gt;
        &amp;lt;docker.registry.name&amp;gt;test&amp;lt;/docker.registry.name&amp;gt;
        &amp;lt;docker.image.tag&amp;gt;1.0.0&amp;lt;/docker.image.tag&amp;gt;
        &amp;lt;docker.maven.plugin.version&amp;gt;1.4.10&amp;lt;/docker.maven.plugin.version&amp;gt;
  &amp;lt;/properties&amp;gt;

&amp;lt;build&amp;gt;
        &amp;lt;finalName&amp;gt;test-starter&amp;lt;/finalName&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
            
            
            
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;com.spotify&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;dockerfile-maven-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${docker.maven.plugin.version}&amp;lt;/version&amp;gt;
                &amp;lt;executions&amp;gt;
                    &amp;lt;execution&amp;gt;
                    &amp;lt;id&amp;gt;default&amp;lt;/id&amp;gt;
                    &amp;lt;goals&amp;gt;
                        
                        &amp;lt;goal&amp;gt;build&amp;lt;/goal&amp;gt;
                        &amp;lt;goal&amp;gt;push&amp;lt;/goal&amp;gt;
                    &amp;lt;/goals&amp;gt;
                    &amp;lt;/execution&amp;gt;
                &amp;lt;/executions&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;contextDirectory&amp;gt;${project.basedir}&amp;lt;/contextDirectory&amp;gt;
                    
                    &amp;lt;useMavenSettingsForAuth&amp;gt;useMavenSettingsForAuth&amp;gt;true&amp;lt;/useMavenSettingsForAuth&amp;gt;
                    &amp;lt;repository&amp;gt;${docker.repostory}/${docker.registry.name}/${project.artifactId}&amp;lt;/repository&amp;gt;
                    &amp;lt;tag&amp;gt;${docker.image.tag}&amp;lt;/tag&amp;gt;
                    &amp;lt;buildArgs&amp;gt;
                        &amp;lt;JAR_FILE&amp;gt;target/${project.build.finalName}.jar&amp;lt;/JAR_FILE&amp;gt;
                    &amp;lt;/buildArgs&amp;gt;
                &amp;lt;/configuration&amp;gt;
            &amp;lt;/plugin&amp;gt;

        &amp;lt;/plugins&amp;gt;
        
        &amp;lt;resources&amp;gt;
            
            &amp;lt;resource&amp;gt;
                &amp;lt;directory&amp;gt;src/main/resources&amp;lt;/directory&amp;gt;
                &amp;lt;targetPath&amp;gt;${project.build.directory}/classes&amp;lt;/targetPath&amp;gt;
                &amp;lt;includes&amp;gt;
                    &amp;lt;include&amp;gt;**/*&amp;lt;/include&amp;gt;
                &amp;lt;/includes&amp;gt;
                &amp;lt;filtering&amp;gt;true&amp;lt;/filtering&amp;gt;
            &amp;lt;/resource&amp;gt;
        &amp;lt;/resources&amp;gt;
    &amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;接下来，在SpringBoot启动类所在模块的根目录创建Dockerfile，内容示例如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-docker&#34; data-language=&#34;docker&#34;&gt;&lt;code class=&#34;language-docker&#34;&gt;#添加依赖环境，前提是将Java8的Docker镜像从官方镜像仓库pull下来，然后上传到自己的Harbor私有仓库中
FROM 192.168.0.10:1180/library/java:8
#指定镜像制作作者
MAINTAINER binghe
#运行目录
VOLUME /tmp
#将本地的文件拷贝到容器
ADD target/*jar app.jar
#启动容器后自动执行的命令
ENTRYPOINT [ &#34;java&#34;, &#34;-Djava.security.egd=file:/dev/./urandom&#34;, &#34;-jar&#34;, &#34;/app.jar&#34; ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;根据实际情况，自行修改。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：FROM 192.168.0.10:1180/library/java:8的前提是执行如下命令。&lt;/strong&gt;&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;docker pull java:8
docker tag java:8 192.168.0.10:1180/library/java:8
docker login 192.168.0.10:1180
docker push 192.168.0.10:1180/library/java:8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;在SpringBoot启动类所在模块的根目录创建yaml文件，录入叫做test.yaml文件，内容如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-yaml&#34; data-language=&#34;yaml&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: apps/v1
kind: Deployment
metadata:
  name: test-starter
  labels:
    app: test-starter
spec:
  replicas: 1
  selector:
    matchLabels:
      app: test-starter
  template:
    metadata:
      labels:
        app: test-starter
    spec:
      containers:
      - name: test-starter
        image: 192.168.0.10:1180/test/test-starter:1.0.0
        ports:
        - containerPort: 8088
      nodeSelector:
        clustertype: node12

---
apiVersion: v1
kind: Service
metadata:
  name: test-starter
  labels:
    app: test-starter
spec:
  ports:
    - name: http
      port: 8088
      nodePort: 30001
  type: NodePort
  selector:
    app: test-starter
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;2-Jenkins配置发布项目&#34;&gt;2.Jenkins配置发布项目&lt;/h3&gt;
&lt;p&gt;将项目上传到SVN代码库，例如地址为&lt;a href=&#34;svn://192.168.0.1/test&#34;&gt;svn://192.168.0.10/test&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接下来，在Jenkins中配置自动发布。步骤如下所示。&lt;/p&gt;
&lt;p&gt;点击新建Item。&lt;/p&gt;
&lt;p&gt;在描述文本框中输入描述信息，如下所示。&lt;/p&gt;
&lt;p&gt;接下来，配置SVN信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：配置GitLab的步骤与SVN相同，不再赘述。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定位到Jenkins的“构建模块”，使用Execute Shell来构建发布项目到K8S集群。&lt;/p&gt;
&lt;p&gt;执行的命令依次如下所示。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;#删除本地原有的镜像,不会影响Harbor仓库中的镜像
docker rmi 192.168.0.10:1180/test/test-starter:1.0.0
#使用Maven编译、构建Docker镜像，执行完成后本地Docker容器中会重新构建镜像文件
/usr/local/maven-3.6.3/bin/mvn -f ./pom.xml clean install -Dmaven.test.skip=true
#登录 Harbor仓库
docker login 192.168.0.10:1180 -u binghe -p Binghe123
#上传镜像到Harbor仓库
docker push 192.168.0.10:1180/test/test-starter:1.0.0
#停止并删除K8S集群中运行的
/usr/bin/kubectl delete -f test.yaml
#将Docker镜像重新发布到K8S集群
/usr/bin/kubectl apply -f test.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;编辑整理 &lt;a href=&#34;https://www.jianshu.com/u/b1e8818c1241&#34;&gt;冰河团队&lt;/a&gt; &lt;a href=&#34;https://www.jianshu.com/p/86d288ea64c4&#34;&gt;From&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;i-class-fa-solid-fa-school-i-系列教程&#34;&gt;&lt;i class=&#34;fa-solid fa-school&#34;&gt;&lt;/i&gt;&lt;strong&gt;系列教程&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;/atom.xml&#34;&gt;&lt;i class=&#34;fa-solid fa-square-rss&#34;&gt;&lt;/i&gt;全部文章RSS订阅&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;i-class-fa-brands-fa-dev-i-Devops系列&#34;&gt;&lt;i class=&#34;fa-brands fa-dev&#34;&gt;&lt;/i&gt;&lt;strong&gt;Devops系列&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;/categories/devops/atom.xml&#34;&gt;&lt;i class=&#34;fa-solid fa-square-rss&#34;&gt;&lt;/i&gt;&lt;strong&gt;Devops 分类 RSS 订阅&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;/posts/ab63eb8f/&#34;&gt;自建全套开源Devops开发系统&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/d32a07a7/&#34;&gt;Git介绍以及分支模型图解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/39563241/&#34;&gt;三万字无坑搭建基于Docker+K8S+GitLab/SVN+Jenkins+Harbor持续集成交付环境&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/3437994a/&#34;&gt;DevOps系列—【Jenkinsfile+Dockerfile+nginx+vue】&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/f4c3ad41/&#34;&gt;项目开发管理工具推荐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/acc13b70/&#34;&gt;Gitlab的安装及使用教程完全版&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/d08eb7b/&#34;&gt;Gitlab的安装及使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/78c3371/&#34;&gt;那些有用的Github工具介绍！Action、app、workflow等&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="gitlab" />
        <category term="docker" />
        <category term="k8s" />
        <category term="harbor" />
        <updated>2022-04-16T10:49:57.000Z</updated>
    </entry>
    <entry>
        <id>https://blog.17lai.site/posts/3437994a/</id>
        <title>DevOps系列---【Jenkinsfile+Dockerfile+nginx+vue】</title>
        <link rel="alternate" href="https://blog.17lai.site/posts/3437994a/"/>
        <content type="html">&lt;h2 id=&#34;1-前提：一台装好的jenkins&#34;&gt;1.前提：一台装好的jenkins&lt;/h2&gt;
&lt;p&gt;参考:&lt;a href=&#34;https://www.cnblogs.com/hujunwei/p/13176994.html&#34;&gt;https://www.cnblogs.com/hujunwei/p/13176994.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-编写Dockerfile，放在项目根目录下&#34;&gt;2.编写Dockerfile，放在项目根目录下&lt;/h2&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-docker&#34; data-language=&#34;docker&#34;&gt;&lt;code class=&#34;language-docker&#34;&gt;FROM nginx
#修改名字、版本、作者
LABEL name=&#34;home-finance-web-dev&#34; version=&#34;1.0.0&#34; author=&#34;hjw&#34;
COPY dist/ /usr/share/nginx/html/
COPY nginx/nginx-dev.conf /etc/nginx/nginx.conf
EXPOSE 80&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h2 id=&#34;3-编写Jenkinsfile，放在项目根目录下&#34;&gt;3.编写Jenkinsfile，放在项目根目录下&lt;/h2&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-yaml&#34; data-language=&#34;yaml&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;//流水线脚本
pipeline {
    agent any
    environment {
        WS = &#34;${WORKSPACE}&#34;
        TOPIC = &#34;测试&#34;
        TITLE = &#34;标题&#34;
        CONTENT = &#34;具体内容&#34;
    }

    //定义流水线的加工流程
    stages {
        stage(&#39;环境检查&#39;) {
            steps{
                sh &#39;printenv&#39;
                echo &#34;正在检测基本信息&#34;
                sh &#39;git --version&#39;
                sh &#39;docker version&#39;
            }
        }

        stage(&#39;编译&#39;) {
            //jenkins不配置任何环境的情况下可以兼容任何场景
            agent {
                docker { image &#39;node:14.17.6-alpine3.13&#39; }
            }
            steps{
                sh &#39;node -v&#39;
                sh &#39;npm -v&#39;
                sh &#39;pwd &amp;amp;&amp;amp; ls -alh&#39;
                sh &#39;echo &#34;默认的项目目录:${WS}&#34;&#39;
                //注意:cd ${WS} &amp;amp;&amp;amp; npm不能分开写，也不能直接用${WORKSPACE}
                sh &#39;cd ${WS}/fast-ui &amp;amp;&amp;amp; npm config set registry=https://registry.npm.taobao.org &amp;amp;&amp;amp; npm install -g cnpm --registry=https://registry.npm.taobao.org &amp;amp;&amp;amp; cnpm install &amp;amp;&amp;amp; cnpm run build&#39;
            }
        }

        stage(&#39;生成镜像&#39;) {
            steps{
                sh &#39;pwd &amp;amp;&amp;amp; ls -alh&#39;
                echo &#39;生成镜像&#39;
                sh &#39;docker version&#39;
                sh &#34;echo 默认的项目目录:${WS}&#34;
                sh &#39;cd ${WS}/fast-ui &amp;amp;&amp;amp; docker build -t home-finance-web .&#39;
            }
        }

        stage(&#39;部署&#39;) {
            steps{
                echo &#39;部署....&#39;
                sh &#39;pwd &amp;amp;&amp;amp; ls -alh&#39;
                sh &#39;pwd &amp;amp;&amp;amp; ls -alh&#39;
                sh &#39;docker rm -f home-finance-web&#39;
                sh &#39;docker run -d -p 8081:80 --restart=always --name home-finance-web home-finance-web&#39;
            }
        }
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h2 id=&#34;4-编写nginx-dev-conf-放在项目根目录下的nginx目录下&#34;&gt;4.编写nginx-dev.conf,放在项目根目录下的nginx目录下&lt;/h2&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-nginx&#34; data-language=&#34;nginx&#34;&gt;&lt;code class=&#34;language-nginx&#34;&gt;user  nginx;
worker_processes  1;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &#34;$request&#34; &#39;
                      &#39;$status $body_bytes_sent &#34;$http_referer&#34; &#39;
                      &#39;&#34;$http_user_agent&#34; &#34;$http_x_forwarded_for&#34;&#39;;

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;

    # include /etc/nginx/conf.d/*.conf;

    server {
        listen       80;
        server_name  101.43.159.8; # 服务器地址或绑定域名

        #charset koi8-r;
        #access_log  /var/log/nginx/host.access.log  main;

        # =========================================================
        # ================== ↓↓↓↓↓↓ start ↓↓↓↓↓↓ ==================
        # =========================================================

        location / {
            root   /usr/share/nginx/html;
            #try_files $uri $uri/ @router;
            index  index.html index.htm;
            try_files $uri $uri/ /index.html; # 解决页面刷新 404 问题
            #proxy_pass http://zhengqingya.gitee.io; # 代理的ip地址和端口号
            #proxy_connect_timeout 600; #代理的连接超时时间（单位：毫秒）
            #proxy_read_timeout 600; #代理的读取资源超时时间（单位：毫秒）
        }

        # =========================================================
        # ================== ↑↑↑↑↑↑ end ↑↑↑↑↑↑ ==================
        # =========================================================

        #error_page  404              /404.html;

        # redirect server error pages to the static page /50x.html
        #
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   /usr/share/nginx/html;
        }

    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;编辑整理 &lt;a href=&#34;https://www.cnblogs.com/hujunwei/p/15957956.html&#34;&gt;hujunwei&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;i-class-fa-solid-fa-school-i-系列教程&#34;&gt;&lt;i class=&#34;fa-solid fa-school&#34;&gt;&lt;/i&gt;&lt;strong&gt;系列教程&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;/atom.xml&#34;&gt;&lt;i class=&#34;fa-solid fa-square-rss&#34;&gt;&lt;/i&gt;全部文章RSS订阅&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;i-class-fa-brands-fa-dev-i-Devops系列&#34;&gt;&lt;i class=&#34;fa-brands fa-dev&#34;&gt;&lt;/i&gt;&lt;strong&gt;Devops系列&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;/categories/devops/atom.xml&#34;&gt;&lt;i class=&#34;fa-solid fa-square-rss&#34;&gt;&lt;/i&gt;&lt;strong&gt;Devops 分类 RSS 订阅&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;/posts/ab63eb8f/&#34;&gt;自建全套开源Devops开发系统&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/d32a07a7/&#34;&gt;Git介绍以及分支模型图解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/39563241/&#34;&gt;三万字无坑搭建基于Docker+K8S+GitLab/SVN+Jenkins+Harbor持续集成交付环境&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/3437994a/&#34;&gt;DevOps系列—【Jenkinsfile+Dockerfile+nginx+vue】&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/f4c3ad41/&#34;&gt;项目开发管理工具推荐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/acc13b70/&#34;&gt;Gitlab的安装及使用教程完全版&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/d08eb7b/&#34;&gt;Gitlab的安装及使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/78c3371/&#34;&gt;那些有用的Github工具介绍！Action、app、workflow等&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="nginx" />
        <category term="jenkins" />
        <category term="devops" />
        <updated>2022-04-15T10:49:37.000Z</updated>
    </entry>
    <entry>
        <id>https://blog.17lai.site/posts/f4c3ad41/</id>
        <title>项目开发管理工具推荐</title>
        <link rel="alternate" href="https://blog.17lai.site/posts/f4c3ad41/"/>
        <content type="html">&lt;blockquote&gt;
&lt;p&gt;软件开发是复杂的创造性的劳动，需要依赖大量工具才能完成，因此想要提高软件开发的效率和质量，离不开强大、高效、易用、维护成本低的工具，下面我根据自己的经验，推荐一些好用的工具。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;即时通讯&#34;&gt;即时通讯&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;更推荐自建开源替代。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;即时通讯和会议系统是项目开发过程中必不可少的，尤其是远程办公时，会议系统更是不可或缺。企业微信拥有和微信一致的沟通体验，简单易用。企业微信可随时随地发起和参与音视频会议，支持300人同时参会，并为主持人提供了管理功能。发言时还可演示文档或电脑屏幕，支持实时标注演示内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/04/1520220415205156.png&#34; alt=&#34;gitea&#34;&gt;&lt;/p&gt;
&lt;p&gt;官方网站：&lt;a href=&#34;https://work.weixin.qq.com/&#34;&gt;https://work.weixin.qq.com/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;项目管理&#34;&gt;项目管理&lt;/h2&gt;
&lt;p&gt;目前主流的项目管理通常采用敏捷开发的模式，因此项目管理工具也要选择支持敏捷开发模式的工具，不建议使用禅道这样的重流程的工具，不适合敏捷团队，这里我推荐Taiga，它设计简洁，操作简单，充分体现了敏捷开发的理念。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/04/1520220415211820.png&#34; alt=&#34;gitea&#34;&gt;&lt;/p&gt;
&lt;p&gt;官方网站：&lt;a href=&#34;https://taiga.io/&#34;&gt;https://taiga.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在线体验：&lt;a href=&#34;https://tree.taiga.io/&#34;&gt;https://tree.taiga.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;体验版服务器在国外，访问可能会有点慢。&lt;/p&gt;
&lt;h2 id=&#34;代码托管&#34;&gt;代码托管&lt;/h2&gt;
&lt;p&gt;前几年使用的比较多是SVN，近几年基本都使用GIT了，开源项目大都使用Github，虽然免费，但国内访问不稳定，速度慢，因此国内的公司基本都会自己搭建，我先后为公司搭建过两个托管平台，一个是Gitlab，一个是Gitea，Gitlab功能比较全面，但对硬件资源要求比较高，而且性能一般。所以推荐使用另一个开源的git托管平台——Gitea。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/04/1520220415212537.png&#34; alt=&#34;gitea&#34;&gt;&lt;/p&gt;
&lt;p&gt;官方网站：&lt;a href=&#34;https://gitea.io/&#34;&gt;https://gitea.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在线体验：&lt;a href=&#34;https://gitea.com/&#34;&gt;https://gitea.com&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;持续交付&#34;&gt;持续交付&lt;/h2&gt;
&lt;p&gt;最知名、使用最广泛的开源的持续集成、交付平台当属Jenkins，主要的优势在于有大量免费的插件可以使用，但实际使用发现，很多插件质量很差，配置项很多，真正想要落地，其实需要自己编写shell脚本。这里我推荐基于docker技术的一款现代化的持续交付平台DroneCI，它使用简单，可以和主流的Git代码托管平台无缝对接，并且不需要编写代码就可以满足大多数持续构建、交付的需求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/04/1520220415212440.png&#34; alt=&#34;gitea&#34;&gt;&lt;/p&gt;
&lt;p&gt;官方网站：&lt;a href=&#34;https://drone.io/&#34;&gt;https://drone.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在线体验：&lt;a href=&#34;https://cloud.drone.io/&#34;&gt;https://cloud.drone.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;体验版服务器在国外，访问可能会有点慢。&lt;/p&gt;
&lt;h2 id=&#34;制品库-本地仓库&#34;&gt;制品库(本地仓库)&lt;/h2&gt;
&lt;p&gt;Maven 仓库是项目中依赖的第三方库，这个库所在的位置叫做仓库。Maven 仓库能帮助我们管理构件（主要是JAR），它就是放置所有JAR文件（WAR，ZIP，POM等等）的地方。&lt;/p&gt;
&lt;p&gt;后来，除了Maven仓库，还有npm、nuget、pypi、docker等仓库也需要本地仓库。&lt;/p&gt;
&lt;p&gt;市面上可选的通用的本地仓库有：nexus、ARTIFACTORY，ARTIFACTORY是收费的，nexus是免费的，同时nexus以其易用性和可靠性，成为目前市场上最主流的本地仓库。&lt;/p&gt;
&lt;p&gt;官方网站：&lt;a href=&#34;https://www.sonatype.com/product-nexus-repository&#34;&gt;https://www.sonatype.com/product-nexus-repository&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;文件存储&#34;&gt;文件存储&lt;/h2&gt;
&lt;p&gt;在公司中，文件分享是一个很常用的功能，不同于云盘，他对性能和安全性没有那么高的要求，简单易用才是大家最关心的，这里推荐chfs，chfs是一个免费的、HTTP协议的文件共享服务器，使用浏览器可以快速访问。与其他常用文件共享方式（如FTP，飞秋，网盘，自己建站）相比，具有使用简单，适用场景更多的优点，在个人使用以及共享给他人的场景中非常方便快捷。&lt;/p&gt;
&lt;p&gt;官方网站：&lt;a href=&#34;http://iscute.cn/chfs&#34;&gt;http://iscute.cn/chfs&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;绘图-流程图、UML、思维导图&#34;&gt;绘图(流程图、UML、思维导图)&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://draw.io&#34;&gt;draw.io&lt;/a&gt; 是一个强大简洁的在线的绘图网站，支持流程图，UML图，架构图，原型图等。支持Github，Google Drive, One drive等网盘同步，并且永久免费。如果觉得使用Web版不方便，&lt;a href=&#34;http://draw.io&#34;&gt;draw.io&lt;/a&gt; 也提供了多平台的离线桌面版可供下载。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/04/1520220415205300.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;在线版：&lt;a href=&#34;https://www.draw.io/&#34;&gt;https://www.draw.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本地部署版：&lt;a href=&#34;https://github.com/jgraph/drawio/releases/latest&#34;&gt;https://github.com/jgraph/drawio/releases/latest&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PC 安装版：&lt;a href=&#34;https://github.com/jgraph/drawio-desktop/releases/latest&#34;&gt;https://github.com/jgraph/drawio-desktop/releases/latest&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;接口管理&#34;&gt;接口管理&lt;/h2&gt;
&lt;p&gt;维护不同工具之间数据一致性非常困难、低效。并且这里不仅仅是工作量的问题，更大的问题是多个系统之间数据不一致，导致协作低效、频繁出问题，开发测试人员痛苦不堪。&lt;/p&gt;
&lt;p&gt;Apifox 是接口管理、开发、测试全流程集成工具，定位 Postman + Swagger + Mock + JMeter。通过一套系统、一份数据，解决多个系统之间的数据同步问题。只要定义好接口文档，接口调试、数据 Mock、接口测试就可以直接使用，无需再次定义；接口文档和接口开发调试使用同一个工具，接口调试完成后即可保证和接口文档定义完全一致。高效、及时、准确！&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/04/1520220415205213.svg+xml&#34; alt=&#34;gitea&#34;&gt;&lt;/p&gt;
&lt;p&gt;官方网站：&lt;a href=&#34;https://www.apifox.cn/&#34;&gt;https://www.apifox.cn&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;安全测试&#34;&gt;安全测试&lt;/h2&gt;
&lt;p&gt;在今天，网站的安全是容易被忽视的，黑客具备广泛的攻击手段，例如SQL注入，XSS，文件包含，目录遍历，参数篡改，认证攻击等，虽然你配置了正确的防火墙和WAF，但是这些安全防御软件仍然存在策略性的绕过。因此，需要您定期的扫描你的web应用，但是手动检测你所有的web应用是否存在安全漏洞比较复杂和费时，所以您需要一款自动化的web漏洞扫描工具来检测您的web应用是否存在安全漏洞。&lt;/p&gt;
&lt;p&gt;Acunetix Web Vulnerability Scanner（简称AWVS）是一款知名的Web网络漏洞扫描工具，它通过网络爬虫测试你的网站安全，检测流行安全漏洞。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/04/1520220415205220.svg+xml&#34; alt=&#34;awvs&#34;&gt;&lt;/p&gt;
&lt;p&gt;官方网站：&lt;a href=&#34;https://www.acunetix.com/&#34;&gt;https://www.acunetix.com&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;性能测试&#34;&gt;性能测试&lt;/h2&gt;
&lt;p&gt;Locust是一个用于可扩展的，分布式的，性能测试的，开源的，用Python编写框架/工具，它非常容易使用，也非常好学。&lt;/p&gt;
&lt;p&gt;它的主要思想就是模拟一群用户将访问你的网站。每个用户的行为由你编写的python代码定义，同时可以从Web界面中实时观察到用户的行为。&lt;/p&gt;
&lt;p&gt;Locust完全是事件驱动的，因此在单台机器上能够支持几千并发用户访问。&lt;/p&gt;
&lt;p&gt;与其它许多基于事件的应用相比，Locust并不使用回调，而是使用gevent，而gevent是基于协程的，可以用同步的方式来编写异步执行的代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/04/1520220415205227.png&#34; alt=&#34;awvs&#34;&gt;&lt;/p&gt;
&lt;p&gt;官方网站：&lt;a href=&#34;https://www.locust.io/&#34;&gt;https://www.locust.io&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;代码静态分析平台&#34;&gt;代码静态分析平台&lt;/h2&gt;
&lt;p&gt;SonarQube 是一款用于代码质量管理的开源工具，它主要用于管理源代码的质量。 通过插件形式，可以支持众多计算机语言，比如 java, C#, go，C/C++, PL/SQL, Cobol, JavaScrip, Groovy 等。sonar可以通过PMD,CheckStyle,Findbugs等等代码规则检测工具来检测你的代码，帮助你发现代码的漏洞，Bug，异味等信息。&lt;/p&gt;
&lt;p&gt;Sonar 不仅提供了对 IDE 的支持，可以在 Eclipse和 IntelliJ IDEA 这些工具里联机查看结果；同时 Sonar 还对大量的持续集成工具提供了接口支持，可以很方便地在持续集成中使用 Sonar&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/04/1520220415205228.svg&#34; alt=&#34;awvs&#34;&gt;&lt;/p&gt;
&lt;p&gt;官方网站：&lt;a href=&#34;https://www.sonarqube.org/&#34;&gt;https://www.sonarqube.org&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;i-class-fa-solid-fa-school-i-系列教程&#34;&gt;&lt;i class=&#34;fa-solid fa-school&#34;&gt;&lt;/i&gt;&lt;strong&gt;系列教程&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;/atom.xml&#34;&gt;&lt;i class=&#34;fa-solid fa-square-rss&#34;&gt;&lt;/i&gt;全部文章RSS订阅&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;i-class-fa-brands-fa-dev-i-Devops系列&#34;&gt;&lt;i class=&#34;fa-brands fa-dev&#34;&gt;&lt;/i&gt;&lt;strong&gt;Devops系列&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;/categories/devops/atom.xml&#34;&gt;&lt;i class=&#34;fa-solid fa-square-rss&#34;&gt;&lt;/i&gt;&lt;strong&gt;Devops 分类 RSS 订阅&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;/posts/ab63eb8f/&#34;&gt;自建全套开源Devops开发系统&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/d32a07a7/&#34;&gt;Git介绍以及分支模型图解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/39563241/&#34;&gt;三万字无坑搭建基于Docker+K8S+GitLab/SVN+Jenkins+Harbor持续集成交付环境&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/3437994a/&#34;&gt;DevOps系列—【Jenkinsfile+Dockerfile+nginx+vue】&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/f4c3ad41/&#34;&gt;项目开发管理工具推荐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/acc13b70/&#34;&gt;Gitlab的安装及使用教程完全版&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/d08eb7b/&#34;&gt;Gitlab的安装及使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/78c3371/&#34;&gt;那些有用的Github工具介绍！Action、app、workflow等&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="ci/cd" />
        <category term="devops" />
        <updated>2022-04-15T10:48:59.000Z</updated>
    </entry>
    <entry>
        <id>https://blog.17lai.site/posts/acc13b70/</id>
        <title>Gitlab的安装及使用教程完全版</title>
        <link rel="alternate" href="https://blog.17lai.site/posts/acc13b70/"/>
        <content type="html">&lt;h2 id=&#34;1-Gitlab概述&#34;&gt;1. Gitlab概述&lt;/h2&gt;
&lt;hr&gt;
&lt;h3 id=&#34;1-1-GitLab介绍&#34;&gt;1.1 GitLab介绍&lt;/h3&gt;
&lt;p&gt;GitLab是利用Ruby on Rails一个开源的版本管理系统，实现一个自托管的Git项目仓库，可通过Web界面进行访问公开的或者私人项目。&lt;/p&gt;
&lt;p&gt;GitLab能够浏览源代码，管理缺陷和注释。可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。团队成员可以利用内置的简单聊天程序(Wall)进行交流。&lt;/p&gt;
&lt;p&gt;它还提供一个代码片段收集功能可以轻松实现代码复用，便于日后有需要的时候进行查找&lt;/p&gt;
&lt;h3 id=&#34;1-2-Gitlab服务构成&#34;&gt;1.2 Gitlab服务构成&lt;/h3&gt;
&lt;p&gt;Nginx：静态web服务器。&lt;/p&gt;
&lt;p&gt;gitlab-shell：用于处理Git命令和修改authorized keys列表。&lt;/p&gt;
&lt;p&gt;gitlab-workhorse: 轻量级的反向代理服务器。&lt;/p&gt;
&lt;p&gt;logrotate：日志文件管理工具。&lt;/p&gt;
&lt;p&gt;postgresql：数据库。&lt;/p&gt;
&lt;p&gt;redis：缓存数据库。&lt;/p&gt;
&lt;p&gt;sidekiq：用于在后台执行队列任务（异步执行）。&lt;/p&gt;
&lt;p&gt;unicorn：An HTTP server for Rack applications，GitLab Rails应用是托管在这个服务器上面的。&lt;/p&gt;
&lt;h3 id=&#34;1-3-Gitlab工作流程&#34;&gt;1.3 Gitlab工作流程&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/05/2820210528222044.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-4-GitLab-Shell&#34;&gt;1.4 GitLab Shell&lt;/h3&gt;
&lt;p&gt;GitLab Shell有两个作用：为GitLab处理Git命令、修改authorized keys列表&lt;/p&gt;
&lt;p&gt;当通过SSH访问GitLab Server时，GitLab Shell会：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;限制执行预定义好的Git命令（git push，git pull，git annex）&lt;/li&gt;
&lt;li&gt;调用GitLab Rails API检查权限&lt;/li&gt;
&lt;li&gt;执行pre-receive钩子（在企业版中叫做Git钩子）&lt;/li&gt;
&lt;li&gt;执行用户请求的动作，处理GitLab的post-receive动作&lt;/li&gt;
&lt;li&gt;处理自定义的post-receive动作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当通过http(s)访问GitLab Server时，工作流程取决于你是从Git仓库拉取(pull)代码还是向git仓库推送(push)代码：&lt;/p&gt;
&lt;p&gt;如果是从Git仓库拉取(pull)代码，GitLab Rails应用会全权负责处理用户鉴权和执行Git命令的工作&lt;/p&gt;
&lt;p&gt;如果是向Git仓库推送(push)代码，GitLab Rails应用既不会进行用户鉴权也不会执行Git命令，它会把以下工作交由GitLab Shell进行处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用GitLab Rails API 检查权限&lt;/li&gt;
&lt;li&gt;执行pre-receive钩子（在GitLab企业版中叫做Git钩子）&lt;/li&gt;
&lt;li&gt;执行你请求的动作&lt;/li&gt;
&lt;li&gt;处理GitLab的post-receive动作&lt;/li&gt;
&lt;li&gt;处理自定义的post-receive动作&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-5-GitLab-Workhorse&#34;&gt;1.5 GitLab Workhorse&lt;/h3&gt;
&lt;p&gt;GitLab Workhorse是一个敏捷的反向代理。它会处理一些大的HTTP请求，比如文件上传、文件下载、Git push/pull和Git包下载。其它请求会反向代理到GitLab Rails应用，即反向代理给后端的unicorn。&lt;/p&gt;
&lt;h2 id=&#34;2-Gitlab的安装部署&#34;&gt;2. Gitlab的安装部署&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Gitlab要求服务器内存2G以上&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-1-方式一-下载gitlab-ce的rpm包&#34;&gt;2.1 方式一:下载gitlab-ce的rpm包&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://packages.gitlab.com/gitlab/gitlab-ce&#34;&gt;gitlab官方rpm包下载&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/&#34;&gt;清华的源&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将对应版本的gitlab-ce下载到本地后，直接yum安装即可&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;# 要先将这个rpm包下载到本地
yum install -y gitlab-ce-13.6.1-ce.0.el7.x86_64.rpm&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;2-2-方式二-配置yum源&#34;&gt;2.2 方式二:配置yum源&lt;/h3&gt;
&lt;p&gt;在 /etc/yum.repos.d/ 下新建 gitlab-ce.repo，写入如下内容：&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;[gitlab-ce]
name=gitlab-ce
baseurl=https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/
Repo_gpgcheck=0
Enabled=1
Gpgkey=https://packages.gitlab.com/gpg.key&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;然后创建cache，再直接安装gitlab-ce&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;yum makecache  # 这一步会创建大量的数据
 
# 直接安装最新版
yum install -y gitlab-ce
 
# 如果要安装指定的版本，在后面填上版本号即可
yum install -y  gitlab-ce-13.6.1
 
# 如果安装时出现gpgkey验证错误，只需在安装时明确指明不进行gpgkey验证
yum install gitlab-ce -y --nogpgcheck&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;2-2-1-单服务启动模式&#34;&gt;&lt;strong&gt;2.2.1. 单服务启动模式&lt;/strong&gt;&lt;/h3&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run -d --name gitlab --hostname gitlab.example.com \
-e GITLAB_OMNIBUS_CONFIG=&#34;
    external_url &#39;https://gitlab.example.com&#39;
    gitlab_rails[&#39;gitlab_shell_ssh_port&#39;] = 22
    nginx[&#39;redirect_http_to_https&#39;] = true
    nginx[&#39;ssl_dhparam&#39;] = &#39;/etc/gitlab/ssl/dhparam.pem&#39;
    nginx[&#39;ssl_certificate&#39;] = &#39;/etc/gitlab/ssl/domain.crt&#39;
    nginx[&#39;ssl_certificate_key&#39;] = &#39;/etc/gitlab/ssl/domain.key&#39;
    nginx[&#39;custom_gitlab_server_config&#39;] = &#39;location ^~ /.well-known {\n alias /var/opt/gitlab/letsencrypt/.well-known;\n}\n&#39;
    high_availability[&#39;mountpoint&#39;] = [&#39;/etc/gitlab&#39;, &#39;/var/log/gitlab&#39; &#39;/var/opt/gitlab&#39;  # 严格限定gitlab服务启动前，指定文件系统挂完毕
&#34; \
-p 22:22 -p 80:80 -p 443:443 \
-v /srv/gitlab/config:/etc/gitlab \
-v /srv/gitlab/logs:/var/log/gitlab \
-v /srv/gitlab/data:/var/opt/gitlab \
-v /etc/certs:/etc/gitlab/ssl \
--restart=always gitlab/gitlab-ce:latest
 &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;2-2-1-Compose服务编排模式-推荐方式&#34;&gt;&lt;strong&gt;2.2.1. Compose服务编排模式(推荐方式)&lt;/strong&gt;&lt;/h3&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;docker pull gitlab/gitlab-ce:latest
 
############################ 多行命令开始 ##########################
cat &amp;gt; docker-compose.yaml &amp;lt;&amp;lt;EOF
version: &#39;2&#39;
 
services:
 
  Gitlab:
    image: &#39;gitlab/gitlab-ce:latest&#39;
    container_name: &#39;gitlab&#39;
    hostname: &#39;gitlab.example.com&#39;
    restart: always
    ports:
      - &#39;22:22&#39;
      - &#39;80:80&#39;
      - &#39;443:443&#39;
    environment:
      GITLAB_OMNIBUS_CONFIG: |
        # Add any other gitlab.rb configuration here, each on its own line
        external_url &#39;https://gitlab.example.com&#39;
        gitlab_rails[&#39;gitlab_shell_ssh_port&#39;] = 22
        nginx[&#39;redirect_http_to_https&#39;] = true
        nginx[&#39;ssl_dhparam&#39;] = &#34;/etc/gitlab/ssl/dhparam.pem&#34;
        nginx[&#39;ssl_certificate&#39;] = &#34;/etc/gitlab/ssl/domain.crt&#34;
        nginx[&#39;ssl_certificate_key&#39;] = &#34;/etc/gitlab/ssl/domain.key&#34;
        nginx[&#39;custom_gitlab_server_config&#39;] = &#34;location ^~ /.well-known {\n alias /var/opt/gitlab/letsencrypt/.well-known;\n}\n&#34;
        high_availability[&#39;mountpoint&#39;] = [&#34;/etc/gitlab&#34;, &#34;/var/log/gitlab&#34;, &#34;/var/opt/gitlab&#34;]  # 严格限定gitlab服务启动前，指定文件系统挂完毕
    volumes:
      - /srv/gitlab/config:/etc/gitlab
      - /srv/gitlab/logs:/var/log/gitlab
      - /srv/gitlab/data:/var/opt/gitlab
      - /etc/certs:/etc/gitlab/ssl
EOF
############################ 多行命令结束 ##########################
 
# 启动服务
docker-compose -f docker-compose.yaml up -d
 &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;2-3-gitlab的配置&#34;&gt;2.3 gitlab的配置&lt;/h3&gt;
&lt;p&gt;配置文件位置  /etc/gitlab/gitlab.rb&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@centos7 test]# vim /etc/gitlab/gitlab.rb
 
[root@centos7 test]# grep &#34;^[a-Z]&#34; /etc/gitlab/gitlab.rb
 
external_url &#39;http://10.0.0.51&#39;  # 这里一定要加上http://
 
# 配置邮件服务
gitlab_rails[&#39;smtp_enable&#39;] = true
gitlab_rails[&#39;smtp_address&#39;] = &#34;smtp.qq.com&#34;
gitlab_rails[&#39;smtp_port&#39;] = 25
gitlab_rails[&#39;smtp_user_name&#39;] = &#34;hgzerowzh@qq.com&#34;  # 自己的qq邮箱账号
gitlab_rails[&#39;smtp_password&#39;] = &#34;xxx&#34;  # 开通smtp时返回的授权码
gitlab_rails[&#39;smtp_domain&#39;] = &#34;qq.com&#34;
gitlab_rails[&#39;smtp_authentication&#39;] = &#34;login&#34;
gitlab_rails[&#39;smtp_enable_starttls_auto&#39;] = true
gitlab_rails[&#39;smtp_tls&#39;] = false
gitlab_rails[&#39;gitlab_email_from&#39;] = &#34;hgzerowzh@qq.com&#34;  # 指定发送邮件的邮箱地址
user[&#34;git_user_email&#34;] = &#34;shit@qq.com&#34;   # 指定接收邮件的邮箱地址&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;修改好配置文件后，要使用 gitlab-ctl reconfigure 命令重载一下配置文件，否则不生效。&lt;/strong&gt;&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;gitlab-ctl reconfigure # 重载配置文件
gitlab-ctl restart&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h4 id=&#34;测试邮件服务器&#34;&gt;测试邮件服务器&lt;/h4&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;gitlab-rails console
Notify.test_email(&#39;rollinghell@foxmail.com&#39;,&#39;testbiaoti&#39;,&#39;testzhegnwen1&#39;).deliver_now&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@test102 ~]# gitlab-rails console
--------------------------------------------------------------------------------
 GitLab:       12.5.0 (1f0ab8978ef)
GitLab Shell: 10.2.0
 PostgreSQL:   10.9
--------------------------------------------------------------------------------
Loading production environment (Rails 5.2.3)
irb(main):001:0&amp;gt; Notify.test_email(&#39;andycrusoe@gmail.com&#39;,&#39;test&#39;,&#39;test&#39;).deliver_now
Notify#test_email: processed outbound mail in 1.4ms
Sent mail to anliven@126.com (73.0ms)
Date: Wed, 27 Nov 2019 15:12:58 +0800
From: GitLab &amp;lt;gitlab@192.168.16.102&amp;gt;
Reply-To: GitLab &amp;lt;noreply@192.168.16.102&amp;gt;
To: anliven@126.com
Message-ID: &amp;lt;5dde21fa612d4_3a1b3fcb38fcf9c0651b@test102.mail&amp;gt;
Subject: test
Mime-Version: 1.0
Content-Type: text/html;
charset=UTF-8
Content-Transfer-Encoding: 7bit
Auto-Submitted: auto-generated
X-Auto-Response-Suppress: All
&amp;lt;!DOCTYPE html PUBLIC &#34;-//W3C//DTD HTML 4.0 Transitional//EN&#34; &#34;http://www.w3.org/TR/REC-html40/loose.dtd&#34;&amp;gt;
&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;p&amp;gt;test&amp;lt;/p&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
=&amp;gt; #&amp;lt;Mail::Message:70141649239780, Multipart: false, Headers: &amp;lt;Date: Wed, 27 Nov 2019 15:12:58 +0800&amp;gt;, &amp;lt;From: GitLab &amp;lt;gitlab@192.168.16.102&amp;gt;&amp;gt;, &amp;lt;Reply-To: GitLab &amp;lt;noreply@192.168.16.102&amp;gt;&amp;gt;, &amp;lt;To: anliven@126.com&amp;gt;, &amp;lt;Message-ID: &amp;lt;5dde21fa612d4_3a1b3fcb38fcf9c0651b@test102.mail&amp;gt;&amp;gt;, &amp;lt;Subject: test&amp;gt;, &amp;lt;Mime-Version: 1.0&amp;gt;, &amp;lt;Content-Type: text/html; charset=UTF-8&amp;gt;, &amp;lt;Content-Transfer-Encoding: 7bit&amp;gt;, &amp;lt;Auto-Submitted: auto-generated&amp;gt;, &amp;lt;X-Auto-Response-Suppress: All&amp;gt;&amp;gt;
irb(main):002:0&amp;gt;
irb(main):003:0&amp;gt; exit
[root@test102 ~]#
 &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h4 id=&#34;配置gitlab代理&#34;&gt;配置gitlab代理&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.gitlab.com/omnibus/settings/environment-variables.html&#34;&gt;https://docs.gitlab.com/omnibus/settings/environment-variables.html&lt;/a&gt;&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-ruby&#34; data-language=&#34;ruby&#34;&gt;&lt;code class=&#34;language-ruby&#34;&gt;gitaly[&#39;env&#39;] = {
    &#34;http_proxy&#34; =&amp;gt; &#34;http://USERNAME:PASSWORD@example.com:8080&#34;,
    &#34;https_proxy&#34; =&amp;gt; &#34;http://USERNAME:PASSWORD@example.com:8080&#34;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;也可以使用单独模块代理&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-ruby&#34; data-language=&#34;ruby&#34;&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Needed for proxying Git clones
gitaly[&#39;env&#39;] = {
    &#34;http_proxy&#34; =&amp;gt; &#34;http://USERNAME:PASSWORD@example.com:8080&#34;,
    &#34;https_proxy&#34; =&amp;gt; &#34;http://USERNAME:PASSWORD@example.com:8080&#34;
}

gitlab_workhorse[&#39;env&#39;] = {
    &#34;http_proxy&#34; =&amp;gt; &#34;http://USERNAME:PASSWORD@example.com:8080&#34;,
    &#34;https_proxy&#34; =&amp;gt; &#34;http://USERNAME:PASSWORD@example.com:8080&#34;
}

gitlab_pages[&#39;env&#39;] = {
    &#34;http_proxy&#34; =&amp;gt; &#34;http://USERNAME:PASSWORD@example.com:8080&#34;,
    &#34;https_proxy&#34; =&amp;gt; &#34;http://USERNAME:PASSWORD@example.com:8080&#34;
}

# If you use the docker registry
registry[&#39;env&#39;] = {
    &#34;http_proxy&#34; =&amp;gt; &#34;http://USERNAME:PASSWORD@example.com:8080&#34;,
    &#34;https_proxy&#34; =&amp;gt; &#34;http://USERNAME:PASSWORD@example.com:8080&#34;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;应用生效 &lt;code&gt;gitlab-ctl reconfigure&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-4-Gitlab常用命令&#34;&gt;2.4 Gitlab常用命令&lt;/h3&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;gitlab-ctl start         # 启动所有 gitlab 组件
gitlab-ctl stop          # 停止所有 gitlab 组件
gitlab-ctl restart       # 重启所有 gitlab 组件
gitlab-ctl status        # 查看服务状态
 
gitlab-ctl reconfigure   # 启动服务
gitlab-ctl show-config   # 验证配置文件
 
gitlab-ctl tail          # 查看日志
 
gitlab-rake gitlab:check SANITIZE=true --trace    # 检查gitlab
 
vim /etc/gitlab/gitlab.rb # 修改默认的配置文件&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;2-5-gitlab-ctl常用命令介绍&#34;&gt;2.5 gitlab-ctl常用命令介绍&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:right&#34;&gt;命令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;check-config&lt;/td&gt;
&lt;td&gt;检查在gitlab中是否有任何配置。在指定版本中删除的rb&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;deploy-page&lt;/td&gt;
&lt;td&gt;安装部署页面&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;diff-config&lt;/td&gt;
&lt;td&gt;将用户配置与包可用配置进行比较&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;remove-accounts&lt;/td&gt;
&lt;td&gt;删除所有用户和组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;upgrade&lt;/td&gt;
&lt;td&gt;升级&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;service-list&lt;/td&gt;
&lt;td&gt;查看所有服务&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;once&lt;/td&gt;
&lt;td&gt;如果GitLab服务停止了就启动服务，如果已启动就不做任何操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;restart&lt;/td&gt;
&lt;td&gt;重启GitLab服务&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;start&lt;/td&gt;
&lt;td&gt;如果GitLab服务停止了就启动服务，如果已启动就重启服务&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;stop&lt;/td&gt;
&lt;td&gt;停止GitLab服务&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;status&lt;/td&gt;
&lt;td&gt;查看GitLab服务状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:right&#34;&gt;reconfigure&lt;/td&gt;
&lt;td&gt;重新配置GitLab并启动&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;3-Gitlab的使用&#34;&gt;3. Gitlab的使用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Gitlab安装好后，设置密码，管理账户为root&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-1-创建Group&#34;&gt;&lt;strong&gt;3.1 创建Group&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;填上组名即可，这里组名为java&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/05/2820210528222105.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802164637.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-2-创建User&#34;&gt;&lt;strong&gt;3.2 创建User&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;创建四个User：pm、dev1、dev2、dev3&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/05/2820210528222131.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/05/2820210528222120.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-3-添加User到Group中并授权&#34;&gt;&lt;strong&gt;3.3 添加User到Group中并授权&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/05/2820210528222140.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-4-创建Project并配置SSH&#34;&gt;&lt;strong&gt;3.4 创建Project并配置SSH&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/05/2820210528222147.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/05/2820210528222154.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/05/2820210528222201.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/05/2820210528222233.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-5-在项目中添加成员&#34;&gt;&lt;strong&gt;3.5 在项目中添加成员&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802164730.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802164804.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-6-将本地文件推送到Gitlab&#34;&gt;3.6 将本地文件推送到Gitlab&lt;/h3&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;# 将app01项目克隆下来
git clone git@10.0.0.51:java/app01.git
 
# 初始化配置
git config --global user.name &#34;hgzero&#34;
git config --global user.email &#34;hgzero@qq.com&#34;
 
# 在app01目录下新建一些文件
 
# 推送到gitlab
git add .
git commit -m &#34;first edition&#34;
git push origin master&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802164823.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;4-制定开发计划&#34;&gt;4. 制定开发计划&lt;/h2&gt;
&lt;h3 id=&#34;4-1-创建开发计划&#34;&gt;&lt;strong&gt;4.1 创建开发计划&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;项目：app01&lt;/li&gt;
&lt;li&gt;版本：v1.0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802173643.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;4-2-创建里程碑Milestones&#34;&gt;&lt;strong&gt;4.2 创建里程碑Milestones&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用pm账号登录gitlab后操作（先要在admin中设置pm账号的密码）&lt;/li&gt;
&lt;li&gt;要根据开发计划来创建Milestones&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802164839.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802164935.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802164956.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802165053.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;4-3-根据开发计划创建issue&#34;&gt;4.3 根据开发计划创建issue&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;创建4个issue，分派给dev1和dev2这两个开发人员&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802165109.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802165138.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802165158.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802165215.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802165238.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802165257.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;4-4-开发者登录账号查看分派的任务&#34;&gt;**4.4 开发者登录账号查看分派的任务 **&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;然后开发dev1登录gitlab，就能看到任务已经分配过来了&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802165316.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;4-5-开发流程&#34;&gt;&lt;strong&gt;4.5 开发流程&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;公司里的开发开始任务&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;# 1. 先从仓库把项目拉下来
git clone git@10.0.0.51:java/app01.git
cd app01/
 
# 2.先创建一个自己的分支，然后进行开发
git checkout -b index   # 创建一个叫index的分支，并切换到这个分支
git status
 
# 3. 开始开发首页
echo &#34;&amp;lt;h1&amp;gt;welcome to this app&amp;lt;/h1&amp;gt;&#34; &amp;gt; index.html  # 假设就开发了一个index页面
 
# 4. 开发完成后，把项目传到仓库
git add .
git commit -m &#34;index&#34;
# 如果写成 git commit -m &#34;close #2&#34; ，则表示merge请求允许且merge成功之后，自动删除编号为#2的issue
 
# 传到index分支
git push origin index&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;4-6-合并分支&#34;&gt;&lt;strong&gt;4.6 合并分支&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1）开发dev1发送合并分支请求给pm&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802165333.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802165341.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802165350.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）pm收到开发的Merge请求后进行处理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用pm登录，就可以看到pm已经收到了合并请求merge request&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802165452.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802165505.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802165423.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802164313.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3）开发dev1确认任务完成&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;退出pm账户，登入dev1账户：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802164301.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;或者点进去后，在侧边栏进行标识Done，然后已经完成的issue，可以将其Close&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802164248.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这个时候Milestones的进度已经往前进了一些了：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802164237.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;4-7-开发其他功能&#34;&gt;4.7 开发其他功能&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;然后其他开发者或者自己再次进行开发时，先要把刚刚更新后的内容（master主干）拉回来，然后再进行开发&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;git checkout master  # 切换到master&lt;br&gt;
git pull             # 从远端仓库拉取数据&lt;br&gt;
# 然后再进行其他操作&lt;/p&gt;
&lt;h2 id=&#34;5-Gitlab备份恢复&#34;&gt;5. Gitlab备份恢复&lt;/h2&gt;
&lt;h3 id=&#34;5-1-备份gitlab&#34;&gt;5.1 备份gitlab&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1）修改配置文件&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;/etc/gitlab/gitlab.rb&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;# 备份保存的位置，这里是默认位置，可修改成指定的位置
gitlab_rails[&#39;backup_path&#39;] = &#34;/var/opt/gitlab/backups&#34;
 
# 设置备份保存的时间，超过此时间的日志将会被新覆盖
gitlab_rails[&#39;backup_keep_time&#39;] = 604800  # 这里是默认设置，保存7天
 
# 特别注意：
#     如果自定义了备份保存位置，则要修改备份目录的权限，比如：
#     chown -R git.git /data/backup/gitlab&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;配置完成后要重启以使配置生效&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;# 重读配置文件
gitlab-ctl reconfigure
 
# 重启gitlab
gitlab-ctl restart&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;2）设置定时任务&lt;/strong&gt;&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;# 每天凌晨2点定时创建备份
# 将一下内容写入到定时任务中 crontab -e
0 2 * * * /usr/bin/gitlab-rake gitlab:backup:create
 
# 备份策略建议：
#     本地保留3到7天，在异地备份永久保存&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;3）备份时间的识别&lt;/strong&gt;&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;# 备份后的文件类似这样的形式：1494170842_gitlab_backup.tar，可以根据前面的时间戳确认备份生成的时间
 
data  -d  @1494170842&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;5-2-恢复gitlab&#34;&gt;5.2 恢复gitlab&lt;/h3&gt;
&lt;h4 id=&#34;1）停止停止相关数据连接-数据写入服务&#34;&gt;&lt;strong&gt;1）停止停止相关数据连接,数据写入服务&lt;/strong&gt;&lt;/h4&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;# 停止数据写入服务
gitlab-ctl stop puma
gitlab-ctl stop sidekiq&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h4 id=&#34;2）进行数据恢复并重启&#34;&gt;&lt;strong&gt;2）进行数据恢复并重启&lt;/strong&gt;&lt;/h4&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;# 进行恢复
gitlab-rake gitlab:backup:restore BACKUP=1627839447_2021_08_01_14.1.1-ee  # 这个时间戳就是刚刚备份的文件前面的时间戳
 
# 重启
gitlab-ctl restart&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h2 id=&#34;6-gitlab邮件通知配置&#34;&gt;6. gitlab邮件通知配置&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;vim  /etc/gitlab/gitlab.rb&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;gitlab_rails[&#39;time_zone&#39;] = &#39;Asia/Shanghai&#39;
 
gitlab_rails[&#39;gitlab_email_enabled&#39;] = true
gitlab_rails[&#39;gitlab_email_from&#39;] = &#39;example@163.com&#39; # 填写发件人的邮箱地址
gitlab_rails[&#39;gitlab_email_display_name&#39;] = &#39;gitlab&#39;
 
gitlab_rails[&#39;smtp_enable&#39;] = true
gitlab_rails[&#39;smtp_address&#39;] = &#34;smtp.163.com&#34;  # smtp服务器的地址,如网易的地址
gitlab_rails[&#39;smtp_port&#39;] = 25                 # 要注意如果使用了SSL/TLS的话,端口可能不是25
gitlab_rails[&#39;smtp_user_name&#39;] = &#34;smtp用户名&#34;
gitlab_rails[&#39;smtp_password&#39;] = &#34;smtp用户密码&#34;
gitlab_rails[&#39;smtp_domain&#39;] = &#34;163.com&#34;
gitlab_rails[&#39;smtp_authentication&#39;] = &#34;login&#34;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;启用邮件功能&lt;/strong&gt;&lt;br&gt;
Gitlab 的 Compose 配置 &lt;code&gt;GITLAB_OMNIBUS_CONFIG&lt;/code&gt; 节点下增加如下几行：&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;########## 邮件服务配置 ##########
gitlab_rails[&#39;smtp_enable&#39;] = true
gitlab_rails[&#39;smtp_address&#39;] = &#34;smtp.exmail.qq.com&#34;
gitlab_rails[&#39;smtp_port&#39;] = 465
gitlab_rails[&#39;smtp_tls&#39;] = true
gitlab_rails[&#39;smtp_user_name&#39;] = &#34;账号&#34;
gitlab_rails[&#39;smtp_password&#39;] = &#34;密码&#34;
gitlab_rails[&#39;smtp_authentication&#39;] = &#34;login&#34;
gitlab_rails[&#39;smtp_enable_starttls_auto&#39;] = true 
gitlab_rails[&#39;gitlab_email_from&#39;] = &#34;发件人邮箱&#34;
 &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h2 id=&#34;7-使用SourceTree进行项目开发&#34;&gt;7. 使用SourceTree进行项目开发&lt;/h2&gt;
&lt;hr&gt;
&lt;h3 id=&#34;7-1-项目拉取&#34;&gt;7.1 项目拉取&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;先把项目克隆下来&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802164210.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802164157.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果ssh的方式克隆失败，可能是因为SSH Key没找到，可以在这里添加&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802164146.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802164132.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;7-2-创建分支进行功能开发&#34;&gt;7.2 创建分支进行功能开发&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1）新建立一个叫“pay”的分支&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802164122.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802164113.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）进行功能开发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802164103.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;7-3-提交项目&#34;&gt;7.3 提交项目&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1）开发pay功能完成后进行提交&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以看到SourceTree中已经有“未提交的更改”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802164054.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802164042.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）添加“用户信息”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802164029.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;** 3）进行提交**&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802164014.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注释也可以写成  close #3    ，作用是提交完成后关闭3号issue&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;7-4-推送到仓库&#34;&gt;&lt;strong&gt;7.4 推送到仓库&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802164002.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802163947.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;然后就可以在gitlab上进行发送merge请求了，后面就可以进行其他操作了&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;7-5-项目上线&#34;&gt;7.5 项目上线&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1）当所有工作完成之后，就可以进行上线了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802163932.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）打标签&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;上线先打个标签&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802163916.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802163907.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/05/2820210528225256.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;** 3）删除无用分支**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;然后删除已经合并到主干中的不必要的分支，如index、pay等&lt;/li&gt;
&lt;li&gt;最后一定要注意时间一定要同步，不然会错乱&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;8-Gitlab调优&#34;&gt;&lt;strong&gt;8. Gitlab调优&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;gitlab对内存资源的消耗比较厉害&lt;br&gt;
其中尤以 sidekiq队列 及 unicorn服务 两个组件对内存消耗最多&lt;br&gt;
可以再容器启动时对相关参数进行微调：&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-yaml&#34; data-language=&#34;yaml&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;unicorn[&#39;worker_processes&#39;] = 1
unicorn[&#39;worker_memory_limit_min&#39;] = &#34;300 * 1 &amp;lt;&amp;lt; 20&#34;
unicorn[&#39;worker_memory_limit_max&#39;] = &#34;400 * 1 &amp;lt;&amp;lt; 20&#34;
unicorn[&#39;worker_timeout&#39;] = 15
sidekiq[&#39;concurrency&#39;] = 10
sidekiq_cluster[&#39;enable&#39;] = false
sidekiq_cluster[&#39;ha&#39;] = false
redis[&#39;maxclients&#39;] = &#34;100&#34;
nginx[&#39;worker_processes&#39;] = 2
nginx[&#39;worker_connections&#39;] = 512
nginx[&#39;keepalive_timeout&#39;] = 300
nginx[&#39;cache_max_size&#39;] = &#39;200m&#39;
mattermost[&#39;enable&#39;] = false
mattermost_nginx[&#39;enable&#39;] = false
gitlab_pages[&#39;enable&#39;] = false
pages_nginx[&#39;enable&#39;] = false
postgresql[&#39;shared_buffers&#39;] = &#34;256MB&#34;
postgresql[&#39;max_connections&#39;] = 30
postgresql[&#39;work_mem&#39;] = &#34;8MB&#34;
postgresql[&#39;maintenance_work_mem&#39;] = &#34;16MB&#34;
postgresql[&#39;effective_cache_size&#39;] = &#34;1MB&#34;
postgresql[&#39;checkpoint_timeout&#39;] = &#34;5min&#34;
postgresql[&#39;checkpoint_warning&#39;] = &#34;30s&#34;
 &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;配置调整后需要重载一下&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;docker exec gitlab gitlab-ctl reconfigure
docker-compose down
docker-compose up -d
 &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h2 id=&#34;9-Gitlab-启用-ContainerRegistry&#34;&gt;9. Gitlab 启用 ContainerRegistry&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ContainerRegistry&lt;/code&gt;是&lt;code&gt;Gitlab&lt;/code&gt;内置的&lt;code&gt;Docker Registry&lt;/code&gt;集成组件&lt;/li&gt;
&lt;li&gt;集成后每个项目可获得私有的 &lt;code&gt;Docker&lt;/code&gt; 镜像存储空间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ContainerRegistry&lt;/code&gt; 可以复用 &lt;code&gt;Gitlab&lt;/code&gt; 域名 或者 独立域名&lt;/li&gt;
&lt;li&gt;这里配置为复用域名（此时&lt;code&gt;ContainerRegistry&lt;/code&gt; 将复用 &lt;code&gt;Gitlab&lt;/code&gt; 的 &lt;code&gt;TLS&lt;/code&gt; 证书）&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;docker-compose.yaml&lt;/code&gt;中Gitlab服务的 &lt;code&gt;GITLAB_OMNIBUS_CONFIG&lt;/code&gt; 节点下增加如下配置：&lt;/li&gt;
&lt;/ol&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;registry_external_url &#34;https://gitlab.example.com:4567&#34;  # ContainerRegistry的外部访问地址
registry_nginx[&#39;ssl_certificate&#39;] = &#34;/etc/gitlab/ssl/domain.crt&#34;
registry_nginx[&#39;ssl_certificate_key&#39;] = &#34;/etc/gitlab/ssl/domain.key&#34;
gitlab_rails[&#39;registry_host&#39;] = &#34;gitlab.example.com&#34;
gitlab_rails[&#39;registry_port&#39;] = &#34;4567&#34;
gitlab_rails[&#39;registry_api_url&#39;] = &#34;http://localhost:5000&#34;
gitlab_rails[&#39;gitlab_default_projects_features_builds&#39;] = false
gitlab_rails[&#39;gitlab_default_projects_features_container_registry&#39;] = false
 &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;端口开放增加 &lt;code&gt;- 4567:4567&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;服务重启 &lt;code&gt;docker-compose restart Gitlab&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;ContainerRegistry&lt;/code&gt; 集成后可以通过 &lt;code&gt;Gitlab&lt;/code&gt; 账户登录： &lt;code&gt;docker login gitlab.example.com:4567&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;日常维护命令&#34;&gt;日常维护命令&lt;/h2&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;# Gitlab维护
docker exec gitlab gitlab-ctl status  # gitlab各组件服务状态
docker exec gitlab gitlab-ctl start/restart/stop [组件名]  # gitlab所有组件的统一控制（其中Unicorn组件重启完成前GitLab会报502）
docker exec gitlab gitlab-ctl tail [/var/log/gitlab下的某子目录]  # 实时查看日志
 
docker exec gitlab update-permissions  # 修复gitlab版本升级后出现的权限问题
docker exec gitlab gitlab-ctl reconfigure  # 重载配置
docker exec -t gitlab gitlab-rake gitlab:backup:create  # 创建备份
 
# ContainerRegistry维护
docker exec gitlab gitlab-ctl registry-garbage-collect  # 垃圾回收，清理废弃layer（registry停机）
 &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h3 id=&#34;Import-Repository-Repo-By-Url&#34;&gt;Import Repository(Repo By Url)&lt;/h3&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;# 账号密码若存在特殊字符则需要url编码
https://username:password@host:port/group/project.git
 &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h2 id=&#34;10-GitLab重置用户名密码&#34;&gt;&lt;strong&gt;10. GitLab重置用户名密码&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;打开终端，访问：&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;gitlab-rails console&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;输入：&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;user = User.where(id: 1).first
user.password=&#39;123456&#39;
user.password_confirmation = &#39;123456&#39;
user.save! #注意加上 “！”&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;然后退出命令行即可。&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;quit&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt; gitlab-rails console production 命令 开始初始化密码
# 在irb(main):001:0&amp;gt; 后面通过 u=User.where(id:1).first 来查找与切换账号（User.all 可以查看所有用户）
# 通过u.password=&#39;12345678&#39;设置密码为12345678(这里的密码看自己喜欢)：
# 通过u.password_confirmation=&#39;12345678&#39; 再次确认密码
# 通过 u.save!进行保存&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h2 id=&#34;11-HTTPS-SSL-支持&#34;&gt;&lt;strong&gt;11. HTTPS SSL 支持&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;nginx反向代理方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注意docker 内部没有ca支持， 需要手动添加&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;域名提供商提供的免费证书&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这种证书直接用，如果是自签名证书，需要添加自己的ca root证书到服务器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;12-Gitlab恢复数据出现must-be-owner-of解决方法&#34;&gt;12. Gitlab恢复数据出现must be owner of解决方法&lt;/h2&gt;
&lt;p&gt;按正常Gitlab备份数据gitlab-rake gitlab:backup:create&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-sql&#34; data-language=&#34;sql&#34;&gt;&lt;code class=&#34;language-sql&#34;&gt;ERROR: must be owner of extension plpgsql
ERROR: must be owner of schema public
ERROR: schema “public” already exists
ERROR: must be owner of schema public
ERROR: must be owner of extension plpgsql
WARNING: no privileges could be revoked for “public”
WARNING: no privileges could be revoked for “public”
WARNING: no privileges were granted for “public”
WARNING: no privileges were granted for “public”&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;h4 id=&#34;1-修改postgresql配置&#34;&gt;**1. 修改postgresql配置 **&lt;/h4&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;cd /var/opt/gitlab/postgresql/data
$ vi /var/opt/gitlab/postgresql/data/postgresql.conf
listen_addresses = &#39;*&#39;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;找到listen_addresses = ” 改为listen_addresses = ‘*’&lt;/p&gt;
&lt;p&gt;修改 /var/opt/gitlab/postgresql/data/pg_hba.conf&lt;br&gt;
在这个文件最后面加入&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;$ vi /var/opt/gitlab/postgresql/data/pg_hba.conf
local   all         all                               trust
host    all         all                               127.0.0.1/32 trust
host    all         all                               ::1/128 trust    #ipv6 可以不配置&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h4 id=&#34;2-重启gitlab生效&#34;&gt;&lt;strong&gt;2. 重启gitlab生效&lt;/strong&gt;&lt;/h4&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;gitlab-ctl restart&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h4 id=&#34;3-修改gitlab账号为超级用户&#34;&gt;&lt;strong&gt;3. 修改gitlab账号为超级用户&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;进入postgresql命令行&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;cd /opt/gitlab/embedded/bin
su gitlab-psql
./psql -h 127.0.0.1 gitlabhq_production&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;查看账户权限&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;\du&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;执行修改gitlab用户为超级权限&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;ALTER USER gitlab WITH SUPERUSER;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;退出&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;\q&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/08/0220210802135016.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;4-从1462989681编号备份中恢复&#34;&gt;4. 从1462989681编号备份中恢复&lt;/h5&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;gitlab-rake gitlab:backup:restore BACKUP=1462989681&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;这样Gitlab恢复数据就不会再报must be owner of extension plpgsql错误。&lt;/p&gt;
&lt;h4 id=&#34;4-重启gitlab&#34;&gt;&lt;strong&gt;4. 重启gitlab&lt;/strong&gt;&lt;/h4&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;gitlab-ctl restart&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h2 id=&#34;13-Gitlab-Pages&#34;&gt;13. Gitlab Pages&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;官方文档：&lt;a href=&#34;https://docs.gitlab.com/ee/user/project/pages/&#34;&gt;https://docs.gitlab.com/ee/user/project/pages/&lt;/a&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Gitlab Pages 使用 &lt;a href=&#34;https://gitlab.com/gitlab-org/gitlab-pages&#34;&gt;GitLab Pages daemon&lt;/a&gt; 服务，它是用 GO 语言实现的简单 HTTP 服务，并且可以监听外部 IP 地址以及为自定义域名和自定义证书提供支持。它通过 SNI 支持动态证书并且默认通过 HTTP2 协议发送页面。最后推荐你去看官方文档 &lt;a href=&#34;https://gitlab.com/gitlab-org/gitlab-pages/blob/master/README.md&#34;&gt;README&lt;/a&gt; 以便全面了解它的工作原理。&lt;/p&gt;
&lt;h3 id=&#34;启用-Pages&#34;&gt;启用 Pages&lt;/h3&gt;
&lt;p&gt;打开 &lt;code&gt;gitlab.rb&lt;/code&gt;：&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;sudo vim /etc/gitlab/gitlab.rb&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;修改 &lt;code&gt;Pages&lt;/code&gt; 配置：&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;# Pages 服务地址
pages_external_url &#34;http://git.17lai.io&#34;
# 启用 pages
gitlab_pages[&#39;enable&#39;] = true
# fails to start in Docker
gitlab_pages[&#39;inplace_chroot&#39;] = true&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;让 &lt;code&gt;Gitlab&lt;/code&gt; 使用当前配置：&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo gitlab-ctl reconfigure

# stdout
&amp;gt; gitlab Reconfigured!&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;如果没有域名怎么办呢？可以参考 &lt;a href=&#34;https://www.imooc.com/learn/634&#34;&gt;Linux智能DNS服务搭建之Bind服务&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&#34;使用-Pages&#34;&gt;使用 Pages&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;官方的案例库：&lt;a href=&#34;https://gitlab.com/pages&#34;&gt;https://gitlab.com/pages&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;用户文档&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般有两种类型的Pages可以创建&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于用户（&lt;a href=&#34;http://username.example.io&#34;&gt;username.example.io&lt;/a&gt;）或组（&lt;a href=&#34;http://groupname.example.io&#34;&gt;groupname.example.io&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;对于Project（&lt;a href=&#34;http://username.example.io/projectname&#34;&gt;username.example.io/projectname&lt;/a&gt; 或 &lt;a href=&#34;http://groupname.example.io/projectname&#34;&gt;groupname.example.io/projectname&lt;/a&gt; ）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在GitLab中，usernames或groupnames是唯一的，我们经常把他们称为namespaces。在一个GitLab实例中只能有一个namespace。&lt;/p&gt;
&lt;p&gt;下面是Gitlab Pages类型、Project Name和 website URL对照表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/04/0820220408205156.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;GitLab Pages前提条件：&lt;/p&gt;
&lt;p&gt;简而言之，这是上传web站点到GitLab Pages需要的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Gitlab Pages使用的域名（向管理员询问）。&lt;/li&gt;
&lt;li&gt;创建一个Project。&lt;/li&gt;
&lt;li&gt;仓库的根目录放一个.gitlab-ci.yml，其中有个叫做pages的job。&lt;/li&gt;
&lt;li&gt;设置一个GitLab Runner构建web站点。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;部署简单的-html-项目&#34;&gt;部署简单的 html 项目&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;我们在自己的 &lt;code&gt;gitlab&lt;/code&gt; 上面创建一个测试项目：&lt;code&gt;plain-html&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;把项目拉取到本地：&lt;/li&gt;
&lt;/ol&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;# 换成你自己的仓库地址
git clone git@git.17lai.io:pages/plain-html.git&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;在项目中新建 &lt;code&gt;public&lt;/code&gt; 目录，然后添加 &lt;code&gt;index.html&lt;/code&gt; 、 &lt;code&gt;style.css&lt;/code&gt; 文件:&lt;/li&gt;
&lt;/ol&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-markup&#34; data-language=&#34;markup&#34;&gt;&lt;code class=&#34;language-markup&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&#34;utf-8&#34;&amp;gt;
    &amp;lt;meta name=&#34;generator&#34; content=&#34;GitLab Pages&#34;&amp;gt;
    &amp;lt;title&amp;gt;Plain HTML site using GitLab Pages&amp;lt;/title&amp;gt;
    &amp;lt;link rel=&#34;stylesheet&#34; href=&#34;style.css&#34;&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div class=&#34;navbar&#34;&amp;gt;
      &amp;lt;a href=&#34;https://pages.gitlab.io/plain-html/&#34;&amp;gt;Plain HTML Example&amp;lt;/a&amp;gt;
      &amp;lt;a href=&#34;https://gitlab.com/pages/plain-html/&#34;&amp;gt;Repository&amp;lt;/a&amp;gt;
      &amp;lt;a href=&#34;https://gitlab.com/pages/&#34;&amp;gt;Other Examples&amp;lt;/a&amp;gt;
    &amp;lt;/div&amp;gt;

    &amp;lt;h1&amp;gt;Hello World!&amp;lt;/h1&amp;gt;

    &amp;lt;p&amp;gt;
      This is a simple plain-HTML website on GitLab Pages, without any fancy static site generator.
    &amp;lt;/p&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-css&#34; data-language=&#34;css&#34;&gt;&lt;code class=&#34;language-css&#34;&gt;body {
  font-family: sans-serif;
  margin: auto;
  max-width: 1280px;
}

.navbar {
  background-color: #313236;
  border-radius: 2px;
  max-width: 800px;
}

.navbar a {
  color: #aaa;
  display: inline-block;
  font-size: 15px;
  padding: 10px;
  text-decoration: none;
}

.navbar a:hover {
  color: #ffffff;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;在项目根目录添加 &lt;code&gt;.gitlab-ci.yml&lt;/code&gt; 文件：&lt;/li&gt;
&lt;/ol&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-yaml&#34; data-language=&#34;yaml&#34;&gt;&lt;code class=&#34;language-yaml&#34;&gt;# This file is a template, and might need editing before it works on your project.
# Full project: https://gitlab.com/pages/plain-html
pages:
  tags:
    - html
  stage: deploy
  script:
    - mkdir .public
    - cp -r * .public
    - mv .public public
  artifacts:
    paths:
      - public
  only:
    - master&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;提交代码：&lt;/li&gt;
&lt;/ol&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;git add .
git commit -m&#34;feat(pages):  开启 pages 服务&#34;
git push&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;最后我们回到 gitlab 服务，在 &lt;code&gt;plain-html&lt;/code&gt; 仓库中的 &lt;code&gt;Settings / pages&lt;/code&gt; 页面可以看到已经有对应的服务地址了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/04/0820220408203643.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;gitlab 服务的域名跟 pages 的不要使用同一个，防止 XSS 攻击。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;管理员文档：&lt;a href=&#34;https://docs.gitlab.com/ce/administration/pages/&#34;&gt;https://docs.gitlab.com/ce/administration/pages/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户文档：&lt;a href=&#34;https://docs.gitlab.com/ce/user/project/pages/index.html&#34;&gt;https://docs.gitlab.com/ce/user/project/pages/index.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;gitlab pages：&lt;a href=&#34;https://pages.gitlab.io/&#34;&gt;https://pages.gitlab.io/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Container-Registry&#34;&gt;Container Registry&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;官方文档：&lt;a href=&#34;https%25://docs.gitlab.com/ee/user/packages/container_registry/&#34;&gt;https://docs.gitlab.com/ee/user/packages/container_registry/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本节修改中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;开启-Container-Registry&#34;&gt;开启 Container Registry&lt;/h3&gt;
&lt;p&gt;修改gitlab配置文件： vim /etc/gitlab/gitlab.rb&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;//外部访问地址，此处被nginx代理，暴露给外部访问
registry_external_url &#39;http://xxx.com&#39;
//启用
gitlab_rails[&#39;registry_enabled&#39;] = true
//registry 服务ip
gitlab_rails[&#39;registry_host&#39;] = &#34;172.29.1.70&#34;
//registry 服务真正端口
gitlab_rails[&#39;registry_port&#39;] = &#34;5000&#34;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;这里需要注意的是，registry_external_url是外部访问的url，如docker需要pull和push，都是访问该路径。然后，刷新配置，重启：&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;gitlab-ctl reconfigure
gitlab-ctl restart&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;访问Docker&#34;&gt;访问Docker&lt;/h3&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;# docker login https://xxx.com -u root -p xxx
Login Succeeded&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;默认&lt;mark&gt;需要SSL&lt;/mark&gt;，请使用反向代理&lt;/p&gt;
&lt;p&gt;官方文档有说明，如果启用了双重验证（Two-Factor Authentication）则不应该输入密码，而是token：&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;docker login xxx.com -u &amp;lt;username&amp;gt; -p &amp;lt;token&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h2 id=&#34;CI&#34;&gt;CI&lt;/h2&gt;
&lt;p&gt;GitLab Continuous Integration (GitLab CI/CD)&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;CI: Continuous Integration：持续集成。&lt;/li&gt;
&lt;li&gt;CD: Coninuous delivery and deployment：持续交付和部署。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Gitlab CI/CD 是以可持续方法论进行软件开发的内建工具（&lt;a href=&#34;https://about.gitlab.com/gitlab-ci/&#34;&gt;continuous integration service&lt;/a&gt; ）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在使用 Gitlab CI 之前，我们需要先了解几个概念：&lt;/p&gt;
&lt;h3 id=&#34;Stage&#34;&gt;Stage&lt;/h3&gt;
&lt;p&gt;阶段：通俗的讲就是步骤（把一件事分解成多个步骤来完成）。 从最上面的图中可以看到在 &lt;code&gt;CI&lt;/code&gt; 中可能会有：&lt;code&gt;Build&lt;/code&gt;、&lt;code&gt;Unit Test&lt;/code&gt; 、&lt;code&gt;Integration Tests&lt;/code&gt; 等多个阶段。&lt;/p&gt;
&lt;h3 id=&#34;Job&#34;&gt;Job&lt;/h3&gt;
&lt;p&gt;任务：就是我们在每个阶段具体要做的事情，而一个阶段可能会有多个任务。&lt;/p&gt;
&lt;h3 id=&#34;Pipelines&#34;&gt;Pipelines&lt;/h3&gt;
&lt;p&gt;一条流水线 （ &lt;code&gt;pipeline&lt;/code&gt;）就是 &lt;strong&gt;一组&lt;/strong&gt; 在各个阶段执行的任务。在同一阶段的多个任务是可以并行的（如果 &lt;code&gt;Runner&lt;/code&gt; 足够多的话），当全部的任务都执行成功之后流水线将会进入下一个阶段。反之，如果其中有一个任务失败，流水线的下一个阶段将不再执行。&lt;/p&gt;
&lt;h3 id=&#34;Runners&#34;&gt;Runners&lt;/h3&gt;
&lt;p&gt;在 Gitlab CI 中，&lt;code&gt;Runner&lt;/code&gt; 负责运行定义在 &lt;code&gt;.gitlab-ci.yml&lt;/code&gt; 中的代码。&lt;code&gt;Runner&lt;/code&gt; 为三种：&lt;code&gt;Shared Runners&lt;/code&gt;、&lt;code&gt;Group Runners&lt;/code&gt;、&lt;code&gt;Specific Runners&lt;/code&gt;，分别表示全局共用 Runner、组共用 Runner、单个项目指定的 Runner。&lt;/p&gt;
&lt;h3 id=&#34;gitlab-ci-yml&#34;&gt;.gitlab-ci.yml&lt;/h3&gt;
&lt;p&gt;Gitlab CI 的配置文件，该文件声明了流水线的结构和顺序，以任务为最小单元。&lt;/p&gt;
&lt;p&gt;文件中允许定义的元素：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.gitlab.com/ce/ci/yaml/README.html#image&#34;&gt;&lt;code&gt;image&lt;/code&gt;&lt;/a&gt;：docker 镜像，当 Gitlab-Runner 的类型为 docker 时，会根据该属性指定的镜像为脚本执行容器。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.gitlab.com/ce/ci/yaml/README.html#services&#34;&gt;&lt;code&gt;services&lt;/code&gt;&lt;/a&gt;: 指定另一个 docker 镜像，主要用于提供服务层的能力，比如 &lt;code&gt;mysql&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.gitlab.com/ce/ci/yaml/README.html#before_script-and-after_script&#34;&gt;&lt;code&gt;before_script&lt;/code&gt;&lt;/a&gt;：任务执行前的钩子事件，比如一个 node 项目，我们可以在这里安装依赖。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.gitlab.com/ce/ci/yaml/README.html#before_script-and-after_script&#34;&gt;&lt;code&gt;after_script&lt;/code&gt;&lt;/a&gt;：任务执行后的钩子事件，当所有的任务都执行完毕之后被调用，不管任务是否执行成功。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.gitlab.com/ce/ci/yaml/README.html#stages&#34;&gt;&lt;code&gt;stages&lt;/code&gt;&lt;/a&gt;：定义流水线中的阶段，默认的为 &lt;code&gt;build&lt;/code&gt; 、&lt;code&gt;test&lt;/code&gt;、&lt;code&gt;deploy&lt;/code&gt;。如果我们要在任务中指定其他的 &lt;code&gt;stage&lt;/code&gt;，则需要使用该属性先申明。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.gitlab.com/ce/ci/yaml/README.html#cache&#34;&gt;&lt;code&gt;cache&lt;/code&gt;&lt;/a&gt;：需要缓存的文件，比如 node 项目可以把 node_modules 缓存起来。提示：可以定义在 &lt;code&gt;.gitlab-ci.yml&lt;/code&gt; 顶级表示项目级别的，也可以申明在单个任务中。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.gitlab.com/ce/ci/yaml/README.html#variables&#34;&gt;&lt;code&gt;variables&lt;/code&gt;&lt;/a&gt;：变量，同样可以在顶级或者单个任务中申明。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.gitlab.com/ce/ci/yaml/README.html#pages&#34;&gt;&lt;code&gt;pages&lt;/code&gt;&lt;/a&gt;：内置的一个任务，用于上传任务执行的结果到 &lt;a href=&#34;https://docs.gitlab.com/ce/user/project/pages/index.html&#34;&gt;Gitlab Pages&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.gitlab.com/ce/ci/yaml/README.html#include&#34;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt;：合并其他的 &lt;code&gt;.gitlab-ci.yml&lt;/code&gt; 文件配置。&lt;/li&gt;
&lt;li&gt;在单个任务中申明的元素：
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.gitlab.com/ce/ci/yaml/README.html#script&#34;&gt;&lt;code&gt;script&lt;/code&gt;&lt;/a&gt;：需要执行的脚本。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.gitlab.com/ce/ci/yaml/README.html#stage&#34;&gt;&lt;code&gt;stage&lt;/code&gt;&lt;/a&gt;：标识该任务所属的阶段。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.gitlab.com/ce/ci/yaml/README.html#tags&#34;&gt;&lt;code&gt;tags&lt;/code&gt;&lt;/a&gt;：为任务打上标签，用于选择特定的 &lt;code&gt;Runner&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.gitlab.com/ce/ci/yaml/README.html#onlyexcept-basic&#34;&gt;&lt;code&gt;only&lt;/code&gt;&lt;/a&gt;：用于表明何时&lt;strong&gt;创建&lt;/strong&gt;该任务。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.gitlab.com/ce/ci/yaml/README.html#onlyexcept-basic&#34;&gt;&lt;code&gt;except&lt;/code&gt;&lt;/a&gt;：用于表明何时&lt;strong&gt;不创建&lt;/strong&gt;该任务。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.gitlab.com/ce/ci/yaml/README.html#when&#34;&gt;&lt;code&gt;when&lt;/code&gt;&lt;/a&gt;：用于表明何时&lt;strong&gt;运行&lt;/strong&gt;该任务。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.gitlab.com/ce/ci/yaml/README.html#allow_failure&#34;&gt;&lt;code&gt;allow_failure&lt;/code&gt;&lt;/a&gt;：允许失败，该任务失败时不会影响整个流水线的结果。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.gitlab.com/ce/ci/yaml/README.html#artifacts&#34;&gt;&lt;code&gt;artifacts&lt;/code&gt;&lt;/a&gt;：任务执行的结果，比如执行 &lt;code&gt;打包任务&lt;/code&gt; 后的产出资源。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.gitlab.com/ce/ci/yaml/README.html#dependencies&#34;&gt;&lt;code&gt;dependencies&lt;/code&gt;&lt;/a&gt;：依赖的其他任务。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.gitlab.com/ce/ci/yaml/README.html#retry&#34;&gt;&lt;code&gt;retry&lt;/code&gt;&lt;/a&gt;：当任务失败时最多重试的次数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.gitlab.com/ce/ci/yaml/README.html#coverage&#34;&gt;&lt;code&gt;coverage&lt;/code&gt;&lt;/a&gt;：指定如何从任务结果中提取代码覆盖率。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.gitlab.com/ce/ci/yaml/README.html#parallel&#34;&gt;&lt;code&gt;parallel&lt;/code&gt;&lt;/a&gt;：允许并行的任务实例个数。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;请注意版本问题，每个属性对版本的要求并不一致，具体的可以点击属性查看官方文档。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;使用-Gitlab-CI&#34;&gt;使用 Gitlab CI&lt;/h3&gt;
&lt;p&gt;使用 Gitlab CI 服务的两种方式： 1. &lt;a href=&#34;https://docs.gitlab.com/ce/topics/autodevops/index.html&#34;&gt;Auto DevOps&lt;/a&gt; 2. 手动配置 CI/CD&lt;/p&gt;
&lt;h4 id=&#34;Auto-DevOps&#34;&gt;&lt;a href=&#34;https://docs.gitlab.com/ce/topics/autodevops/index.html&#34;&gt;Auto DevOps&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Auto DevOps 是 Gitlab 11.0 推出的新功能，它提供了预定义的 CI/CD 配置，允许我们自动检测、构建、测试、发布以及监控应用。&lt;/p&gt;
&lt;p&gt;暂未使用，待补充。&lt;/p&gt;
&lt;h4 id=&#34;手动配置-CI-CD&#34;&gt;手动配置 CI/CD&lt;/h4&gt;
&lt;p&gt;手动配置主要就 2 个步骤，配置 &lt;code&gt;.gitlab-ci.yml&lt;/code&gt; 文件，添加 Gitlab Runner 运行该文件。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;下面，我们看看如何配置 Gitlab Runner：&lt;/p&gt;
&lt;h4 id=&#34;Gitlab-Runner&#34;&gt;Gitlab Runner&lt;/h4&gt;
&lt;p&gt;Gitlab Runner 是一个开源项目，用来运行 &lt;code&gt;.gitlab-ci.yml&lt;/code&gt; 中定义的任务并把结果返给 Gitlab。&lt;/p&gt;
&lt;h5 id=&#34;安装&#34;&gt;安装&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;官方文档：&lt;a href=&#34;https://docs.gitlab.com/runner/install/linux-repository.html&#34;&gt;https://docs.gitlab.com/runner/install/linux-repository.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先，添加离线仓库：&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh | sudo bash&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;然后，安装最新版本：&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;sudo apt-get install gitlab-runner&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h5 id=&#34;注册&#34;&gt;注册&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;官方文档：&lt;a href=&#34;https://docs.gitlab.com/runner/register/index.html&#34;&gt;https://docs.gitlab.com/runner/register/index.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先，我们进入要配置 Runner 的 Gitlab 仓库，在 &lt;code&gt;Settings -&amp;gt; CI / CD&lt;/code&gt; 页面展开 &lt;code&gt;Runners&lt;/code&gt; 配置面板可以看到已经分配的 Runner 以及注册 Runner 需要的参数：&lt;img src=&#34;https://cimg1.17lai.site/data/2022/04/0820220408170943.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;然后，我们使用 Gitlab-Runner 命名开始注册：&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;gitlab-runner register&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;执行完会该命令，终端会有交互，要求我们输入以下参数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;gitlab-ci coordinator url ：gitlab 服务地址&lt;/li&gt;
&lt;li&gt;gitlab-ci token：上图中的 token&lt;/li&gt;
&lt;li&gt;description：描述信息&lt;/li&gt;
&lt;li&gt;tags：标签，对应 &lt;code&gt;.gitlab-ci.yml&lt;/code&gt; 任务中配置的 tags，只有 tags 匹配的任务才会被该 Runner 执行。&lt;/li&gt;
&lt;li&gt;executor：&lt;a href=&#34;https://docs.gitlab.com/runner/executors/README.html&#34;&gt;执行器&lt;/a&gt;，即任务脚本执行的环境&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;如果使用 docker 执行，则需要事先安装 &lt;a href=&#34;https://docs.docker.com/install/linux/docker-ce/ubuntu/&#34;&gt;Docker&lt;/a&gt; 环境。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参数填写完毕之后，一个 Runner 便被注册成功了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/04/0820220408170946.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们回到 gitlab 仓库页面，然后刷新便可以看到 &lt;code&gt;_fzBq4PN&lt;/code&gt; 这个 Runner 已经被注册到该项目：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2022/04/0820220408170952.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我们可以点击 &lt;code&gt;编辑图标&lt;/code&gt; 对该 Runner 进行修改。我比较喜欢把 &lt;code&gt;Run untagged jobs&lt;/code&gt; 选项勾上，这样就不用每个任务都添加对应的 tags 了（因为现在涉及到的都是一些简单的流程）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;首先，CI/CD 是一种软件开发流程，Gitlab CI/CD 是 Gitlab 为实现该流程而提供的一个内置工具（服务）。 其次，我们有 &lt;a href=&#34;https://docs.gitlab.com/ce/topics/autodevops/index.html&#34;&gt;Auto DevOps&lt;/a&gt; 与 &lt;code&gt;手动配置&lt;/code&gt; 两种方式使用，本文讲解的主要是 &lt;code&gt;手动配置&lt;/code&gt; 方式。&lt;/p&gt;
&lt;h2 id=&#34;加速Gitlab-Runner&#34;&gt;加速Gitlab Runner&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;gitlab runner构建镜像每次RUN 安装依赖包，都远程下载?可以缓存加速吗？ 可以的！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在将GitLab Runner注册到GitLab page上，让GitLab page可以和你的Runner通信时，有一步是填写使用的executor&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;输入Runner的executor：
Please enter the executor: ssh, docker+machine, docker-ssh+machine, kubernetes, docker, parallels, virtualbox, docker-ssh, shell:&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;如果你选择Docker作为Runner的executor，你还要选择默认的docker image来运行job(当然，你也可以在.gitlab-ci.yml里指明你需要用的image),这句话就跟文章使用gitlab-runner往k8s上发送curl命令实现pod中容器使用的镜像版本更新，地址： 开头讲述的那样，不过.gitlab-ci.yml里指明的image优先级高。&lt;/p&gt;
&lt;p&gt;注册完成后你可以在/etc/gitlab-runner里发现 config.toml文件，该文件是Runner的配置文件&lt;/p&gt;
&lt;p&gt;接下来就牵涉到一个重要的话题 —— Executor&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Shell Executor&lt;br&gt;
以宿主机作为Runner的所有jobs的执行器。Runner将会从远程仓库pull你的工程，工程的目录为：/builds。如果你使用了cache，那么cache将会存在/cache/。&lt;br&gt;
但是，它需要将构建所需的所有依赖手动安装到安装了Runner的同一台计算机上，比如使用到的git,jdk,maven,docekr等&lt;/li&gt;
&lt;li&gt;Docker Executor&lt;br&gt;
所有jobs的执行环境为指定的docker image所生成的container，每个job都会生成一个container并且在job结束后立即销毁。这个说的就是config.toml文件和.gitlab-ci.yml中指定的image&lt;br&gt;
Docker executor默认将所有的builds存储在/builds/(这里的路径是container里的路径，Runner配置文件config.toml里的build_dir字段可以重新指明build的目录，默认对应于宿主机的目录是在宿主机的docker volume下：/var/lib/docker/volumes//_data/)，默认将所有的caches存储在container里的/cache目录(config.toml里的cache_dir字段可以重新指明cache的目录)，注意build_dir和cache_dir指向的均是container里的目录，要想将container里的数据持久化，需要用到volumes字段，这个字段的使用和docker volume的使用是类似的，只需在config.toml的[runner.docker]部分添加volumes = [“/cache”, “:rw”]即可实现container里/cache目录数据的永久保存以及将host目录挂载到相应的container目录并具有读写的功能。&lt;br&gt;
比如：&lt;/li&gt;
&lt;/ol&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;# 仅作展示，未显示完整
[runners.docker]
  image = &#34;jdd.io/jre:1.8.275&#34;
  volumes = [&#34;/cache&#34;,&#34;/run/docker.sock:/run/docker.sock&#34;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;当你使用docker 或 docker+machine executors时，你可以通过设置pull_policy来决定Runner如何pull docker image。pull_policy有三种值：&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;always —— Runner始终从远程pull docker image。
if-not-present —— Runner会首先检查本地是否有该image，如果有则用本地的，如果没有则从远程拉取。
never —— Runner始终使用本地的image。&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：这一步就是本文开头提到的，使用本地镜像，不用再从dockerhub上拉取了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;# 仅作展示，未显示完整
[runners.docker]
  image = &#34;jdd.io/jre:1.8.275&#34;
  pull_policy=&#34;if-not-present&#34; # 添加这个选项就可以了
  volumes = [&#34;/cache&#34;,&#34;/run/docker.sock:/run/docker.sock&#34;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;当你使用docker, docker+machine 或 kubernetes作为executor时，GitLab Runner将会使用特定的container来处理Git、artifacts 和cache 操作。&lt;/p&gt;
&lt;h2 id=&#34;权限管理&#34;&gt;权限管理&lt;/h2&gt;
&lt;p&gt;以管理员的身份登入gitlab，点击Settings，然后选择Members，可以通过输入名字选择要分配权限的小组成员，然后分配角色，选择权限有效时间，点击Add to Project就把人员拉近到项目中。&lt;/p&gt;
&lt;p&gt;GitLab的角色有以下四种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Guest：可以创建issue、发表评论，不能读写版本库&lt;/li&gt;
&lt;li&gt;Reporter：可以克隆代码，不能提交，可以赋予测试、产品经理此权限&lt;/li&gt;
&lt;li&gt;Developer：可以克隆代码、开发、提交、push，可以赋予开发人员此权限&lt;/li&gt;
&lt;li&gt;MainMaster：可以创建项目、添加tag、保护分支、添加项目成员、编辑项目，一般GitLab管理员或者CTO才有此权限&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;访问权限 - Visibility Level：&lt;/p&gt;
&lt;p&gt;这个是在建立项目时就需要选定的，主要用于决定哪些人可以访问此项目，包含3种&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Private - 私有，只有属于该项目成员才有原先查看&lt;/li&gt;
&lt;li&gt;Internal - 内部，用个Gitlab账号的人都可以clone&lt;/li&gt;
&lt;li&gt;Public - 公开，任何人可以clone&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文作者：夜法之书       写作不易，转载请注明来源地址！&lt;/p&gt;
&lt;h2 id=&#34;参考链接：&#34;&gt;参考链接：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/hgzero/p/14088215.html&#34;&gt;https://www.cnblogs.com/hgzero/p/14088215.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.51blogs.net/2017/11/10/1110113243.html&#34;&gt;http://www.51blogs.net/2017/11/10/1110113243.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://my.oschina.net/u/2400083/blog/808097&#34;&gt;https://my.oschina.net/u/2400083/blog/808097&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;i-class-fa-solid-fa-school-i-系列教程&#34;&gt;&lt;i class=&#34;fa-solid fa-school&#34;&gt;&lt;/i&gt;&lt;strong&gt;系列教程&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;/atom.xml&#34;&gt;&lt;i class=&#34;fa-solid fa-square-rss&#34;&gt;&lt;/i&gt;全部文章RSS订阅&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;i-class-fa-brands-fa-dev-i-Devops系列&#34;&gt;&lt;i class=&#34;fa-brands fa-dev&#34;&gt;&lt;/i&gt;&lt;strong&gt;Devops系列&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;/categories/devops/atom.xml&#34;&gt;&lt;i class=&#34;fa-solid fa-square-rss&#34;&gt;&lt;/i&gt;&lt;strong&gt;Devops 分类 RSS 订阅&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;/posts/ab63eb8f/&#34;&gt;自建全套开源Devops开发系统&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/d32a07a7/&#34;&gt;Git介绍以及分支模型图解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/39563241/&#34;&gt;三万字无坑搭建基于Docker+K8S+GitLab/SVN+Jenkins+Harbor持续集成交付环境&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/3437994a/&#34;&gt;DevOps系列—【Jenkinsfile+Dockerfile+nginx+vue】&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/f4c3ad41/&#34;&gt;项目开发管理工具推荐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/acc13b70/&#34;&gt;Gitlab的安装及使用教程完全版&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/d08eb7b/&#34;&gt;Gitlab的安装及使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/78c3371/&#34;&gt;那些有用的Github工具介绍！Action、app、workflow等&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="gitlab" />
        <category term="git" />
        <category term="docker" />
        <category term="registry" />
        <category term="教程" />
        <category term="email" />
        <category term="https" />
        <category term="ssl" />
        <updated>2021-08-02T08:25:00.000Z</updated>
    </entry>
    <entry>
        <id>https://blog.17lai.site/posts/d08eb7b/</id>
        <title>Gitlab的安装及使用</title>
        <link rel="alternate" href="https://blog.17lai.site/posts/d08eb7b/"/>
        <content type="html">&lt;h2 id=&#34;Gitlab概述&#34;&gt;Gitlab概述&lt;/h2&gt;
&lt;h3 id=&#34;1-1-GitLab介绍&#34;&gt;1.1 GitLab介绍&lt;/h3&gt;
&lt;p&gt;GitLab是利用Ruby on Rails一个开源的版本管理系统，实现一个自托管的Git项目仓库，可通过Web界面进行访问公开的或者私人项目。&lt;/p&gt;
&lt;p&gt;GitLab能够浏览源代码，管理缺陷和注释。可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。团队成员可以利用内置的简单聊天程序(Wall)进行交流。&lt;/p&gt;
&lt;p&gt;它还提供一个代码片段收集功能可以轻松实现代码复用，便于日后有需要的时候进行查找&lt;/p&gt;
&lt;h3 id=&#34;1-2-Gitlab服务构成&#34;&gt;1.2 Gitlab服务构成&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Nginx：静态web服务器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;gitlab-shell：用于处理Git命令和修改authorized keys列表。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;gitlab-workhorse: 轻量级的反向代理服务器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;logrotate：日志文件管理工具。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;postgresql：数据库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;redis：缓存数据库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sidekiq：用于在后台执行队列任务（异步执行）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;unicorn：An HTTP server for Rack applications，GitLab Rails应用是托管在这个服务器上面的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-3-Gitlab工作流程&#34;&gt;1.3 Gitlab工作流程&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/05/2820210528222044.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-4-GitLab-Shell&#34;&gt;1.4 GitLab Shell&lt;/h3&gt;
&lt;p&gt;GitLab Shell有两个作用：为GitLab处理Git命令、修改authorized keys列表&lt;/p&gt;
&lt;p&gt;当通过SSH访问GitLab Server时，GitLab Shell会：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;限制执行预定义好的Git命令（git push，git pull，git annex）&lt;/li&gt;
&lt;li&gt;调用GitLab Rails API检查权限&lt;/li&gt;
&lt;li&gt;执行pre-receive钩子（在企业版中叫做Git钩子）&lt;/li&gt;
&lt;li&gt;执行用户请求的动作，处理GitLab的post-receive动作&lt;/li&gt;
&lt;li&gt;处理自定义的post-receive动作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当通过http(s)访问GitLab Server时，工作流程取决于你是从Git仓库拉取(pull)代码还是向git仓库推送(push)代码：&lt;/p&gt;
&lt;p&gt;如果是从Git仓库拉取(pull)代码，GitLab Rails应用会全权负责处理用户鉴权和执行Git命令的工作&lt;/p&gt;
&lt;p&gt;如果是向Git仓库推送(push)代码，GitLab Rails应用既不会进行用户鉴权也不会执行Git命令，它会把以下工作交由GitLab Shell进行处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用GitLab Rails API 检查权限&lt;/li&gt;
&lt;li&gt;执行pre-receive钩子（在GitLab企业版中叫做Git钩子）&lt;/li&gt;
&lt;li&gt;执行你请求的动作&lt;/li&gt;
&lt;li&gt;处理GitLab的post-receive动作&lt;/li&gt;
&lt;li&gt;处理自定义的post-receive动作&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-5-GitLab-Workhorse&#34;&gt;1.5 GitLab Workhorse&lt;/h3&gt;
&lt;p&gt;GitLab Workhorse是一个敏捷的反向代理。它会处理一些大的HTTP请求，比如文件上传、文件下载、Git push/pull和Git包下载。其它请求会反向代理到GitLab Rails应用，即反向代理给后端的unicorn。&lt;/p&gt;
&lt;h2 id=&#34;Gitlab的安装部署&#34;&gt;Gitlab的安装部署&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;Gitlab要求服务器内存2G以上&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-1-方式一-下载gitlab-ce的rpm包&#34;&gt;2.1 方式一:下载gitlab-ce的rpm包&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://packages.gitlab.com/gitlab/gitlab-ce&#34;&gt;gitlab官方rpm包下载&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/&#34;&gt;清华的源&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将对应版本的gitlab-ce下载到本地后，直接yum安装即可&lt;/p&gt;
&lt;h4 id=&#34;要先将这个rpm包下载到本地&#34;&gt;要先将这个rpm包下载到本地&lt;/h4&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;yum install -y gitlab-ce-13.6.1-ce.0.el7.x86_64.rpm&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;2-2-方式二-配置yum源&#34;&gt;2.2 方式二:配置yum源&lt;/h3&gt;
&lt;p&gt;在 /etc/yum.repos.d/ 下新建 gitlab-ce.repo，写入如下内容：&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-ruby&#34; data-language=&#34;ruby&#34;&gt;&lt;code class=&#34;language-ruby&#34;&gt;[gitlab-ce]
name=gitlab-ce
baseurl=https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/ Repo_gpgcheck=0
Enabled=1 Gpgkey=https://packages.gitlab.com/gpg.key&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;然后创建cache，再直接安装gitlab-ce&lt;/p&gt;
&lt;p&gt;yum makecache  # 这一步会创建大量的数据&lt;/p&gt;
&lt;h4 id=&#34;直接安装最新版&#34;&gt;直接安装最新版&lt;/h4&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;yum install -y gitlab-ce # 如果要安装指定的版本，在后面填上版本号即可
yum install -y  gitlab-ce-13.6.1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h4 id=&#34;如果安装时出现gpgkey验证错误，只需在安装时明确指明不进行gpgkey验证&#34;&gt;如果安装时出现gpgkey验证错误，只需在安装时明确指明不进行gpgkey验证&lt;/h4&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;yum install gitlab-ce -y --nogpgcheck&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;2-3-gitlab的配置&#34;&gt;2.3 gitlab的配置&lt;/h3&gt;
&lt;p&gt;配置文件位置  /etc/gitlab/gitlab.rb&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@centos7 test]# vim /etc/gitlab/gitlab.rb
[root@centos7 test]# grep &#34;^[a-Z]&#34; /etc/gitlab/gitlab.rb
external_url &#39;http://10.0.0.51&#39;  # 这里一定要加上http://&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h4 id=&#34;配置邮件服务&#34;&gt;配置邮件服务&lt;/h4&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-ruby&#34; data-language=&#34;ruby&#34;&gt;&lt;code class=&#34;language-ruby&#34;&gt;gitlab_rails[&#39;smtp_enable&#39;] = true
gitlab_rails[&#39;smtp_address&#39;] = &#34;smtp.qq.com&#34; gitlab_rails[&#39;smtp_port&#39;] = 25 gitlab_rails[&#39;smtp_user_name&#39;] = &#34;hgzerowzh@qq.com&#34;  # 自己的qq邮箱账号
gitlab_rails[&#39;smtp_password&#39;] = &#34;xxx&#34;  # 开通smtp时返回的授权码
gitlab_rails[&#39;smtp_domain&#39;] = &#34;qq.com&#34; gitlab_rails[&#39;smtp_authentication&#39;] = &#34;login&#34; gitlab_rails[&#39;smtp_enable_starttls_auto&#39;] = true
gitlab_rails[&#39;smtp_tls&#39;] = false
gitlab_rails[&#39;gitlab_email_from&#39;] = &#34;hgzerowzh@qq.com&#34;  # 指定发送邮件的邮箱地址
user[&#34;git_user_email&#34;] = &#34;shit@qq.com&#34;   # 指定接收邮件的邮箱地址&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;修改好配置文件后，要使用 gitlab-ctl reconfigure 命令重载一下配置文件，否则不生效。&lt;/strong&gt;&lt;/p&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-none&#34;&gt;&lt;code class=&#34;language-none&#34;&gt;gitlab-ctl reconfigure # 重载配置文件&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;2-4-Gitlab常用命令&#34;&gt;2.4 Gitlab常用命令&lt;/h3&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-ruby&#34; data-language=&#34;ruby&#34;&gt;&lt;code class=&#34;language-ruby&#34;&gt;gitlab-ctl start         # 启动所有 gitlab 组件
gitlab-ctl stop          # 停止所有 gitlab 组件
gitlab-ctl restart       # 重启所有 gitlab 组件
gitlab-ctl status        # 查看服务状态
gitlab-ctl reconfigure   # 启动服务
gitlab-ctl show-config   # 验证配置文件
gitlab-ctl tail          # 查看日志
gitlab-rake gitlab:check SANITIZE=true --trace    # 检查gitlab
vim /etc/gitlab/gitlab.rb # 修改默认的配置文件&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h2 id=&#34;Gitlab的使用&#34;&gt;Gitlab的使用&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;Gitlab安装好后，设置密码，管理账户为root&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-1-创建Group&#34;&gt;&lt;strong&gt;3.1 创建Group&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;填上组名即可，这里组名为java&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/05/2820210528222105.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211347.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-2-创建User&#34;&gt;&lt;strong&gt;3.2 创建User&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;创建四个User：pm、dev1、dev2、dev3&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/05/2820210528222131.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/05/2820210528222120.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-3-添加User到Group中并授权&#34;&gt;&lt;strong&gt;3.3 添加User到Group中并授权&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/05/2820210528222140.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-4-创建Project并配置SSH&#34;&gt;&lt;strong&gt;3.4 创建Project并配置SSH&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/05/2820210528222147.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/05/2820210528222154.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/05/2820210528222201.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/05/2820210528222233.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-5-在项目中添加成员&#34;&gt;&lt;strong&gt;3.5 在项目中添加成员&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211335.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211726.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-6-将本地文件推送到Gitlab&#34;&gt;3.6 将本地文件推送到Gitlab&lt;/h3&gt;
&lt;h4 id=&#34;将app01项目克隆下来&#34;&gt;将app01项目克隆下来&lt;/h4&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone git@10.0.0.51:java/app01.git # 初始化配置
git config --global user.name &#34;hgzero&#34; git config --global user.email &#34;hgzero@qq.com&#34;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h4 id=&#34;在app01目录下新建一些文件&#34;&gt;在app01目录下新建一些文件&lt;/h4&gt;
&lt;h4 id=&#34;推送到gitlab&#34;&gt;推送到gitlab&lt;/h4&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;git add .
git commit -m &#34;first edition&#34; git push origin master&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211546.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;制定开发计划&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;4-1-创建开发计划&#34;&gt;&lt;strong&gt;4.1 创建开发计划&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;项目：app01&lt;/li&gt;
&lt;li&gt;版本：v1.0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211325.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;4-2-创建里程碑Milestones&#34;&gt;&lt;strong&gt;4.2 创建里程碑Milestones&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用pm账号登录gitlab后操作（先要在admin中设置pm账号的密码）&lt;/li&gt;
&lt;li&gt;要根据开发计划来创建Milestones&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211538.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211719.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211315.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211303.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;4-3-根据开发计划创建issue&#34;&gt;4.3 根据开发计划创建issue&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;创建4个issue，分派给dev1和dev2这两个开发人员&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211529.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211304.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211711.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211520.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211514.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211252.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;4-4-开发者登录账号查看分派的任务&#34;&gt;**4.4 开发者登录账号查看分派的任务 **&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;然后开发dev1登录gitlab，就能看到任务已经分配过来了&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211513.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;4-5-开发流程&#34;&gt;&lt;strong&gt;4.5 开发流程&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;公司里的开发开始任务&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;1-先从仓库把项目拉下来&#34;&gt;1. 先从仓库把项目拉下来&lt;/h4&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;git clone git@10.0.0.51:java/app01.git
cd app01/&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h4 id=&#34;2-先创建一个自己的分支，然后进行开发&#34;&gt;2.先创建一个自己的分支，然后进行开发&lt;/h4&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;git checkout -b index   # 创建一个叫index的分支，并切换到这个分支
git status # 3. 开始开发首页
echo &#34;&amp;lt;h1&amp;gt;welcome to this app&amp;lt;/h1&amp;gt;&#34; &amp;gt; index.html  # 假设就开发了一个index页面&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h2 id=&#34;4-开发完成后，把项目传到仓库&#34;&gt;4. 开发完成后，把项目传到仓库&lt;/h2&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;git add .
git commit -m &#34;index&#34;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h4 id=&#34;如果写成-git-commit-m-“close-2”-，则表示merge请求允许且merge成功之后，自动删除编号为-2的issue&#34;&gt;如果写成 git commit -m “close #2” ，则表示merge请求允许且merge成功之后，自动删除编号为#2的issue&lt;/h4&gt;
&lt;h4 id=&#34;传到index分支&#34;&gt;传到index分支&lt;/h4&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;git push origin index&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;4-6-合并分支&#34;&gt;&lt;strong&gt;4.6 合并分支&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1）开发dev1发送合并分支请求给pm&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211242.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211503.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211701.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）pm收到开发的Merge请求后进行处理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用pm登录，就可以看到pm已经收到了合并请求merge request&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211231.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211502.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211647.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211221.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3）开发dev1确认任务完成&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;退出pm账户，登入dev1账户：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211220.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;或者点进去后，在侧边栏进行标识Done，然后已经完成的issue，可以将其Close&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211454.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这个时候Milestones的进度已经往前进了一些了：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211446.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;4-7-开发其他功能&#34;&gt;4.7 开发其他功能&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;然后其他开发者或者自己再次进行开发时，先要把刚刚更新后的内容（master主干）拉回来，然后再进行开发&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;git checkout master  # 切换到master
git pull             # 从远端仓库拉取数据&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;然后再进行其他操作&lt;/p&gt;
&lt;h2 id=&#34;Gitlab备份恢复&#34;&gt;Gitlab备份恢复&lt;/h2&gt;
&lt;hr&gt;
&lt;h3 id=&#34;5-1-备份gitlab&#34;&gt;5.1 备份gitlab&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1）修改配置文件&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;/etc/gitlab/gitlab.rb&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;备份保存的位置，这里是默认位置，可修改成指定的位置&#34;&gt;备份保存的位置，这里是默认位置，可修改成指定的位置&lt;/h4&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-ruby&#34; data-language=&#34;ruby&#34;&gt;&lt;code class=&#34;language-ruby&#34;&gt;gitlab_rails[&#39;backup_path&#39;] = &#34;/var/opt/gitlab/backups&#34;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h4 id=&#34;设置备份保存的时间，超过此时间的日志将会被新覆盖&#34;&gt;设置备份保存的时间，超过此时间的日志将会被新覆盖&lt;/h4&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-ruby&#34; data-language=&#34;ruby&#34;&gt;&lt;code class=&#34;language-ruby&#34;&gt;gitlab_rails[&#39;backup_keep_time&#39;] = 604800  # 这里是默认设置，保存7天&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h4 id=&#34;特别注意：-如果自定义了备份保存位置，则要修改备份目录的权限，比如：-chown-R-git-git-data-backup-gitlab&#34;&gt;特别注意： # 如果自定义了备份保存位置，则要修改备份目录的权限，比如： # chown -R git.git /data/backup/gitlab&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;配置完成后要重启以使配置生效&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;重读配置文件&#34;&gt;重读配置文件&lt;/h4&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-ruby&#34; data-language=&#34;ruby&#34;&gt;&lt;code class=&#34;language-ruby&#34;&gt;gitlab-ctl reconfigure # 重启gitlab
gitlab-ctl restart&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;2）设置定时任务&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;每天凌晨2点定时创建备份-将一下内容写入到定时任务中-crontab-e&#34;&gt;每天凌晨2点定时创建备份 # 将一下内容写入到定时任务中 crontab -e&lt;/h4&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;0 2 * * * /usr/bin/gitlab-rake gitlab:backup:create # 备份策略建议： # 本地保留3到7天，在异地备份永久保存&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;3）备份时间的识别&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;备份后的文件类似这样的形式：1494170842-gitlab-backup-tar，可以根据前面的时间戳确认备份生成的时间&#34;&gt;备份后的文件类似这样的形式：1494170842_gitlab_backup.tar，可以根据前面的时间戳确认备份生成的时间&lt;/h4&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;data -d  @1494170842&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;5-2-恢复gitlab&#34;&gt;5.2 恢复gitlab&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1）停止数据写入服务&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;停止数据写入服务&#34;&gt;停止数据写入服务&lt;/h4&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;gitlab-ctl stop unicorn
gitlab-ctl stop sidekiq&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;2）进行数据恢复并重启&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;进行恢复&#34;&gt;进行恢复&lt;/h4&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-bash&#34; data-language=&#34;bash&#34;&gt;&lt;code class=&#34;language-bash&#34;&gt;gitlab-rake gitlab:backup:restore BACKUP=1494170842  # 这个时间戳就是刚刚备份的文件前面的时间戳&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h4 id=&#34;重启&#34;&gt;重启&lt;/h4&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-ruby&#34; data-language=&#34;ruby&#34;&gt;&lt;code class=&#34;language-ruby&#34;&gt;gitlab-ctl restart&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;h2 id=&#34;gitlab邮件通知配置&#34;&gt;gitlab邮件通知配置&lt;/h2&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;vim  /etc/gitlab/gitlab.rb&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;&lt;div class=&#34;code-area&#34;&gt;&lt;pre class=&#34;line-numbers language-ruby&#34; data-language=&#34;ruby&#34;&gt;&lt;code class=&#34;language-ruby&#34;&gt;gitlab_rails[&#39;time_zone&#39;] = &#39;Asia/Shanghai&#39; gitlab_rails[&#39;gitlab_email_enabled&#39;] = true
gitlab_rails[&#39;gitlab_email_from&#39;] = &#39;example@163.com&#39; # 填写发件人的邮箱地址
gitlab_rails[&#39;gitlab_email_display_name&#39;] = &#39;gitlab&#39; gitlab_rails[&#39;smtp_enable&#39;] = true
gitlab_rails[&#39;smtp_address&#39;] = &#34;smtp.163.com&#34;  # smtp服务器的地址,如网易的地址
gitlab_rails[&#39;smtp_port&#39;] = 25                 # 要注意如果使用了SSL/TLS的话,端口可能不是25
gitlab_rails[&#39;smtp_user_name&#39;] = &#34;smtp用户名&#34; gitlab_rails[&#39;smtp_password&#39;] = &#34;smtp用户密码&#34; gitlab_rails[&#39;smtp_domain&#39;] = &#34;163.com&#34; gitlab_rails[&#39;smtp_authentication&#39;] = &#34;login&#34;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;
&lt;h2 id=&#34;使用SourceTree进行项目开发&#34;&gt;使用SourceTree进行项目开发&lt;/h2&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;7-1-项目拉取&#34;&gt;7.1 项目拉取&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;先把项目克隆下来&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211633.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211438.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果ssh的方式克隆失败，可能是因为SSH Key没找到，可以在这里添加&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211211.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211201.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;7-2-创建分支进行功能开发&#34;&gt;7.2 创建分支进行功能开发&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1）新建立一个叫“pay”的分支&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211618.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211430.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）进行功能开发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211152.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;7-3-提交项目&#34;&gt;7.3 提交项目&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1）开发pay功能完成后进行提交&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以看到SourceTree中已经有“未提交的更改”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211422.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211144.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）添加“用户信息”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211143.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;** 3）进行提交**&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211415.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注释也可以写成  close #3    ，作用是提交完成后关闭3号issue&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;7-4-推送到仓库&#34;&gt;&lt;strong&gt;7.4 推送到仓库&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211136.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211407.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;然后就可以在gitlab上进行发送merge请求了，后面就可以进行其他操作了&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;7-5-项目上线&#34;&gt;7.5 项目上线&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1）当所有工作完成之后，就可以进行上线了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211135.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）打标签&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;上线先打个标签&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211127.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/09/1320210913211124.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cimg1.17lai.site/data/2021/05/2820210528225256.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;** 3）删除无用分支**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;然后删除已经合并到主干中的不必要的分支，如index、pay等&lt;/li&gt;
&lt;li&gt;最后一定要注意时间一定要同步，不然会错乱&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/hgzero/p/14088215.html&#34;&gt;Praywu&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;Gitlab-使用系列&#34;&gt;Gitlab 使用系列&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;/posts/acc13b70/&#34;&gt;&lt;strong&gt;Gitlab的安装及使用教程完全版&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/29a820b3/&#34;&gt;破解Gitlab EE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/d08eb7b/&#34;&gt;Gitlab的安装及使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/1879721e/&#34;&gt;CI/CD与Git Flow与GitLab&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;i-class-fa-solid-fa-school-i-系列教程&#34;&gt;&lt;i class=&#34;fa-solid fa-school&#34;&gt;&lt;/i&gt;&lt;strong&gt;系列教程&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;/atom.xml&#34;&gt;&lt;i class=&#34;fa-solid fa-square-rss&#34;&gt;&lt;/i&gt;全部文章RSS订阅&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;i-class-fa-brands-fa-square-gitlab-i-Gitlab-使用系列&#34;&gt;&lt;i class=&#34;fa-brands fa-square-gitlab&#34;&gt;&lt;/i&gt;&lt;strong&gt;Gitlab 使用系列&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;/categories/gitlab/atom.xml&#34;&gt;&lt;i class=&#34;fa-solid fa-square-rss&#34;&gt;&lt;/i&gt;&lt;strong&gt;Gitlab RSS 分类订阅&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;/posts/acc13b70/&#34;&gt;&lt;strong&gt;Gitlab的安装及使用教程完全版&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/29a820b3/&#34;&gt;破解Gitlab EE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/d08eb7b/&#34;&gt;Gitlab的安装及使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/1879721e/&#34;&gt;CI/CD与Git Flow与GitLab&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;i-class-fa-brands-fa-dev-i-Devops系列&#34;&gt;&lt;i class=&#34;fa-brands fa-dev&#34;&gt;&lt;/i&gt;&lt;strong&gt;Devops系列&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;/categories/devops/atom.xml&#34;&gt;&lt;i class=&#34;fa-solid fa-square-rss&#34;&gt;&lt;/i&gt;&lt;strong&gt;Devops 分类 RSS 订阅&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;/posts/ab63eb8f/&#34;&gt;自建全套开源Devops开发系统&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/d32a07a7/&#34;&gt;Git介绍以及分支模型图解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/39563241/&#34;&gt;三万字无坑搭建基于Docker+K8S+GitLab/SVN+Jenkins+Harbor持续集成交付环境&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/3437994a/&#34;&gt;DevOps系列—【Jenkinsfile+Dockerfile+nginx+vue】&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/f4c3ad41/&#34;&gt;项目开发管理工具推荐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/acc13b70/&#34;&gt;Gitlab的安装及使用教程完全版&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/d08eb7b/&#34;&gt;Gitlab的安装及使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/posts/78c3371/&#34;&gt;那些有用的Github工具介绍！Action、app、workflow等&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="gitlab" />
        <category term="git" />
        <category term="crack" />
        <updated>2021-07-09T08:25:00.000Z</updated>
    </entry>
</feed>
