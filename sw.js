var cacheStorageKey="17lai-cache-20240413140028";var cacheList=["/css/matery.css?v=1.0.16","/css/my.css?v=1.0.1","/css/highlight.css?v=1.0.0","/css/highlight-dark.css?v=1.0.0","/libs/awesome/css/all.min.css?v=5.15.4","/libs/jquery/jquery.min.js","/libs/materialize/materialize.min.js?v=1.2.2","/libs/materialize/materialize.min.css?v=1.2.2","/libs/masonry/masonry.pkgd.min.js","/libs/aos/aos.min.css","/libs/aos/aos.min.js","/libs/waline/waline-count.js","/js/umami.js?v=1.0.3","/js/color-schema.js?v=1.0.0","/js/plugins.js?v=1.0.0","/js/tw_cn.js?v=1.0.0","/js/boot.js?v=1.0.0","/js/utils.js?v=1.0.6","/js/events.js?v=1.0.0"];self.addEventListener("install",e=>{e.waitUntil(caches.open(cacheStorageKey).then(e=>e.addAll(cacheList)).then(()=>self.skipWaiting()))});self.addEventListener("message",e=>{if(e.data&&e.data.action==="skipWaiting"){self.skipWaiting();console.log("[PWA] rec message skipWaiting")}});self.addEventListener("activate",function(e){console.log("[PWA] Activate");e.waitUntil(caches.keys().then(function(e){return Promise.all(e.map(function(e){if(e!==cacheStorageKey){console.log("[PWA] Removing old cache",e);return caches.delete(e)}}))}));return self.clients.claim()});const customIdentifier="17laiIdentifier";self.addEventListener("message",e=>{if(e.data&&e.data.action==="checkIdentifier"){e.source.postMessage({identifier:customIdentifier})}});const proxyMap={"https://cdn.jsdelivr.net":"https://fastly.jsdelivr.net","https://unpkg.com/@waline/emojis":"https://fastly.jsdelivr.net/npm/@waline/emojis","https://live2dapi.17lai.site":"https://live2d.17lai.site","https://cimg1.17lai.site":"https://cimg1.17lai.fun","https://cdn.17lai.fun":"https://cdn.17lai.site","https://cdn.webpushr.com":"https://cdn-push.17lai.site","https://bot.webpushr.com":"https://bot-push.17lai.site","https://analytics.webpushr.com":"https://analytics-push.17lai.site","https://notevents.webpushr.com":"https://notevents-push.17lai.site"};function isProxyRequired(e){const t=new URL(e);for(const[s,r]of Object.entries(proxyMap)){const n=new URL(s);if(t.origin===n.origin&&t.pathname.startsWith(n.pathname)){return r}}return null}function getMirrorRequired(e){const t=new URL(e);for(const[s,r]of Object.entries(proxyMap)){const n=new URL(s);if(t.origin===n.origin&&t.pathname.startsWith(n.pathname)){const o=e.replace(s,r);return o}}console.log("[PWA]Proxy not required for URL:",e);return e}async function checkWebPushrConnection(e){try{const t=new AbortController;const{signal:s}=t;const r=await fetch("https://webpushr.com",{signal:s,timeout:e});return r.ok}catch(e){console.error("[PWA]Failed to connect to webpushr.com:",e);return false}}function refreshCacheList(e){return caches.open(e).then(s=>{return Promise.all(cacheList.map(t=>{return s.match(t).then(e=>{if(!e){console.log("[PWA] Resource not found in cache, fetching from network:",t);return fetch(t,{cache:"default"}).then(e=>{if(e.ok){console.log("[PWA] Caching resource:",t);s.put(t,e.clone());return e}else{throw new Error(`Failed to fetch ${t}`)}})}else{return e}})}))}).catch(e=>{console.error("[PWA] Failed to refresh cache list:",e)})}self.addEventListener("fetch",async n=>{const e=new URL(n.request.url);n.respondWith(caches.open(cacheStorageKey).then(e=>e.match(n.request,{ignoreSearch:true})).then(e=>{if(e){return e}else{const t=isProxyRequired(n.request.url);const s=fetch(n.request,{cache:"default"});const r=handleProxyRequest(n.request,t);return Promise.race([s.then(e=>{if(e.ok){return e}else{return r}}),r]).catch(e=>{console.log("[PWA] original and proxy requests failed");return fetch(n.request,{cache:"default"})})}}).then(e=>{return refreshCacheList(cacheStorageKey).then(()=>e)}))});async function ProxyRequest(e,t){try{console.log("[PWA]Attempting proxy request to:",t);const s=new URL(e.url);console.log("[PWA]Original URL:",s.href);const r=await fetch(t+e.url.replace(e.referrer,""),e);console.log("[PWA]Proxy request:",t+(e.url.startsWith(e.referrer)?e.url.substring(e.referrer.length):e.url));return r}catch(e){console.error("[PWA]Error proxying request:",e);throw e}}async function handleProxyRequests(e){try{const t=await Promise.all(e.map(async e=>{const t=isProxyRequired(e.url);if(t){const s=getMirrorRequired(e.url);console.log("[PWA]Proxy request:",s);return fetch(s,e,{cache:"default"})}else{return fetch(e,{cache:"default"})}}));return t}catch(e){console.error("[PWA] Error handling proxy requests:",e);throw e}}async function handleProxyRequest(e,t){try{const s=new URL(e.url);const r=getMirrorRequired(s.href);console.log("[PWA]Proxy request:",r);return fetch(r,e,{cache:"default"})}catch(e){console.error("[PWA]Error proxying request:",e);throw e}}