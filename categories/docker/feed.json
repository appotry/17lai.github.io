{
    "version": "https://jsonfeed.org/version/1",
    "title": "夜法之书 • All posts by \"docker\" category",
    "description": "~软件驱动世界~",
    "home_page_url": "https://blog.17lai.site",
    "items": [
        {
            "id": "https://blog.17lai.site/posts/90e60aac/",
            "url": "https://blog.17lai.site/posts/90e60aac/",
            "title": "使用 Shell 脚本实现一个简单 Docker",
            "date_published": "2022-03-18T06:33:17.000Z",
            "content_html": "<blockquote>\n<p>《使用 Shell 脚本实现 Docker》旨在通过一系列的实验使用户对docker的底层技术，如Namespace、CGroups、rootfs、联合加载等有一个感性的认识。在此过程中，我们还将通过Shell脚本一步一步地实现一个简易的docker，以期使读者在使用docker的过程中知其然知其所以然。</p>\n</blockquote>\n<p>我们的实验环境为Ubuntu 18.04 64bit，简易docker工程的名字为docker.sh，该工程仓库地址如下：</p>\n<pre class=\"line-numbers language-html\" data-language=\"html\"><code class=\"language-html\">https://github.com/pandengyang/docker.sh.git\nhttps://github.com/appotry/docker.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>《使用 Shell 脚本实现 Docker》目录如下：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">1. Namespace\n1.1. Namespace简介\n1.2. uts namespace\n1.2.1. uts namespace简介\n1.2.2. docker.sh\n1.3. mount namespace\n1.3.1. /etc/mtab、/proc/self/mounts\n1.3.2. /proc/self/mountinfo\n1.3.3. bind mount\n1.3.4. mount namespace简介\n1.3.5. docker.sh\n1.4. pid namespace\n1.4.1. unshare的--fork选项\n1.4.2. pid namespace简介\n1.4.3. pid嵌套\n1.4.4. docker.sh\n2. CGroups\n2.1. CGroups简介\n2.2. 限制内存\n2.2.1. 用CGroups限制内存\n2.2.2. docker.sh\n3. 切换根文件系统\n3.1. 根文件系统\n3.2. pivot_root\n3.3. docker.sh\n4. 联合加载\n4.1. 联合加载简介\n4.2. AUFS\n4.3. docker.sh\n5. 卷\n5.1. 卷简介\n5.2. docker.sh\n6. 后记<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"1-Namespace\">1.Namespace</h2>\n<h3 id=\"1-1-Namespace简介\">1.1.Namespace简介</h3>\n<p>传统上，在Linux中，许多资源是全局管理的。例如，系统中的所有进程按照惯例是通过PID标识的，这意味着内核必须管理一个全局的PID列表。而且，所有调用者通过uname系统调用返回的系统相关信息都是相同的。用户id的管理方式类似，即各个用户是通过一个全局唯一的UID标识。</p>\n<p>Namespace是Linux用来隔离上述全局资源的一种方式。把一个或多个进程加入到同一个namespace中后，这些进程只会看到该namespace中的资源。namespace是后来加入到Linux中的，为了兼容之前的全局资源管理方式，Linux为每一种资源准备了一个全局的namespace。Linux中的每一个进程都默认加入了这些全局namespace。</p>\n<p>Linux中的每个进程都有一个/proc/[pid]/ns/目录，里面包含了该进程所属的namespace信息。我们查看一下当前Shell的/proc/[pid]/ns目录，命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~$ <span class=\"token function\">sudo</span> <span class=\"token function\">ls</span> -l /proc/<span class=\"token variable\">$$</span>/ns\ntotal <span class=\"token number\">0</span>\nlrwxrwxrwx <span class=\"token number\">1</span> phl phl <span class=\"token number\">0</span> Jan <span class=\"token number\">22</span> 08:43 cgroup -<span class=\"token operator\">&gt;</span> cgroup:<span class=\"token punctuation\">[</span><span class=\"token number\">4026531835</span><span class=\"token punctuation\">]</span>\nlrwxrwxrwx <span class=\"token number\">1</span> phl phl <span class=\"token number\">0</span> Jan <span class=\"token number\">22</span> 08:43 ipc -<span class=\"token operator\">&gt;</span> ipc:<span class=\"token punctuation\">[</span><span class=\"token number\">4026531839</span><span class=\"token punctuation\">]</span>\nlrwxrwxrwx <span class=\"token number\">1</span> phl phl <span class=\"token number\">0</span> Jan <span class=\"token number\">22</span> 08:43 mnt -<span class=\"token operator\">&gt;</span> mnt:<span class=\"token punctuation\">[</span><span class=\"token number\">4026531840</span><span class=\"token punctuation\">]</span>\nlrwxrwxrwx <span class=\"token number\">1</span> phl phl <span class=\"token number\">0</span> Jan <span class=\"token number\">22</span> 08:43 net -<span class=\"token operator\">&gt;</span> net:<span class=\"token punctuation\">[</span><span class=\"token number\">4026531993</span><span class=\"token punctuation\">]</span>\nlrwxrwxrwx <span class=\"token number\">1</span> phl phl <span class=\"token number\">0</span> Jan <span class=\"token number\">22</span> 08:43 pid -<span class=\"token operator\">&gt;</span> pid:<span class=\"token punctuation\">[</span><span class=\"token number\">4026531836</span><span class=\"token punctuation\">]</span>\nlrwxrwxrwx <span class=\"token number\">1</span> phl phl <span class=\"token number\">0</span> Jan <span class=\"token number\">22</span> 08:43 pid_for_children -<span class=\"token operator\">&gt;</span> pid:<span class=\"token punctuation\">[</span><span class=\"token number\">4026531836</span><span class=\"token punctuation\">]</span>\nlrwxrwxrwx <span class=\"token number\">1</span> phl phl <span class=\"token number\">0</span> Jan <span class=\"token number\">22</span> 08:43 user -<span class=\"token operator\">&gt;</span> user:<span class=\"token punctuation\">[</span><span class=\"token number\">4026531837</span><span class=\"token punctuation\">]</span>\nlrwxrwxrwx <span class=\"token number\">1</span> phl phl <span class=\"token number\">0</span> Jan <span class=\"token number\">22</span> 08:43 uts -<span class=\"token operator\">&gt;</span> uts:<span class=\"token punctuation\">[</span><span class=\"token number\">4026531838</span><span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>该目录下有很多符号链接，每个符号链接代表一个该进程所属的namespace。用readlink读取这些符号链接可以查看进程所属的namespace id。我们读一下当前Shell所属的uts namespace id，命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~$ <span class=\"token function\">sudo</span> readlink /proc/<span class=\"token variable\">$$</span>/ns/uts\nuts:<span class=\"token punctuation\">[</span><span class=\"token number\">4026531838</span><span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>后文中我们将介绍uts namespace、mount namespace、pid namespace的用法。</p>\n<h3 id=\"1-2-uts-namespace\">1.2.uts namespace</h3>\n<h4 id=\"1-2-1-uts-namespace简介\">1.2.1.uts namespace简介</h4>\n<p>uts namespace用于隔离系统的主机名等信息，我们将通过实验学习其用法。在实验过程中，我们采用如下的步骤：</p>\n<ol>\n<li>查看全局uts namespace信息</li>\n<li>新建一个uts namespace，查看其信息并作出修改</li>\n<li>查看全局uts namespace，查看其是否被新建的uts namespace影响到</li>\n</ol>\n<p>对于其他namespace，我们也采取类似的步骤进行实验学习。</p>\n<p>首先，我们查看一下全局的hostname及uts namespace id。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~$ <span class=\"token function\">hostname</span>\nkernelnewbies\n\nphl@kernelnewbies:~$ <span class=\"token function\">sudo</span> readlink /proc/<span class=\"token variable\">$$</span>/ns/uts\nuts:<span class=\"token punctuation\">[</span><span class=\"token number\">4026531838</span><span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>然后，我们创建一个新的uts namespace，并查看其namespce id。</p>\n<p>在继续之前，需要介绍一个namespace工具unshare。利用unshare我们可以新建一个的namespace，并在新namespace中执行一条命令。unshare执行时需要root权限。unshare的使用方法如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">unshare <span class=\"token punctuation\">[</span>options<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">[</span>program <span class=\"token punctuation\">[</span>arguments<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>执行unshare时，我们可以指定要新建的namespace的类型以及要执行的命令。unshare提供了一系列选项，当指定某个选项时可新建指定的namespace。namespace类型选项如下：</p>\n<ul>\n<li>--uts创建新的uts namespace</li>\n<li>--mount创建新的mount namespace</li>\n<li>--pid创建新的pid namespace</li>\n<li>--user创建新的user namespace</li>\n</ul>\n<p>介绍完unshare之后，我们继续之前的实验。我们用unshare创建一个新的uts namespace，并在新的uts namespace中执行/bin/bash命令，命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~$ <span class=\"token function\">sudo</span> unshare --uts /bin/bash\nroot@kernelnewbies:~<span class=\"token comment\">#</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>我们用unshare创建了一个新的uts namespace。在新的uts namespace中查看其hostname和namespace id，命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">root@kernelnewbies:~$ <span class=\"token function\">hostname</span>\nkernelnewbies\n\nroot@kernelnewbies:~<span class=\"token comment\"># readlink /proc/$$/ns/uts</span>\nuts:<span class=\"token punctuation\">[</span><span class=\"token number\">4026532177</span><span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>从结果我们可以看到，新uts namespace的id与全局uts namespace的id不一致。这说明/bin/bash已运行在一个新的uts namespace中了。</p>\n<p>我们将新uts namespace的hostname改为dreamland，并强制更新Shell提示符。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">root@kernelnewbies:~<span class=\"token comment\"># hostname dreamland</span>\nroot@kernelnewbies:~<span class=\"token comment\"># hostname</span>\ndreamland\n\nroot@kernelnewbies:~<span class=\"token comment\"># exec /bin/bash</span>\nroot@dreamland:~<span class=\"token comment\">#</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>从结果我们可以看到，新uts namespace的hostname的确是被修改了，exec /bin/bash用于强制更新Shell的提示符。</p>\n<p>我们重新打开一个Shell窗口，该Shell位于全局uts namespace中。在新的Shell窗口中查看全局uts namespace id及hostname，命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~$ <span class=\"token function\">hostname</span>\nkernelnewbies\n\nphl@kernelnewbies:~$ <span class=\"token function\">sudo</span> readlink /proc/<span class=\"token variable\">$$</span>/ns/uts\nuts:<span class=\"token punctuation\">[</span><span class=\"token number\">4026531838</span><span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>从结果我们可以看到，我们在新uts namespace中所作的修改并未影响到全局的uts namespace。</p>\n<p>父进程创建子进程时只有提供创建新namespace的标志，才可创建新的namespace，并使子进程处于新的namespace中。默认情况下，子进程与父进程处于相同的namespace中。我们在新的uts namespace中创建一个子进程，然后查看该子进程的uts namespace id，命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~$ <span class=\"token function\">sudo</span> unshare --uts /bin/bash\nroot@kernelnewbies:~<span class=\"token comment\"># readlink /proc/$$/ns/uts</span>\nuts:<span class=\"token punctuation\">[</span><span class=\"token number\">4026532305</span><span class=\"token punctuation\">]</span>\n\nroot@kernelnewbies:~<span class=\"token comment\"># bash</span>\nroot@kernelnewbies:~<span class=\"token comment\"># readlink /proc/$$/ns/uts</span>\nuts:<span class=\"token punctuation\">[</span><span class=\"token number\">4026532305</span><span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>从结果我们可以看到，子进程所属uts namespace的id与其父进程相同。其他namespae与uts namespace类似，子进程与父进程同属一个namespace。</p>\n<h4 id=\"1-2-2-docker-sh\">1.2.2.docker.sh</h4>\n<p>有了以上关于uts namespace的介绍，我们就可以将uts namespace加入到docker.sh中了。docker.sh工程分为两个脚本：docker.sh和container.sh。</p>\n<p>docker.sh用于收集用户输入、调用unshare创建namespace并执行container.sh脚本，docker.sh脚本如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token function-name function\">usage</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token builtin class-name\">echo</span> -e <span class=\"token string\">\"<span class=\"token entity\" title=\"\\033\">\\033</span>[31mIMPORTANT: Run As Root<span class=\"token entity\" title=\"\\033\">\\033</span>[0m\"</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"\"</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Usage:    docker.sh [OPTIONS]\"</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"\"</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"A docker written by shell\"</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"\"</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Options:\"</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"          -c string       docker command\"</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"                          (<span class=\"token entity\" title=\"\\&quot;\">\\\"</span>run<span class=\"token entity\" title=\"\\&quot;\">\\\"</span>)\"</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"          -m              memory\"</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"                          (<span class=\"token entity\" title=\"\\&quot;\">\\\"</span>100M, 200M, 300M...<span class=\"token entity\" title=\"\\&quot;\">\\\"</span>)\"</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"          -C string       container name\"</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"          -I string       image name\"</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"          -V string       volume\"</span>\n        <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"          -P string       program to run in container\"</span>\n\n        <span class=\"token builtin class-name\">return</span> <span class=\"token number\">0</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token builtin class-name\">test</span> <span class=\"token string\">\"<span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">whoami</span><span class=\"token variable\">)</span></span>\"</span> <span class=\"token operator\">!=</span> root\n<span class=\"token keyword\">then</span>\n        usage\n        <span class=\"token builtin class-name\">exit</span> -1\n<span class=\"token keyword\">fi</span>\n\n<span class=\"token keyword\">while</span> <span class=\"token builtin class-name\">getopts</span> c:m:C:I:V:P: option\n<span class=\"token keyword\">do</span>\n        <span class=\"token keyword\">case</span> <span class=\"token string\">\"<span class=\"token variable\">$option</span>\"</span>\n        <span class=\"token keyword\">in</span>\n                c<span class=\"token punctuation\">)</span> <span class=\"token assign-left variable\">cmd</span><span class=\"token operator\">=</span><span class=\"token variable\">$OPTARG</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n                m<span class=\"token punctuation\">)</span> <span class=\"token assign-left variable\">memory</span><span class=\"token operator\">=</span><span class=\"token variable\">$OPTARG</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n                C<span class=\"token punctuation\">)</span> <span class=\"token assign-left variable\">container</span><span class=\"token operator\">=</span><span class=\"token variable\">$OPTARG</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n                I<span class=\"token punctuation\">)</span> <span class=\"token assign-left variable\">image</span><span class=\"token operator\">=</span><span class=\"token variable\">$OPTARG</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n                V<span class=\"token punctuation\">)</span> <span class=\"token assign-left variable\">volume</span><span class=\"token operator\">=</span><span class=\"token variable\">$OPTARG</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n                P<span class=\"token punctuation\">)</span> <span class=\"token assign-left variable\">program</span><span class=\"token operator\">=</span><span class=\"token variable\">$OPTARG</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">\\</span>?<span class=\"token punctuation\">)</span> usage\n                    <span class=\"token builtin class-name\">exit</span> -2<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">esac</span>\n<span class=\"token keyword\">done</span>\n\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">cmd</span><span class=\"token operator\">=</span><span class=\"token variable\">$cmd</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">memory</span><span class=\"token operator\">=</span><span class=\"token variable\">$memory</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">container</span><span class=\"token operator\">=</span><span class=\"token variable\">$container</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">image</span><span class=\"token operator\">=</span><span class=\"token variable\">$image</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">volume</span><span class=\"token operator\">=</span><span class=\"token variable\">$volume</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">program</span><span class=\"token operator\">=</span><span class=\"token variable\">$program</span>\n\nunshare --uts ./container.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>脚本最开始为usage函数，该函数为docker.sh的使用说明。当用户以非预期的方式使用docker.sh时，该函数会被调用。该函数输出如下信息：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">IMPORTANT: Run As Root\n\nUsage:  docker.sh <span class=\"token punctuation\">[</span>OPTIONS<span class=\"token punctuation\">]</span>\n\nA <span class=\"token function\">docker</span> written by shell\n\nOptions:\n                -c string       <span class=\"token function\">docker</span> <span class=\"token builtin class-name\">command</span>\n                                <span class=\"token punctuation\">(</span><span class=\"token string\">\"run\"</span><span class=\"token punctuation\">)</span>\n                -m              memory\n                                <span class=\"token punctuation\">(</span><span class=\"token string\">\"100M, 200M, 300M...\"</span><span class=\"token punctuation\">)</span>\n                -C string       container name\n                -I string       image name\n                -V string       volume\n                -P string       program to run <span class=\"token keyword\">in</span> container<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>从usage函数的输出我们可以看到，执行docker.sh时需要root权限且需要正确地传递参数。</p>\n<p>docker.sh首先对当前用户进行检测，如果用户不为root，则打印使用说明并退出脚本；如果用户为root，则继续执行。检测用户的脚本如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">if</span> <span class=\"token builtin class-name\">test</span> <span class=\"token string\">\"<span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">whoami</span><span class=\"token variable\">)</span></span>\"</span> <span class=\"token operator\">!=</span> root\n<span class=\"token keyword\">then</span>\n        usage\n        <span class=\"token builtin class-name\">exit</span> -1\n<span class=\"token keyword\">fi</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>然后，docker.sh使用getopts从命令行提取参数，然后赋值给合适的变量。从命令行提取参数的脚本如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token keyword\">while</span> <span class=\"token builtin class-name\">getopts</span> c:m:C:I:V:P: option\n<span class=\"token keyword\">do</span>\n        <span class=\"token keyword\">case</span> <span class=\"token string\">\"<span class=\"token variable\">$option</span>\"</span>\n        <span class=\"token keyword\">in</span>\n                c<span class=\"token punctuation\">)</span> <span class=\"token assign-left variable\">cmd</span><span class=\"token operator\">=</span><span class=\"token variable\">$OPTARG</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n                m<span class=\"token punctuation\">)</span> <span class=\"token assign-left variable\">memory</span><span class=\"token operator\">=</span><span class=\"token variable\">$OPTARG</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n                C<span class=\"token punctuation\">)</span> <span class=\"token assign-left variable\">container</span><span class=\"token operator\">=</span><span class=\"token variable\">$OPTARG</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n                I<span class=\"token punctuation\">)</span> <span class=\"token assign-left variable\">image</span><span class=\"token operator\">=</span><span class=\"token variable\">$OPTARG</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n                V<span class=\"token punctuation\">)</span> <span class=\"token assign-left variable\">volume</span><span class=\"token operator\">=</span><span class=\"token variable\">$OPTARG</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n                P<span class=\"token punctuation\">)</span> <span class=\"token assign-left variable\">program</span><span class=\"token operator\">=</span><span class=\"token variable\">$OPTARG</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">\\</span>?<span class=\"token punctuation\">)</span> usage\n                    <span class=\"token builtin class-name\">exit</span> -2<span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">esac</span>\n<span class=\"token keyword\">done</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>如果用户的输入不正确，则打印使用说明并退出脚本；如果用户输入正确，则解析命令行参数并赋值给合适的变量。</p>\n<p>为了简化，用户在运行docker.sh时需提供完整的参数列表，示例如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> ./docker.sh -c run -m 100M -C dreamland -I ubuntu1604 -V data1 -P /bin/bash<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>当然，如果当前用户就是root，就不需要sudo了。下表列出了各个参数的含义及示例：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2022/03/1820220318143125.png\" alt=\"使用 Shell 脚本实现 Docker\"></p>\n<p>docker.sh将命令行参数赋值给变量后，需要将这些变量导出，以传递给container.sh。导出变量的脚本如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">cmd</span><span class=\"token operator\">=</span><span class=\"token variable\">$cmd</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">memory</span><span class=\"token operator\">=</span><span class=\"token variable\">$memory</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">container</span><span class=\"token operator\">=</span><span class=\"token variable\">$container</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">image</span><span class=\"token operator\">=</span><span class=\"token variable\">$image</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">volume</span><span class=\"token operator\">=</span><span class=\"token variable\">$volume</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">program</span><span class=\"token operator\">=</span><span class=\"token variable\">$program</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这里说明一下为什么要将docker.sh工程拆分为docker.sh和container.sh两个脚本。因为调用unshare创建新的namespace时，会执行一个命令，该命令在新的namespace中运行。该命令一旦结束，unshare也就结束了，unshare创建的新namespace也就不存在了。</p>\n<p>docker.sh不会并发地执行unshare命令与unshare之后的脚本，因此，只有unshare结束了，后续脚本才可继续运行。但是当unshare结束了，准备执行后续脚本时，新的namespae已经不存在了。因此一些加入cgroups、切换根文件系统等工作必须在unshare执行的命令中进行，所以我们采用在unshare中执行container.sh脚本的方式完成后续的工作。</p>\n<p>最后，docker.sh调用unshare创建新的uts namespace，并执行container.sh脚本。调用unshare的脚本如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">unshare --uts ./container.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>container.sh将容器的hostname修改为通过-C传递的容器的名字，然后执行通过-P传递的程序。container.sh脚本如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token function\">hostname</span> <span class=\"token variable\">$container</span>\n<span class=\"token builtin class-name\">exec</span> <span class=\"token variable\">$program</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>现在，我们运行docker.sh，并查看其hostname。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~/docker.sh$ <span class=\"token function\">sudo</span> ./docker.sh -c run -m 100M -C dreamland -I ubuntu1604 -V data1 -P /bin/bash\nroot@dreamland:~/docker.sh<span class=\"token comment\"># hostname</span>\ndreamland<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>从结果我们可以看到，容器的hostname已经改变为我们传递的容器名字dreamland了。</p>\n<h3 id=\"1-3-mount-namespace\">1.3.mount namespace</h3>\n<h4 id=\"1-3-1-etc-mtab、-proc-self-mounts\">1.3.1./etc/mtab、/proc/self/mounts</h4>\n<p>早期的Linux使用/etc/mtab文件来记录当前的挂载点信息。每次mount/umount文件系统时会更新/etc/mtab文件中的信息。</p>\n<p>后来，linux引入了mount namespace，每个进程都有一份自己的挂载点信息。当然，处于同一个mount namespace里面的进程，其挂载点信息是相同的。进程的挂载点信息通过/proc/[pid]/mounts文件导出给用户。</p>\n<p>为了兼容以前的/etc/mtab，/etc/mtab变成了指向/proc/self/mounts的符号链接。通过readlink查看/etc/mtab指向的文件，命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~$ readlink /etc/mtab\n<span class=\"token punctuation\">..</span>/proc/self/mounts<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>通过读取/proc/self/mounts文件，可以查看当前的挂载点信息，命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~$ <span class=\"token function\">cat</span> /proc/self/mounts\nsysfs /sys sysfs rw,nosuid,nodev,noexec,relatime <span class=\"token number\">0</span> <span class=\"token number\">0</span>\nproc /proc proc rw,nosuid,nodev,noexec,relatime <span class=\"token number\">0</span> <span class=\"token number\">0</span>\n/dev/sda1 / ext4 rw,relatime,errors<span class=\"token operator\">=</span>remount-ro <span class=\"token number\">0</span> <span class=\"token number\">0</span>\nsecurityfs /sys/kernel/security securityfs rw,nosuid,nodev,noexec,relatime <span class=\"token number\">0</span> <span class=\"token number\">0</span>\n<span class=\"token punctuation\">..</span>.<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>由于该文件中内容太多，我们省略了一部分，只保留了一些比较重要的挂载点信息。每行的信息分为六个字段，各字段的含义及示例如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2022/03/1820220318143143.png\" alt=\"使用 Shell 脚本实现 Docker\"></p>\n<p>由于该文件有点过时，被后文介绍的/proc/self/mountinfo替换掉，所以不做过多介绍。</p>\n<h4 id=\"1-3-2-proc-self-mountinfo\">1.3.2./proc/self/mountinfo</h4>\n<p>/proc/self/mountinfo包含了进程mount namespace中的挂载点信息。 它提供了旧的/proc/[pid]/mounts文件中缺少的各种信息（传播状态，挂载点id，父挂载点id等），并解决了/proc/[pid]/mounts文件的一些其他缺陷。我们查看进程挂载点信息时应优先使用该文件。</p>\n<p>该文件中每一行代表一个挂载点信息，每个挂载点信息分为11个字段。挂载点信息的示例如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2022/03/1820220318143124.png\" alt=\"使用 Shell 脚本实现 Docker\"></p>\n<p>各字段的含义及示例如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2022/03/1820220318143118.png\" alt=\"使用 Shell 脚本实现 Docker\"></p>\n<p>我们主要关注可选字段中的传播状态选项。首先，我们看一下关于mount namespace的问题。问题如下：</p>\n<p>当创建mount namespace时，新mount namespace会拷贝一份老mount namespace里面的挂载点信息。例如，全局mount namespace中有一个/a挂载点，新建的mount namespace中也会有一个/a挂载点。那么我们在新mount namespace中的/a下创建或删除一个挂载点，全局mount namespace中的/a会同步创建或删除该挂载点吗？或者在全局mount namespace中的/a下创建或删除一个挂载点，新mount namespace中的/a会同步创建或删除该挂载点吗？</p>\n<p>mountinfo文件中可选字段的传播状态就是控制在一个挂载点下进行创建/删除挂载点操作时是否会传播到其他挂载点的选项。传播状态有四种可取值，常见的有如下两种：</p>\n<ul>\n<li>shared 表示创建/删除挂载点的操作会传播到其他挂载点</li>\n<li>private 表示创建/删除挂载点的操作不会传播到其他挂载点</li>\n</ul>\n<p>由于在容器技术中要保证主机与容器的挂载点信息互不影响，因此要求容器中的挂载点的传播状态为private。</p>\n<h4 id=\"1-3-3-bind-mount\">1.3.3.bind mount</h4>\n<p>bind mount可以将一个目录（源目录）挂载到另一个目录（目的目录），在目的目录里面的读写操作将直接作用于源目录。</p>\n<p>下面我们通过实验了解一下bind mount的功能，首先，我们准备一下实验所需要的的目录及文件。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~$ <span class=\"token function\">mkdir</span> <span class=\"token builtin class-name\">bind</span>\nphl@kernelnewbies:~$ <span class=\"token builtin class-name\">cd</span> bind/\nphl@kernelnewbies:~/bind$ <span class=\"token function\">mkdir</span> a\nphl@kernelnewbies:~/bind$ <span class=\"token function\">mkdir</span> b\nphl@kernelnewbies:~/bind$ <span class=\"token builtin class-name\">echo</span> hello, a <span class=\"token operator\">&gt;</span> a/a.txt\nphl@kernelnewbies:~/bind$ <span class=\"token builtin class-name\">echo</span> hello, b <span class=\"token operator\">&gt;</span> b/b.txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>然后，我们将a目录bind mount到b目录并查看b目录下的内容。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~/bind$ <span class=\"token function\">sudo</span> <span class=\"token function\">mount</span> --bind a b\nphl@kernelnewbies:~/bind$ tree b\nb\n└── a.txt\n<span class=\"token number\">0</span> directories, <span class=\"token number\">1</span> <span class=\"token function\">file</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>从结果我们可以看到，b目录下原先的内容被隐藏，取而代之的是a目录下的内容。</p>\n<p>然后，我们修改b目录下的内容，修改完毕后，从b目录上卸载掉a目录。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~/bind$ <span class=\"token builtin class-name\">echo</span> hello, a from b <span class=\"token operator\">&gt;</span> b/a.txt\nphl@kernelnewbies:~/bind$ <span class=\"token function\">sudo</span> <span class=\"token function\">umount</span> b<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>我们读取一下a目录中a.txt，看看其内容是否被改变。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~/bind$ <span class=\"token function\">cat</span> a/a.txt\nhello, a from b<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>从结果我们可以看到，a目录中的内容确实被当a被bind mount到b时对b目录的操作所修改了。</p>\n<p>bind mount在容器技术中有很重要的用途，后文会有涉及。</p>\n<h4 id=\"1-3-4-mount-namespace简介\">1.3.4.mount namespace简介</h4>\n<p>mount namespace用来隔离文件系统的挂载点信息, 使得不同的mount namespace拥有自己独立的挂载点信息。不同的namespace之间不会相互影响，其在unshare中的选项为--mount。</p>\n<p>当用unshare创建新的mount namespace时，新创建的namespace将拷贝一份老namespace里的挂载点信息，但从这之后，他们就没有关系了。这是unshare将新 namespace 里面的所有挂载点的传播状态设置为private实现的。通过mount和umount增加和删除各自mount namespace里面的挂载点都不会相互影响。</p>\n<p>下面我们将演示mount namespace的用法。首先，我们准备需要的目录和文件，命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~$ <span class=\"token function\">mkdir</span> -p hds/hd1 hds/hd2 <span class=\"token operator\">&amp;&amp;</span> <span class=\"token builtin class-name\">cd</span> hds\n\nphl@kernelnewbies:~/hds$ <span class=\"token function\">dd</span> <span class=\"token assign-left variable\">if</span><span class=\"token operator\">=</span>/dev/zero <span class=\"token assign-left variable\">bs</span><span class=\"token operator\">=</span>1M <span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token number\">1</span> <span class=\"token assign-left variable\">of</span><span class=\"token operator\">=</span>hd1.img <span class=\"token operator\">&amp;&amp;</span> mkfs.ext2 hd1.img\nphl@kernelnewbies:~/hds$ <span class=\"token function\">dd</span> <span class=\"token assign-left variable\">if</span><span class=\"token operator\">=</span>/dev/zero <span class=\"token assign-left variable\">bs</span><span class=\"token operator\">=</span>1M <span class=\"token assign-left variable\">count</span><span class=\"token operator\">=</span><span class=\"token number\">1</span> <span class=\"token assign-left variable\">of</span><span class=\"token operator\">=</span>hd2.img <span class=\"token operator\">&amp;&amp;</span> mkfs.ext2 hd2.img\n\nphl@kernelnewbies:~$ tree <span class=\"token builtin class-name\">.</span>\n<span class=\"token builtin class-name\">.</span>\n├── hd1\n├── hd1.img\n├── hd2\n└── hd2.img\n<span class=\"token number\">2</span> directories, <span class=\"token number\">2</span> files<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>然后，我们在全局的mount namespace中挂载hd1.img到hd1目录，然后查看该mount namespace中的挂载点信息与mount namespace id。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~/hds$ <span class=\"token function\">sudo</span> <span class=\"token function\">mount</span> hd1.img hd1\nphl@kernelnewbies:~/hds$ <span class=\"token function\">cat</span> /proc/self/mountinfo <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> hd\n<span class=\"token number\">556</span> <span class=\"token number\">27</span> <span class=\"token number\">7</span>:18 / /home/phl/hds/hd1 rw,relatime shared:372 - ext2 /dev/loop18 rw\n\nphl@kernelnewbies:~/hds$ <span class=\"token function\">sudo</span> readlink /proc/<span class=\"token variable\">$$</span>/ns/mnt\nmnt:<span class=\"token punctuation\">[</span><span class=\"token number\">4026531840</span><span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>然后，执行unshare命令创建一个新的mount namespace并查看该mount namespace id和挂载点信息。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~/hds$ <span class=\"token function\">sudo</span> unshare --uts --mount /bin/bash\nroot@kernelnewbies:~/hds<span class=\"token comment\"># cat /proc/self/mountinfo | grep hd</span>\n<span class=\"token number\">739</span> <span class=\"token number\">570</span> <span class=\"token number\">7</span>:18 / /home/phl/hds/hd1 rw,relatime - ext2 /dev/loop18 rw\n\nroot@kernelnewbies:~/hds<span class=\"token comment\"># readlink /proc/$$/ns/mnt</span>\nmnt:<span class=\"token punctuation\">[</span><span class=\"token number\">4026532180</span><span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>从结果我们可以看到，新mount namespace中的挂载点信息与全局mountnamespace中的挂载点信息基本一致，一些挂载选项（如传播状态）变化了。新的mount namespace id与全局mount namespace id是不一样的。</p>\n<p>然后，我们在新的mount namespace中挂载hd2.img到hd2目录，并查看挂载点信息。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">root@kernelnewbies:~/hds<span class=\"token comment\"># mount hd2.img hd2</span>\nroot@kernelnewbies:~/hds<span class=\"token comment\"># cat /proc/self/mountinfo | grep hd</span>\n<span class=\"token number\">739</span> <span class=\"token number\">570</span> <span class=\"token number\">7</span>:18 / /home/phl/hds/hd1 rw,relatime - ext2 /dev/loop18 rw\n<span class=\"token number\">740</span> <span class=\"token number\">570</span> <span class=\"token number\">7</span>:19 / /home/phl/hds/hd2 rw,relatime - ext2 /dev/loop19 rw<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>从结果我们可以看到，新mount namespace中有hd1和hd2这两个挂载点。现在启动一个新的Shell窗口，查看全局mount namespace中的挂载点信息。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~/hds$ <span class=\"token function\">cat</span> /proc/self/mountinfo <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> hd\n<span class=\"token number\">556</span> <span class=\"token number\">27</span> <span class=\"token number\">7</span>:18 / /home/phl/hds/hd1 rw,relatime shared:372 - ext2 /dev/loop18 rw<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>从结果我们可以看到，全局mount namespace中的挂载点信息只有hd1，而没有hd2。这说明在新mount namespace中进行挂载/卸载操作不会影响其他mount namespace中的挂载点信息。</p>\n<p>mount namespace只隔离挂载点信息，并不隔离挂载点下面的文件信息。对于多个mount namespace都能看到的挂载点，如果在一个namespace中修改了挂载点下面的文件，其他namespace也能感知到。下面，我们在新建的mount namespace中创建一个文件，命令如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">root@kernelnewbies:~/hds<span class=\"token comment\"># echo hello from new mount namespace &gt; hd1/hello.txt</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>在新启动的Shell中，查看hd1目录并读取hd1/hello.txt文件。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~/hds$ tree hd1\nhd1\n├── hello.txt\n└── lost+found <span class=\"token punctuation\">[</span>error opening dir<span class=\"token punctuation\">]</span>\n<span class=\"token number\">1</span> directory, <span class=\"token number\">1</span> <span class=\"token function\">file</span>\n\nphl@kernelnewbies:~/hds$ <span class=\"token function\">cat</span> hd1/hello.txt\nhello from new <span class=\"token function\">mount</span> namespace<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>从结果我们可以看到，在全局mount namespace中，我们可以读取到在新建的mount namespace中创建的文件。</p>\n<h4 id=\"1-3-5-docker-sh\">1.3.5.docker.sh</h4>\n<p>有了以上关于mount namespace的知识，我们就可以将mount namespace加入到docker.sh中了。mount namespace将放在docker.sh中，带下划线的行是我们为实现mount namespace而修改的代码。修改后的docker.sh脚本如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">..</span>.\nunshare --uts --mount ./container.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>从上述代码我们可以看到，我们仅仅是在调用unshare时加入--mount选项，就可为docker.sh引入了mount namespace功能。</p>\n<h3 id=\"1-4-pid-namespace\">1.4.pid namespace</h3>\n<h4 id=\"1-4-1-unshare的-fork选项\">1.4.1.unshare的--fork选项</h4>\n<p>unshare有一个选项--fork，当执行unshare时，如果没有这个选项，unshare会直接exec新命令，也就是说unshare变成了新命令。如果带有--fork选项，unshare会fork一个子进程，该子进程exec新命令，unshare是该子进程的父进程。我们分别不带--fork和带--fork来执行unshare，然后查看进程之间的关系。</p>\n<p>首先，我们不带--fork选项执行unshare，并查看当前Shell的进程id。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~$ <span class=\"token function\">sudo</span> unshare --uts /bin/bash\nroot@kernelnewbies:~/hds<span class=\"token comment\"># echo $$</span>\n<span class=\"token number\">11699</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>此时unshare会创建一个新的uts namespace，然后exec /bin/bash。我们启动一个新Shell，然后使用pstree查看进程间关系，命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~/hds$ pstree -p <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> <span class=\"token number\">11699</span>\nsudo<span class=\"token punctuation\">(</span><span class=\"token number\">11698</span><span class=\"token punctuation\">)</span>---bash<span class=\"token punctuation\">(</span><span class=\"token number\">11699</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>从结果我们可以看到，sudo fork出一个子进程，该子进程执行unshare。unshare创建了新uts namespace后，exec了/bin/bash，也就是说unshare变成了/bin/bash。</p>\n<p>然后，我们带--fork选项执行unshare，并查看当前Shell的进程id。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~/hds$ <span class=\"token function\">sudo</span> unshare --uts --fork /bin/bash\nroot@kernelnewbies:~/hds<span class=\"token comment\"># echo $$</span>\n<span class=\"token number\">11866</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>此时unshare会创建一个新的uts namespace，然后fork出一个子进程，该子进程exec /bin/bash。我们启动一个新Shell，然后使用pstree查看进程间关系，命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~/hds$ pstree -p <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> <span class=\"token number\">11866</span>\nsudo<span class=\"token punctuation\">(</span><span class=\"token number\">11864</span><span class=\"token punctuation\">)</span>---unshare<span class=\"token punctuation\">(</span><span class=\"token number\">11865</span><span class=\"token punctuation\">)</span>---bash<span class=\"token punctuation\">(</span><span class=\"token number\">11866</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>从结果我们可以看到，sudo fork出一个子进程，该子进程执行命令unshare。unshare创建了新uts namespace后，fork出一个子进程，该子进程exec /bin/bash，也就是说unshare变成了新的/bin/bash进程的父进程。</p>\n<h4 id=\"1-4-2-pid-namespace简介\">1.4.2.pid namespace简介</h4>\n<p>pid namespace用来隔离进程pid空间，使得不同pid namespace里的进程 pid可以重复且相互之间不影响。进程所属的pid namespace在创建的时候就确定了，无法更改，因此需要--fork选项来创建一个新进程，然后将该新进程加入新建的pid namespace中。pid namespace在unshare中的选项为--pid。</p>\n<p>unshare在创建pid namespace时需同时提供--pid与--fork选项。unshare本身会加入全局的pid namespace，其fork出的子进程会加入新建的pid namespace。</p>\n<p>首先，我们查看全局pid namespace id，命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~$ <span class=\"token function\">sudo</span> readlink /proc/<span class=\"token variable\">$$</span>/ns/pid\npid:<span class=\"token punctuation\">[</span><span class=\"token number\">4026531836</span><span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>然后，执行unshare命令创建一个新的pid namespace并查看该pid namespace id。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~$ <span class=\"token function\">sudo</span> unshare --mount --pid --fork /bin/bash\nroot@kernelnewbies:~<span class=\"token comment\"># readlink /proc/$$/ns/pid</span>\npid:<span class=\"token punctuation\">[</span><span class=\"token number\">4026531836</span><span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>从结果我们可以看到，新创建的进程也处于全局pid namespace中，而不是新的pid namespace。</p>\n<p>出现这种情形是因为当前的/proc文件系统是老的。我们查看一下$$的值，命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">root@kernelnewbies:~<span class=\"token comment\"># echo $$</span>\n<span class=\"token number\">1</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>从结果我们可以看到，$$的值为1，但是/proc文件系统却是老的，因此我们查看的实际是init进程所属的pid namespace，当然是全局pid namespace了。</p>\n<p>重新挂载/proc文件系统，这也是unshare执行时带--mount选项的原因，只有这样，重新挂载/proc文件系统时，不会搞乱整个系统。再次查看新进程所属的pid namespace，命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">root@kernelnewbies:~<span class=\"token comment\"># mount -t proc proc /proc</span>\nroot@kernelnewbies:~<span class=\"token comment\"># readlink /proc/$$/ns/pid</span>\npid:<span class=\"token punctuation\">[</span><span class=\"token number\">4026532182</span><span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>从结果我们可以看到，新进程的pid namespace与全局pid namespace的id不同。</p>\n<p>接下来，我们再来查看一下新pid namespace中的进程信息。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">root@kernelnewbies:~<span class=\"token comment\"># ps -ef</span>\n<span class=\"token environment constant\">UID</span>        PID  <span class=\"token environment constant\">PPID</span>  C STIME TTY          TIME CMD\nroot         <span class=\"token number\">1</span>     <span class=\"token number\">0</span>  <span class=\"token number\">0</span> <span class=\"token number\">19</span>:03 pts/1    00:00:00 /bin/bash\nroot        <span class=\"token number\">10</span>     <span class=\"token number\">1</span>  <span class=\"token number\">0</span> <span class=\"token number\">19</span>:03 pts/1    00:00:00 <span class=\"token function\">ps</span> -e<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>从结果我们可以看到，当前pid namespace中只有2个进程，看不到全局pid namespace里面的其他进程。我们通过unshare执行的进程pid为1，也就是说该进程成了新pid namespace中的init进程。</p>\n<h4 id=\"1-4-3-pid嵌套\">1.4.3.pid嵌套</h4>\n<p>pid namespace可以嵌套，也就是说有父子关系，在当前pid namespace里面创建的所有新的pid namespace都是当前pid namespace的子pid namespace。</p>\n<p>首先，我们创建3个嵌套的pid namespace，并查看每个pid namespace id。--mount-proc选项用于自动挂载/proc文件系统，省去了手动挂载/proc文件系统的操作。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~$ <span class=\"token function\">sudo</span> readlink /proc/<span class=\"token variable\">$$</span>/ns/pid\npid:<span class=\"token punctuation\">[</span><span class=\"token number\">4026531836</span><span class=\"token punctuation\">]</span>\n\nphl@kernelnewbies:~$ <span class=\"token function\">sudo</span> unshare --uts --mount --pid --mount-proc --fork /bin/bash\nroot@kernelnewbies:~<span class=\"token comment\"># readlink /proc/$$/ns/pid</span>\npid:<span class=\"token punctuation\">[</span><span class=\"token number\">4026532182</span><span class=\"token punctuation\">]</span>\n\nroot@kernelnewbies:~<span class=\"token comment\"># unshare --uts --mount --pid --mount-proc --fork /bin/bash</span>\nroot@kernelnewbies:~<span class=\"token comment\"># readlink /proc/$$/ns/pid</span>\npid:<span class=\"token punctuation\">[</span><span class=\"token number\">4026532185</span><span class=\"token punctuation\">]</span>\n\nroot@kernelnewbies:~<span class=\"token comment\"># unshare --uts --mount --pid --mount-proc --fork /bin/bash</span>\nroot@kernelnewbies:~<span class=\"token comment\"># readlink /proc/$$/ns/pid</span>\npid:<span class=\"token punctuation\">[</span><span class=\"token number\">4026532188</span><span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>然后，我们启动一个新Shell，然后使用pstree查看进程间关系。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~$ pstree -lp <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> unshare\nsudo<span class=\"token punctuation\">(</span><span class=\"token number\">12547</span><span class=\"token punctuation\">)</span>---unshare<span class=\"token punctuation\">(</span><span class=\"token number\">12548</span><span class=\"token punctuation\">)</span>---bash<span class=\"token punctuation\">(</span><span class=\"token number\">12549</span><span class=\"token punctuation\">)</span>---unshare<span class=\"token punctuation\">(</span><span class=\"token number\">12579</span><span class=\"token punctuation\">)</span>---bash<span class=\"token punctuation\">(</span><span class=\"token number\">12580</span><span class=\"token punctuation\">)</span>---unshare<span class=\"token punctuation\">(</span><span class=\"token number\">12593</span><span class=\"token punctuation\">)</span>---bash<span class=\"token punctuation\">(</span><span class=\"token number\">12594</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>使用cat /proc/[pid]/status | grep NSpid可查看某进程在当前pid namespace及子孙pid namespace中的pid。我们在全局pid namespace中查看上述各进程在各pid namespace中的pid，命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~$ <span class=\"token function\">cat</span> /proc/12594/status <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> NSpid\nNSpid: <span class=\"token number\">12594</span> <span class=\"token number\">21</span> <span class=\"token number\">11</span> <span class=\"token number\">1</span>\n\nphl@kernelnewbies:~$ <span class=\"token function\">cat</span> /proc/12593/status <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> NSpid\nNSpid: <span class=\"token number\">12593</span> <span class=\"token number\">20</span> <span class=\"token number\">10</span>\n\nphl@kernelnewbies:~$ <span class=\"token function\">cat</span> /proc/12580/status <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> NSpid\nNSpid: <span class=\"token number\">12580</span> <span class=\"token number\">11</span> <span class=\"token number\">1</span>\n\nphl@kernelnewbies:~$ <span class=\"token function\">cat</span> /proc/12579/status <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> NSpid\nNSpid: <span class=\"token number\">12579</span> <span class=\"token number\">10</span>\n\nphl@kernelnewbies:~$ <span class=\"token function\">cat</span> /proc/12549/status <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> NSpid\nNSpid: <span class=\"token number\">12549</span> <span class=\"token number\">1</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>下面我们将以上进程在各pid namespace中的pid，整理成表格。表格信息如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2022/03/1820220318143156.png\" alt=\"使用 Shell 脚本实现 Docker\"></p>\n<p>我们以最后一行为例进行介绍，最后一行有4个pid，这4个pid其实是同一个进程。这个进程在4个pid namespace中都可以被看到，且其在4个pid namespace中的pid各不相同。</p>\n<h4 id=\"1-4-4-docker-sh\">1.4.4.docker.sh</h4>\n<p>有了以上关于pid namespace的知识，我们就可以将pid namespae加入到docker.sh中了。pid namespace将放在docker.sh中，带下划线的行是我们为实现pid namespace而修改的代码。修改后的docker.sh脚本如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">..</span>.\nunshare --uts --mount --pid --fork ./container.sh<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>从上述代码我们可以看到，我们仅仅是在调用unshare时加入--pid和--fork选项，就可为docker.sh引入了pid namespace功能。</p>\n<p>然后，我们需要重新挂载/proc文件系统。重新挂载/proc文件系统的功能将放在container.sh中，带下划线的行是我们为重新挂载/proc文件系统而新添的代码。修改后的container.sh脚本如下如下所示：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">hostname</span> <span class=\"token variable\">$container</span>\n<span class=\"token function\">mount</span> -t proc proc /proc\n<span class=\"token builtin class-name\">exec</span> <span class=\"token variable\">$program</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>现在，我们运行docker.sh，并查看当前的进程信息。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~/docker.sh$ <span class=\"token function\">sudo</span> ./docker.sh -c run -m 100M -C dreamland -I ubuntu1604 -V data1 -P /bin/bash\nroot@dreamland:~/docker.sh<span class=\"token comment\"># ps -ef</span>\n<span class=\"token environment constant\">UID</span>        PID  <span class=\"token environment constant\">PPID</span>  C STIME TTY          TIME CMD\nroot         <span class=\"token number\">1</span>     <span class=\"token number\">0</span>  <span class=\"token number\">0</span> <span class=\"token number\">17</span>:31 pts/1    00:00:00 /bin/bash\nroot        <span class=\"token number\">16</span>     <span class=\"token number\">1</span>  <span class=\"token number\">0</span> <span class=\"token number\">17</span>:31 pts/1    00:00:00 <span class=\"token function\">ps</span> -ef<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>从结果我们可看出，当前进程只有两个，不再有主机上的其他进程。</p>\n<h2 id=\"2-CGroups\">2.CGroups</h2>\n<h3 id=\"2-1-CGroups简介\">2.1.CGroups简介</h3>\n<p>CGroups是一种将进程分组，并以组为单位对进程实施资源限制的技术。每个组都包含以下几类信息：</p>\n<ul>\n<li>进程列表</li>\n<li>资源A限制</li>\n<li>资源B限制</li>\n<li>资源C限制</li>\n<li>...</li>\n</ul>\n<p>我们将以常见的CPU资源及内存资源为例进行介绍。以下的信息将使进程号为1001、1002、2008、3306的四个进程总共只能使用一个CPU核心；总共最多使用25%的CPU资源；总共最多使用100M内存，这样的一个分组被称为cgroup。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2022/03/1820220318143103.png\" alt=\"使用 Shell 脚本实现 Docker\"></p>\n<p>上面的介绍只是说明了要将何种资源限制施加于哪些进程，并未说明资源限制是如何施加到进程上。具体施加资源限制的过程需要subsystem来帮忙。subsystem读取cgroup中的资源限制和进程列表，然后将这些资源限制施加到这些进程上。常见的subsystem包括如下几种：</p>\n<ul>\n<li>cpu</li>\n<li>memory</li>\n<li>pids</li>\n<li>devices</li>\n<li>blkio</li>\n<li>net_cls</li>\n</ul>\n<p>每个subsystem只读取与其相关的资源限制，然后施加到进程上。例如：memory子系统只读取内存限制，而cpu子系统只读取cpu限制。</p>\n<p>cgroup被组织成树，如下图所示：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2022/03/1820220318143057.png\" alt=\"使用 Shell 脚本实现 Docker\"></p>\n<p>采用树状结构可以方便地实现资源限制继承，一个cgroup中的资源限制将作用于该cgroup及其子孙cgroup中的进程。例如：图中13001、10339、2999受到A、B、C、D四个cgroup中的资源限制。这样的一个树状结构被称为hierarchy。</p>\n<p>hierarchy中包含了系统中所有的进程，它们分布于各个cgroup中。在hierarchy中，一个进程必须属于且只属于一个cgroup，这样才能保证对进程施加的资源限制不会遗漏也不会冲突。</p>\n<p>要想让一个subsystem读取hierarchy中各cgroup的资源限制，并施加于其中的进程需要将subsystem和hierarchy关联起来。subsystem与hierarchy的关系如下：</p>\n<ul>\n<li>系统中可以有多个hierarchy</li>\n<li>一个hierarchy可以关联0个或多个subsystem，当关联0个subsystem时，该hierarchy只是对进程进行分类</li>\n<li>一个subsystem最多关联到一个hierarchy，因为每个hierarchy都包含系统中所有的进程，若一个subsystem关联到了多个hierarchy，对同一进程将有多种资源限制，这是不对的</li>\n</ul>\n<p>系统使用CGroups通常有两种形式：一种是创建一个hierarchy，将所有的subsystem关联到其上，在这个hierarchy上配置各种资源限制；另一种是为每一个subsystem创建一个hierarchy，并将该subsystem关联到其上，每个hierarchy只对一种资源进行限制。后一种比较清晰，得到了更普遍的采用。</p>\n<p>CGroups不像大多数的技术那样提供API或命令之类的用户接口，而是提供给用户一个虚拟文件系统，该虚拟文件系统类型为cgroup。一个挂载后的cgroup文件系统就是一个hierarchy，文件系统中的一个目录就是一个cgroup，目录中的文件代表了进程列表或者资源限制信息。文件系统是树状结构，其各个目录之间的父子关系就代表了cgroup之间的继承关系。挂载cgroup虚拟文件系统后，通过在该文件系统上创建目录、写进程列表文件、写资源限制文件就可以操作CGroups。</p>\n<p>下面，我们通过实验学习一下CGroups的用法。首先，我们挂载一个cgroup虚拟文件系统，该文件系统不与任何subsystem关联，仅仅是将进程进行分类。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~$ <span class=\"token function\">mkdir</span> -p cg/test\n<span class=\"token comment\"># -o none,name=test 表示该cgroup文件系统不与任何子系统关联</span>\n<span class=\"token comment\"># 该文件系统用name=test来标识</span>\nphl@kernelnewbies:~$ <span class=\"token function\">sudo</span> <span class=\"token function\">mount</span> -t cgroup -o none,name<span class=\"token operator\">=</span>test <span class=\"token builtin class-name\">test</span> cg/test\nphl@kernelnewbies:~$ tree cg/test\ncg/test\n├── cgroup.clone_children\n├── cgroup.procs\n├── cgroup.sane_behavior\n├── notify_on_release\n├── release_agent\n└── tasks\n<span class=\"token number\">0</span> directories, <span class=\"token number\">6</span> files<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>挂载cgroup文件系统后，该cgroup文件系统的根目录下会生成许多文件，该根目录被称为root cgroup。cgroup.procs里面存放的是当前cgroup中的所有进程id，由于该hierarchy中只有一个cgroup，所以这个文件包含了系统中所有的进程id。其他的文件与cgroups基本功能关系不大，暂时可以忽略。</p>\n<p>在cgroup文件系统中，创建一个目录就会创建一个cgroup。下面我们将会演示如何创建下面这样的hierarchy：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2022/03/1820220318143054.png\" alt=\"使用 Shell 脚本实现 Docker\"></p>\n<p>命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~$ <span class=\"token function\">sudo</span> <span class=\"token function\">mkdir</span> -p cg/test/test1/test11\nphl@kernelnewbies:~$ <span class=\"token function\">sudo</span> <span class=\"token function\">mkdir</span> -p cg/test/test2/test22\nphl@kernelnewbies:~$ tree cg/test\ncg/test\n├── cgroup.clone_children\n├── cgroup.procs\n├── cgroup.sane_behavior\n├── notify_on_release\n├── release_agent\n├── tasks\n├── test1\n│   ├── cgroup.clone_children\n│   ├── cgroup.procs\n│   ├── notify_on_release\n│   ├── tasks\n│   └── test11\n│       ├── cgroup.clone_children\n│       ├── cgroup.procs\n│       ├── notify_on_release\n│       └── tasks\n└── test2\n    ├── cgroup.clone_children\n    ├── cgroup.procs\n    ├── notify_on_release\n    ├── tasks\n    └── test22\n        ├── cgroup.clone_children\n        ├── cgroup.procs\n        ├── notify_on_release\n        └── tasks\n\n<span class=\"token number\">4</span> directories, <span class=\"token number\">22</span> files<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>从结果我们可以看到，我们创建了相应的目录后，这些目录下自动出现了包含cgroup信息的目录及文件。</p>\n<p>删除cgroup时只需删除该cgroup所在的目录即可。下面我们将删除test11 cgroup，命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~$ <span class=\"token function\">sudo</span> <span class=\"token function\">rmdir</span> cg/test/test1/test11\nphl@kernelnewbies:~$ tree cg/test\ncg/test\n├── cgroup.clone_children\n├── cgroup.procs\n├── cgroup.sane_behavior\n├── notify_on_release\n├── release_agent\n├── tasks\n├── test1\n│   ├── cgroup.clone_children\n│   ├── cgroup.procs\n│   ├── notify_on_release\n│   └── tasks\n└── test2\n    ├── cgroup.clone_children\n    ├── cgroup.procs\n    ├── notify_on_release\n    ├── tasks\n    └── test22\n        ├── cgroup.clone_children\n        ├── cgroup.procs\n        ├── notify_on_release\n        └── tasks\n\n<span class=\"token number\">3</span> directories, <span class=\"token number\">18</span> files<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>每个cgroup下面都有一个cgroup.procs文件，该文件里面包含当前cgroup里面的所有进程id。只要将某个进程的id写入该文件，即可将该进程加入到该cgroup中。下面，我们将当前的bash加入到test22 cgroup中，命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~$ <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$$</span>\n<span class=\"token number\">3894</span>\nphl@kernelnewbies:~$ <span class=\"token function\">sudo</span> <span class=\"token function\">sh</span> -c <span class=\"token string\">\"echo 3894 &gt; cg/test/test2/test22/cgroup.procs\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>/proc/[pid]/cgroup包含了某个进程所在的cgroup信息。下面，我们查看一下当前bash进程所在的cgroup信息，命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~$ <span class=\"token function\">cat</span> /proc/3894/cgroup\n<span class=\"token number\">13</span>:name<span class=\"token operator\">=</span>test:/test2/test22\n<span class=\"token number\">12</span>:freezer:/\n<span class=\"token number\">11</span>:perf_event:/\n<span class=\"token number\">10</span>:blkio:/user.slice\n<span class=\"token number\">9</span>:devices:/user.slice\n<span class=\"token number\">8</span>:hugetlb:/\n<span class=\"token number\">7</span>:cpu,cpuacct:/user.slice\n<span class=\"token number\">6</span>:net_cls,net_prio:/\n<span class=\"token number\">5</span>:memory:/user.slice\n<span class=\"token number\">4</span>:rdma:/\n<span class=\"token number\">3</span>:pids:/user.slice/user-1001.slice/session-4.scope\n<span class=\"token number\">2</span>:cpuset:/\n<span class=\"token number\">1</span>:name<span class=\"token operator\">=</span>systemd:/user.slice/user-1001.slice/session-4.scope\n<span class=\"token number\">0</span>::/user.slice/user-1001.slice/session-4.scope<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>从结果我们可以看到，当前bash进程加入了多个cgroup，其中带下划线的行为我们刚刚加入的cgroup。</p>\n<p>要想将hierarchy与子系统关联起来，需要在-o选项中指定子系统名称。下面演示了如何将memory子系统与新挂载的cgroup文件系统关联起来。代码如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~$ <span class=\"token function\">sudo</span> <span class=\"token function\">mkdir</span> cg/memory\nphl@kernelnewbies:~$ <span class=\"token function\">sudo</span> <span class=\"token function\">mount</span> -t cgroup -o memory memcg cg/memory<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>由于很多发行版的操作系统已经为我们配置好了这些cgroup文件系统，我们应当直接使用这些已经挂在好的文件系统，不需要自己去挂载。</p>\n<p>另外，当创建子进程时，子进程会自动加入父进程所在的cgroup。</p>\n<h3 id=\"2-2-限制内存\">2.2.限制内存</h3>\n<h4 id=\"2-2-1-用CGroups限制内存\">2.2.1.用CGroups限制内存</h4>\n<p>下面我们将介绍演示CGroups如何限制进程使用的内存资源，我们以内存为例进行讲解。</p>\n<p>Ubuntu18.04已经为我们挂载了一个关联memory子系统的cgroup虚拟文件系统。我们用mount命令查看一下该系统挂载到了何处，命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~$ <span class=\"token function\">mount</span> <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> cgroup\ntmpfs on /sys/fs/cgroup <span class=\"token builtin class-name\">type</span> tmpfs <span class=\"token punctuation\">(</span>ro,nosuid,nodev,noexec,mode<span class=\"token operator\">=</span><span class=\"token number\">755</span><span class=\"token punctuation\">)</span>\ncgroup on /sys/fs/cgroup/unified <span class=\"token builtin class-name\">type</span> cgroup2 <span class=\"token punctuation\">(</span>rw,nosuid,nodev,noexec,relatime,nsdelegate<span class=\"token punctuation\">)</span>\ncgroup on /sys/fs/cgroup/systemd <span class=\"token builtin class-name\">type</span> cgroup <span class=\"token punctuation\">(</span>rw,nosuid,nodev,noexec,relatime,xattr,name<span class=\"token operator\">=</span>systemd<span class=\"token punctuation\">)</span>\ncgroup on /sys/fs/cgroup/cpuset <span class=\"token builtin class-name\">type</span> cgroup <span class=\"token punctuation\">(</span>rw,nosuid,nodev,noexec,relatime,cpuset<span class=\"token punctuation\">)</span>\ncgroup on /sys/fs/cgroup/pids <span class=\"token builtin class-name\">type</span> cgroup <span class=\"token punctuation\">(</span>rw,nosuid,nodev,noexec,relatime,pids<span class=\"token punctuation\">)</span>\ncgroup on /sys/fs/cgroup/rdma <span class=\"token builtin class-name\">type</span> cgroup <span class=\"token punctuation\">(</span>rw,nosuid,nodev,noexec,relatime,rdma<span class=\"token punctuation\">)</span>\ncgroup on /sys/fs/cgroup/memory <span class=\"token builtin class-name\">type</span> cgroup <span class=\"token punctuation\">(</span>rw,nosuid,nodev,noexec,relatime,memory<span class=\"token punctuation\">)</span>\ncgroup on /sys/fs/cgroup/net_cls,net_prio <span class=\"token builtin class-name\">type</span> cgroup <span class=\"token punctuation\">(</span>rw,nosuid,nodev,noexec,relatime,net_cls,net_prio<span class=\"token punctuation\">)</span>\ncgroup on /sys/fs/cgroup/cpu,cpuacct <span class=\"token builtin class-name\">type</span> cgroup <span class=\"token punctuation\">(</span>rw,nosuid,nodev,noexec,relatime,cpu,cpuacct<span class=\"token punctuation\">)</span>\ncgroup on /sys/fs/cgroup/hugetlb <span class=\"token builtin class-name\">type</span> cgroup <span class=\"token punctuation\">(</span>rw,nosuid,nodev,noexec,relatime,hugetlb<span class=\"token punctuation\">)</span>\ncgroup on /sys/fs/cgroup/devices <span class=\"token builtin class-name\">type</span> cgroup <span class=\"token punctuation\">(</span>rw,nosuid,nodev,noexec,relatime,devices<span class=\"token punctuation\">)</span>\ncgroup on /sys/fs/cgroup/blkio <span class=\"token builtin class-name\">type</span> cgroup <span class=\"token punctuation\">(</span>rw,nosuid,nodev,noexec,relatime,blkio<span class=\"token punctuation\">)</span>\ncgroup on /sys/fs/cgroup/perf_event <span class=\"token builtin class-name\">type</span> cgroup <span class=\"token punctuation\">(</span>rw,nosuid,nodev,noexec,relatime,perf_event<span class=\"token punctuation\">)</span>\ncgroup on /sys/fs/cgroup/freezer <span class=\"token builtin class-name\">type</span> cgroup <span class=\"token punctuation\">(</span>rw,nosuid,nodev,noexec,relatime,freezer<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>该系统挂载到了/sys/fs/cgroup/memory目录下。我们在该hierarchy中创建一个test cgroup并查看该cgroup的目录结构，命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~$ <span class=\"token function\">sudo</span> <span class=\"token function\">mkdir</span> /sys/fs/cgroup/memory/test\nphl@kernelnewbies:~$ tree /sys/fs/cgroup/memory/test\n/sys/fs/cgroup/memory/test\n├── cgroup.clone_children\n├── cgroup.event_control\n├── cgroup.procs\n├── memory.failcnt\n├── memory.force_empty\n├── memory.kmem.failcnt\n├── memory.kmem.limit_in_bytes\n├── memory.kmem.max_usage_in_bytes\n├── memory.kmem.slabinfo\n├── memory.kmem.tcp.failcnt\n├── memory.kmem.tcp.limit_in_bytes\n├── memory.kmem.tcp.max_usage_in_bytes\n├── memory.kmem.tcp.usage_in_bytes\n├── memory.kmem.usage_in_bytes\n├── memory.limit_in_bytes\n├── memory.max_usage_in_bytes\n├── memory.move_charge_at_immigrate\n├── memory.numa_stat\n├── memory.oom_control\n├── memory.pressure_level\n├── memory.soft_limit_in_bytes\n├── memory.stat\n├── memory.swappiness\n├── memory.usage_in_bytes\n├── memory.use_hierarchy\n├── notify_on_release\n└── tasks\n<span class=\"token number\">0</span> directories, <span class=\"token number\">27</span> files<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>从结果我们可以看到，新建的test cgroup中有许多文件，这些文件中存放着资源限制信息。其中memory.limit_in_bytes里面存放的是该cgroup中的进程能够使用的内存额度。</p>\n<p>下面，我们将当前bash加入到test cgroup中并查看当前bash所属的cgroup信息。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~$ <span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$$</span>\n<span class=\"token number\">2984</span>\nphl@kernelnewbies:~$ <span class=\"token function\">sudo</span> <span class=\"token function\">sh</span> -c <span class=\"token string\">\"echo 2984 &gt; /sys/fs/cgroup/memory/test/cgroup.procs\"</span>\nphl@kernelnewbies:~$ <span class=\"token function\">cat</span> /proc/2984/cgroup\n<span class=\"token number\">12</span>:devices:/user.slice\n<span class=\"token number\">11</span>:hugetlb:/\n<span class=\"token number\">10</span>:memory:/test\n<span class=\"token number\">9</span>:rdma:/\n<span class=\"token number\">8</span>:perf_event:/\n<span class=\"token number\">7</span>:blkio:/user.slice\n<span class=\"token number\">6</span>:cpu,cpuacct:/user.slice\n<span class=\"token number\">5</span>:pids:/user.slice/user-1001.slice/session-4.scope\n<span class=\"token number\">4</span>:freezer:/\n<span class=\"token number\">3</span>:cpuset:/\n<span class=\"token number\">2</span>:net_cls,net_prio:/\n<span class=\"token number\">1</span>:name<span class=\"token operator\">=</span>systemd:/user.slice/user-1001.slice/session-4.scope\n<span class=\"token number\">0</span>::/user.slice/user-1001.slice/session-4.scope<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>从结果我们可以看到，当前bash所属的memory cgroup变为了/test，该目录为一个相对于root cgroup的相对路径。</p>\n<p>然后，将100M写入test cgroup中的memory.limit_in_bytes文件中，命令如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~$ <span class=\"token function\">sudo</span> <span class=\"token function\">sh</span> -c <span class=\"token string\">\"echo 100M &gt; /sys/fs/cgroup/memory/test/memory.limit_in_bytes\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>我们在当前bash中启动一个占用300M进程的stress进程，该stress进程是bash的子进程，其与bash进程都在test cgroup中。命令如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~$ stress --vm <span class=\"token number\">1</span> --vm-bytes 300M --vm-keep<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>启动一个新的Shell窗口，执行top命令查看stress进程占用的内存。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">PID <span class=\"token environment constant\">USER</span>      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND\n<span class=\"token number\">14216</span> root      <span class=\"token number\">20</span>   <span class=\"token number\">0</span>  <span class=\"token number\">315440</span> <span class=\"token number\">101224</span>    <span class=\"token number\">264</span> D <span class=\"token number\">27.7</span>  <span class=\"token number\">2.5</span>   <span class=\"token number\">0</span>:02.66 stress<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>从结果我们可以看到，stress进程占用了2.5%的内存。我的电脑的内存为4G，4G * 2.5% = 100M，stress进程确实受到了cgroup中设置的内存额度的限制。</p>\n<h4 id=\"2-2-2-docker-sh\">2.2.2.docker.sh</h4>\n<p>下有了以上关于CGroups的知识，我们就可以将限制内存的功能加入到docker.sh中了。限制内存的功能将放在container.sh中，带下划线的行是我们为实现限制内存而新添的代码。修改后的container.sh脚本如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">hostname</span> <span class=\"token variable\">$container</span>\n<span class=\"token function\">mkdir</span> -p /sys/fs/cgroup/memory/<span class=\"token variable\">$container</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$$</span> <span class=\"token operator\">&gt;</span> /sys/fs/cgroup/memory/<span class=\"token variable\">$container</span>/cgroup.procs\n<span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$memory</span> <span class=\"token operator\">&gt;</span> /sys/fs/cgroup/memory/<span class=\"token variable\">$container</span>/memory.limit_in_bytes\n<span class=\"token function\">mount</span> -t proc proc /proc\n<span class=\"token builtin class-name\">exec</span> <span class=\"token variable\">$program</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>首先，我们根据容器的名字创建cgroup，命令如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">mkdir</span> -p /sys/fs/cgroup/memory/<span class=\"token variable\">$container</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>然后，我们将当前bash加入到我们创建的cgroup中，命令如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$$</span> <span class=\"token operator\">&gt;</span> /sys/fs/cgroup/memory/<span class=\"token variable\">$container</span>/cgroup.procs<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>最后，我们将内存限制写入新cgroup的memory.limit_in_bytes文件中，命令如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$memory</span> <span class=\"token operator\">&gt;</span> /sys/fs/cgroup/memory/<span class=\"token variable\">$container</span>/memory.limit_in_bytes<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>现在，我们运行docker.sh，并启动一个占用300M进程的stress进程。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~/docker.sh$ <span class=\"token function\">sudo</span> ./docker.sh -c run -m 100M -C dreamland -I ubuntu1604 -V data1 -P /bin/bash\nroot@dreamland:~/docker.sh<span class=\"token comment\"># stress --vm 1 --vm-bytes 300M --vm-keep</span>\nstress: info: <span class=\"token punctuation\">[</span><span class=\"token number\">12</span><span class=\"token punctuation\">]</span> dispatching hogs: <span class=\"token number\">0</span> cpu, <span class=\"token number\">0</span> io, <span class=\"token number\">1</span> vm, <span class=\"token number\">0</span> hdd<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>启动一个新的Shell窗口，执行top命令查看stress进程占用的内存。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">PID <span class=\"token environment constant\">USER</span>      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND\n<span class=\"token number\">14216</span> root      <span class=\"token number\">20</span>   <span class=\"token number\">0</span>  <span class=\"token number\">315440</span> <span class=\"token number\">101224</span>    <span class=\"token number\">264</span> D <span class=\"token number\">27.7</span>  <span class=\"token number\">2.5</span>   <span class=\"token number\">0</span>:02.66 stress<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>从结果我们可以看到，容器内的stress进程只使用了100M的内存。</p>\n<h2 id=\"3-切换根文件系统\">3.切换根文件系统</h2>\n<h3 id=\"3-1-根文件系统\">3.1.根文件系统</h3>\n<p>在容器技术中，根文件系统可为容器进程提供一个与主机不一致的文件系统环境。举个例子，主机为Ubuntu 18.04，创建的容器采用Ubuntu 16.04的根文件系统，那么容器运行时所用的软件及其依赖库、配置文件等都是Ubuntu 16.04的。尽管该容器使用的内核是仍旧是Ubuntu 18.04的，但应用软件的表现却与Ubuntu 16.04一致，从虚拟化的角度来说该容器就是一个Ubuntu 16.04系统。</p>\n<p>debootstrap是Ubuntu下的一个工具，用来构建根文件系统。生成的目录符合Linux文件系统标准，即包含了/boot、/etc、/bin、/usr等目录。debootstrap的安装命令如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> <span class=\"token function\">install</span> <span class=\"token function\">debootstrap</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>下面我们通过debootstrap构建Ubuntu 16.04的根文件系统。为了清晰，我们在images目录下生成根文件系统。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~/docker.sh$ <span class=\"token function\">mkdir</span> images\nphl@kernelnewbies:~/docker.sh$ <span class=\"token builtin class-name\">cd</span> images\nphl@kernelnewbies:~/docker.sh/images$ <span class=\"token function\">sudo</span> <span class=\"token function\">debootstrap</span> --arch amd64 xenial ./ubuntu1604<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>制作根文件系统需要从服务器下载很多文件，很耗时，请耐心等待。当文件系统制作好后，可以使用tree命令查看生成的根文件系统。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~/docker.sh/images$ tree -L <span class=\"token number\">1</span> ubuntu1604/\nubuntu1604/\n├── bin\n├── boot\n├── dev\n├── etc\n├── home\n├── lib\n├── lib64\n├── media\n├── mnt\n├── old_root\n├── opt\n├── proc\n├── root\n├── run\n├── sbin\n├── srv\n├── sys\n├── tmp\n├── usr\n└── var\n<span class=\"token number\">20</span> directories, <span class=\"token number\">0</span> files<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这个根文件系统与Linux系统目录很相近，我们后续的实验将使用该根文件系统。</p>\n<h3 id=\"3-2-pivot-root\">3.2.pivot_root</h3>\n<p>pivot_root命令用于切换根文件系统，其使用方式如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">pivot_root new_root put_old<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>pivot_root将当前进程的根文件系统移至put_old目录并使new_root目录成为新的根文件系统。</p>\n<p>下面我们将通过实验学习pivot_root的使用方法。为了简单，我们在一个新的mount namespace下进行实验。首先，我们创建一个新的mount namespace，命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~/docker.sh/images$ <span class=\"token function\">sudo</span> unshare --mount /bin/bash\nroot@kernelnewbies:~/docker.sh/images<span class=\"token comment\">#</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>在我们的实验中，我们的根文件系统将挂载在ubuntu1604目录，而老的根文件系统将被移动到ubuntu1604/old_root目录下。我们先创建old_root目录，命令如下：</p>\n<p>root@kernelnewbies:~/docker.sh/images# mkdir -p ubuntu1604/old_root/</p>\n<p>由于pivot_root命令要求老的根目录和新的根目录不能在同一个挂载点下，因此我们通过bind mount将ubuntu1604目录变成一个挂载点。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">root@kernelnewbies:~/docker.sh/images<span class=\"token comment\"># mount --bind ubuntu1604 ubuntu1604</span>\nroot@kernelnewbies:~/docker.sh/images<span class=\"token comment\"># cat /proc/self/mountinfo | grep ubuntu1604</span>\n<span class=\"token number\">624</span> <span class=\"token number\">382</span> <span class=\"token number\">8</span>:1 /home/phl/docker.sh/images/ubuntu1604 /home/phl/docker.sh/images/ubuntu1604 rw,relatime - ext4 /dev/sda1 rw,errors<span class=\"token operator\">=</span>remount-ro<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>准备好切换根文件系统所需要的条件后，我们调用pivot_root切换根文件系统。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">root@kernelnewbies:~/docker.sh/images<span class=\"token comment\"># cd ubuntu1604/</span>\nroot@kernelnewbies:~/docker.sh/images/ubuntu1604<span class=\"token comment\"># pivot_root . old_root/</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>此时，已完成根文件系统的切换，/proc文件系统也被挪到了<br>\n/home/phl/docker.sh/images/ubuntu1604/old_root/proc，也就是说当前没有/proc文件系统，因此，我们无法查看挂载点信息，自然也无法执行一些依赖于/proc文件系统的操作。我们需要重新挂载/proc文件系统。命令如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">root@kernelnewbies:~/docker.sh/images/ubuntu1604<span class=\"token comment\"># mount -t proc proc /proc</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>重新挂载/proc文件系统后，我们就可以查看当前的挂载点信息了。通过读取/proc/self/mountinfo文件来查看系统的挂载点信息。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">root@kernelnewbies:~/docker.sh/images/ubuntu1604<span class=\"token comment\"># cat /proc/self/mountinfo</span>\n<span class=\"token number\">382</span> <span class=\"token number\">624</span> <span class=\"token number\">8</span>:1 / /old_root rw,relatime - ext4 /dev/sda1 rw,errors<span class=\"token operator\">=</span>remount-ro\n<span class=\"token punctuation\">..</span>.\n<span class=\"token number\">624</span> <span class=\"token number\">381</span> <span class=\"token number\">8</span>:1 /home/phl/docker.sh/images/ubuntu1604 / rw,relatime - ext4 /dev/sda1 rw,errors<span class=\"token operator\">=</span>remount-ro\n<span class=\"token number\">625</span> <span class=\"token number\">624</span> <span class=\"token number\">0</span>:5 / /proc rw,relatime - proc proc rw<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>此时的挂载点很多，为了方便查看，此处只保留了一些主要的挂载点信息。这些挂载点信息包括/、/proc、/old_root。/old_root为老的根文件系统，我们需要将其卸载。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">root@kernelnewbies:~/docker.sh/images/ubuntu1604<span class=\"token comment\"># umount -l /old_root/</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>卸载掉老的根文件系统后，我们再查看系统的挂载点信息。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">root@kernelnewbies:~/docker.sh/images/ubuntu1604<span class=\"token comment\"># cat /proc/self/mountinfo</span>\n<span class=\"token number\">624</span> <span class=\"token number\">381</span> <span class=\"token number\">8</span>:1 /home/phl/docker.sh/images/ubuntu1604 / rw,relatime - ext4 /dev/sda1 rw,errors<span class=\"token operator\">=</span>remount-ro\n<span class=\"token number\">625</span> <span class=\"token number\">624</span> <span class=\"token number\">0</span>:5 / /proc rw,relatime - proc proc rw<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>此时，挂载点信息中只有/、/proc，不再有主机的挂载点信息。</p>\n<h3 id=\"3-3-docker-sh\">3.3.docker.sh</h3>\n<p>有了以上关于切换根文件系统的知识，我们就可以将切换根文件系统的功能加入到docker.sh中了。切换根文件系统的功能将放在container.sh中，带下划线的行是我们为实现切换根文件系统而新添的代码。修改后的container.sh脚本如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token function\">hostname</span> <span class=\"token variable\">$container</span>\n\n<span class=\"token function\">mkdir</span> -p /sys/fs/cgroup/memory/<span class=\"token variable\">$container</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$$</span> <span class=\"token operator\">&gt;</span> /sys/fs/cgroup/memory/<span class=\"token variable\">$container</span>/cgroup.procs\n<span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$memory</span> <span class=\"token operator\">&gt;</span> /sys/fs/cgroup/memory/<span class=\"token variable\">$container</span>/memory.limit_in_bytes\n\n<span class=\"token function\">mkdir</span> -p images/<span class=\"token variable\">$image</span>/old_root\n<span class=\"token function\">mount</span> --bind images/<span class=\"token variable\">$image</span> images/<span class=\"token variable\">$image</span>\n\n<span class=\"token builtin class-name\">cd</span> images/<span class=\"token variable\">$image</span>\npivot_root <span class=\"token builtin class-name\">.</span> ./old_root\n\n<span class=\"token function\">mount</span> -t proc proc /proc\n<span class=\"token function\">umount</span> -l /old_root\n\n<span class=\"token builtin class-name\">exec</span> <span class=\"token variable\">$program</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>首先，我们在新的根文件系统目录中创建挂载老的根文件系统的目录。命令如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">mkdir</span> -p images/<span class=\"token variable\">$image</span>/old_root<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>然后，我们将新根文件系统目录bind mount成一个挂载点。命令如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">mount</span> --bind images/<span class=\"token variable\">$image</span> images/<span class=\"token variable\">$image</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>然后，我们切换根文件系统。命令如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">cd</span> images/<span class=\"token variable\">$image</span>\npivot_root <span class=\"token builtin class-name\">.</span> ./old_root<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>最后，我们重新挂载/proc文件系统，然后卸载掉老的根文件系统。命令如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">mount</span> -t proc proc /proc\n<span class=\"token function\">umount</span> -l /old_root<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>现在，我们运行docker.sh，并查看当前的发行版信息。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~/docker.sh$ <span class=\"token function\">sudo</span> ./docker.sh -c run -m 100M -C dreamland -I ubuntu1604 -V data1 -P /bin/bash\nroot@dreamland:/<span class=\"token comment\"># cat /etc/issue</span>\nUbuntu <span class=\"token number\">16.04</span> LTS <span class=\"token punctuation\">\\</span>n <span class=\"token punctuation\">\\</span>l<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>从结果我们可以看出，读出的发行版信息是Ubuntu 16.04 LTS \\n \\l，而非主机的Ubuntu 18.04.3 LTS \\n \\l。这说明当前使用的根文件系统确实是ubuntu16.04目录下的根文件系统，而非主机的根文件系统。</p>\n<p>我们再查看一下当前的挂载点信息，看看是否只有/与/proc。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">root@dreamland:/<span class=\"token comment\"># cat /proc/self/mountinfo</span>\n<span class=\"token number\">625</span> <span class=\"token number\">381</span> <span class=\"token number\">8</span>:1 /home/phl/docker.sh/images/ubuntu1604 / rw,relatime - ext4 /dev/sda1 rw,errors<span class=\"token operator\">=</span>remount-ro\n<span class=\"token number\">626</span> <span class=\"token number\">625</span> <span class=\"token number\">0</span>:52 / /proc rw,relatime - proc proc rw<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>从结果我们可看出，当前挂载点信息中只有/、/proc，不再有主机的挂载点信息。</p>\n<p>通过根文件系统，我们实现了在容器中虚拟出与主机不一样的操作系统的功能。</p>\n<h2 id=\"4-联合加载\">4.联合加载</h2>\n<h3 id=\"4-1-联合加载简介\">4.1.联合加载简介</h3>\n<p>联合加载指的是一次同时加载多个文件系统，但是在外面看起来只能看到 一个文件系统。联合加载会将各层文件系统叠加到一起，这样最终的文件系统会 包含所有底层的文件和目录。</p>\n<p>联合加载的多个文件系统中有一个是可读写文件系统，称为读写层，其他文件系统是只读的，称为只读层。当联合加载的文件系统发生变化时，这些变化都应用到这个读写层。比如，如果想修改一个文件，这个文件首先会从只读层复制到读写层。原只读层中的文件依然存在，但是被读写层中的该文件副本所隐藏。我们以后读写该文件时，都是读写的该文件在读写层中的副本。这种机制被称为 写时复制。</p>\n<p>我们之前实现的docker.sh，有一个很大的缺陷。那就是，如果使用相同的根文件系统同时启动多个容器的实例，那么，这些容器实例使用的根文件系统位于同一个目录。我们在不同的容器实例对根文件系统所作的修改，这些容器彼此之间都可以看到，甚至一个容器可以覆覆盖另一个容器所作的修改。同时，容器实例退出时，对根文件系统所作的修改也直接作用于其所使用的根文件系统。当我们使用该根文件系统再次启动容器实例时，新启动的容器实例也可以看到以前的这些修改。例如，我们用ubuntu1604根文件系统启动两个容器实例，命令如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~/docker.sh$ <span class=\"token function\">sudo</span> ./docker.sh -c run -m 100M -C dreamland -I ubuntu1604 -V data1 -P /bin/bash\nphl@kernelnewbies:~/docker.sh$ <span class=\"token function\">sudo</span> ./docker.sh -c run -m 100M -C dreamland2 -I ubuntu1604 -V data1 -P /bin/bash<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>这两个容器实例对根文件系统做的修改彼此都可以看到。容器实例退出时，这些修改也被保存了下来，当用ubuntu1604根文件系统启动新的容器实例时，新实例也可看到以前实例所做的修改。</p>\n<p>如果容器使用的根文件系统是一个联合加载的文件系统，原先的根文件系统作为一个只读层，再添加一个读写层，那么，在容器内所作的修改都将只作用于读写层。为了区分，我们以后称ubuntu1604目录下的根文件系统为镜像。而我们可以为每一个容器实例指定一个唯一的读写层目录，这样的话，多个容器实例就可以使用同一个镜像，容器内所作的修改不会影响彼此，也不会影响到以后启动的容器实例。例如：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~/docker.sh$ <span class=\"token function\">sudo</span> ./docker.sh -c run -m 100M -C dreamland -I ubuntu1604 -V data1 -P /bin/bash\nphl@kernelnewbies:~/docker.sh$ <span class=\"token function\">sudo</span> ./docker.sh -c run -m 100M -C dreamland2 -I ubuntu1604 -V data1 -P /bin/bash<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>我们使用ubuntu1604镜像启动了两个容器示例，并在容器实例里进行读写操作。这两个容器实例的读写层目录是不一样的，在容器实例中所作的修改只作用于各自的读写层，彼此之间不会影响，当然更不会影响到后续启动的容器实例。</p>\n<h3 id=\"4-2-AUFS\">4.2. AUFS</h3>\n<p>AUFS是一个实现了联合加载功能的文件系统。我们将采用AUFS实现docker.sh中的联合加载功能。</p>\n<p>下面，我们将通过实验演示一下AUFS文件系统的用法。首先，我们准备需要用到的目录及文件。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~$ <span class=\"token function\">mkdir</span> aufs\nphl@kernelnewbies:~$ <span class=\"token builtin class-name\">cd</span> aufs/\nphl@kernelnewbies:~/aufs$ <span class=\"token function\">mkdir</span> rw r1 r2 union\nphl@kernelnewbies:~/aufs$ <span class=\"token builtin class-name\">echo</span> hello r1 <span class=\"token operator\">&gt;</span> r1/hellor1.txt\nphl@kernelnewbies:~/aufs$ <span class=\"token builtin class-name\">echo</span> hello r2 <span class=\"token operator\">&gt;</span> r2/hellor2.txt\nphl@kernelnewbies:~/aufs$ <span class=\"token builtin class-name\">echo</span> hello rw <span class=\"token operator\">&gt;</span> rw/hellorw.txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>下表列出了各个目录的作用。列表如下：</p>\n<ul>\n<li>rw为aufs文件系统的读写层目录</li>\n<li>r1为aufs文件系统的只读层目录</li>\n<li>r2为aufs文件系统的只读层目录</li>\n<li>union为挂载点，联合加载的aufs文件系统挂载于此目录</li>\n</ul>\n<p>下面我们将rw、r1、r2联合加载到union目录。命令如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~/aufs$ <span class=\"token function\">sudo</span> <span class=\"token function\">mount</span> -t aufs -o <span class=\"token assign-left variable\">dirs</span><span class=\"token operator\">=</span>rw:r1:r2 none union<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<ul>\n<li>-t aufs表示要挂载的文件系统类型为AUFS</li>\n<li>-o dirs=rw:r1:r2表示要将哪些目录加载到afus文件系统中，多个目录之间以:分隔。目录列表中的第一个目录表示读写层目录</li>\n<li>union表示aufs文件系统要挂载的目录</li>\n</ul>\n<p>挂载好AUFS文件系统后，我们进入该文件系统，查看其内容。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~/aufs$ <span class=\"token builtin class-name\">cd</span> union/\nphl@kernelnewbies:~/aufs/union$ <span class=\"token function\">ls</span>\nhellor1.txt hellor2.txt hellorw.txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>从输出结果来看，rw、r1、r2目录下的内容全部出现在了AUFS文件系统中，该文件系统由rw、r1、r2目录叠加而成。</p>\n<p>然后，我们修改这些文件，看看原始的rw、r1、r2目录下的文件是否更改。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~/aufs/union$ <span class=\"token builtin class-name\">echo</span> hello to r1 from union <span class=\"token operator\">&gt;</span> hellor1.txt\nphl@kernelnewbies:~/aufs/union$ <span class=\"token builtin class-name\">echo</span> hello to r2 from union <span class=\"token operator\">&gt;</span> hellor2.txt\nphl@kernelnewbies:~/aufs/union$ <span class=\"token builtin class-name\">echo</span> hello to rw from union <span class=\"token operator\">&gt;</span> hellorw.txt<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>我们返回到aufs目录，直接查看aufs目录下的内容。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~/aufs$ tree <span class=\"token builtin class-name\">.</span>\n<span class=\"token builtin class-name\">.</span>\n├── r1\n│   └── hellor1.txt\n├── r2\n│   └── hellor2.txt\n├── rw\n│   ├── hellor1.txt\n│   ├── hellor2.txt\n│   └── hellorw.txt\n└── union\n    ├── hellor1.txt\n    ├── hellor2.txt\n    └── hellorw.txt\n\n<span class=\"token number\">4</span> directories, <span class=\"token number\">8</span> files<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>从输出结果我们可以看到，我们修改的hellor1.txt和hellor2.txt文件分别被拷贝了一份放在读写层目录rw中。我们查看一下这些文件的内容，命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~/aufs$ <span class=\"token function\">cat</span> r1/hellor1.txt\nhello r1\nphl@kernelnewbies:~/aufs$ <span class=\"token function\">cat</span> r2/hellor2.txt\nhello r2\nphl@kernelnewbies:~/aufs$ <span class=\"token function\">cat</span> rw/hellor1.txt\nhello to r1 from union\nphl@kernelnewbies:~/aufs$ <span class=\"token function\">cat</span> rw/hellor2.txt\nhello to r2 from union\nphl@kernelnewbies:~/aufs$ <span class=\"token function\">cat</span> rw/hellorw.txt\nhello to rw from union<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>从输出结果我们看到，用户修改只读层r1、r2中的文件时，这些文件被复制到了读写层，我们修改的是读写层的副本，原只读层中的文件没有变化。用户修改读写层rw中的文件时，修改直接作用于这些文件本身。</p>\n<h3 id=\"4-3-docker-sh\">4.3.docker.sh</h3>\n<p>在继续之前，我们需要将上一章在ubuntu1604根文件系统中创建的old_root目录删除掉，以保证该根文件系统跟刚制作好时一样。命令及结果如下：</p>\n<p>phl@kernelnewbies:~/docker.sh$ sudo rm -rf images/ubuntu1604/old_root</p>\n<p>有了以上关于联合加载的介绍，我们就可以将联合加载功能加入到docker.sh中了。联合加载功能将放在container.sh脚本中，带下划线的行是我们为实现联合加载功能而新添的代码。修改后的container.sh如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token function\">hostname</span> <span class=\"token variable\">$container</span>\n\n<span class=\"token function\">mkdir</span> -p /sys/fs/cgroup/memory/<span class=\"token variable\">$container</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$$</span> <span class=\"token operator\">&gt;</span> /sys/fs/cgroup/memory/<span class=\"token variable\">$container</span>/cgroup.procs\n<span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$memory</span> <span class=\"token operator\">&gt;</span> /sys/fs/cgroup/memory/<span class=\"token variable\">$container</span>/memory.limit_in_bytes\n\n<span class=\"token function\">mkdir</span> -p <span class=\"token variable\">$container</span>/rwlayer\n<span class=\"token function\">mount</span> -t aufs -o <span class=\"token assign-left variable\">dirs</span><span class=\"token operator\">=</span><span class=\"token variable\">$container</span>/rwlayer:./images/<span class=\"token variable\">$image</span> none <span class=\"token variable\">$container</span>\n\n<span class=\"token function\">mkdir</span> -p <span class=\"token variable\">$container</span>/old_root\n<span class=\"token builtin class-name\">cd</span> <span class=\"token variable\">$container</span>\npivot_root <span class=\"token builtin class-name\">.</span> ./old_root\n\n<span class=\"token function\">mount</span> -t proc proc /proc\n<span class=\"token function\">umount</span> -l /old_root\n\n<span class=\"token builtin class-name\">exec</span> <span class=\"token variable\">$program</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>首先，我们根据容器的名字创建联合加载需要的读写层目录及文件系统挂载目录。命令如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">mkdir</span> -p <span class=\"token variable\">$container</span>/rwlayer<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>假如我们传递的容器的名字为dreamland，将创建以下目录：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~/docker.sh$ tree dreamland/\ndreamland/\n└── rwlayer<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>其中dreamland/rwlayer目录为创建的AUFS文件系统的读写层，dreamland目录为AUFS文件系统的挂载点。</p>\n<p>然后我们将镜像目录、读写层目录联合加载到挂载点目录。命令如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">mount</span> -t aufs -o <span class=\"token assign-left variable\">dirs</span><span class=\"token operator\">=</span><span class=\"token variable\">$container</span>/rwlayer:./images/<span class=\"token variable\">$image</span> none <span class=\"token variable\">$container</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>假如容器名字为dreamland，使用的镜像为ubuntu1604根文件系统，dreamland/rwlayer、images/ubuntu1604将被联合加载的dreamland目录。其中，dreamland/rwlayer为AUFS文件系统的读写层，images/ubuntu1604为AUFS文件系统的只读层。</p>\n<p>之前我们将老的根文件系统挪到了rootfs/old_root，rootfs代表一个具体的镜像目录。创建old_root目录时直接修改了该镜像。下面我们将老的根文件系统的挂载点目录放在AUFS文件系统中，并将老的根文件系统挪到此处。命令如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">mkdir</span> -p <span class=\"token variable\">$container</span>/old_root\n<span class=\"token builtin class-name\">cd</span> <span class=\"token variable\">$container</span>\npivot_root <span class=\"token builtin class-name\">.</span> ./old_root<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>此时，$container目录本身就是一个挂载点，挂载了AUFS文件系统。因此下面的代码就被移除了：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">mount</span> --bind images/<span class=\"token variable\">$image</span> images/<span class=\"token variable\">$image</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>现在，我们运行docker.sh，并在/root下创建一个文件。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~/docker.sh$ <span class=\"token function\">sudo</span> ./docker.sh -c run -m 100M -C dreamland -I ubuntu1604 -V data1 -P /bin/bash\nroot@dreamland:/<span class=\"token comment\"># cd /root</span>\nroot@dreamland:/root<span class=\"token comment\"># ls</span>\nroot@dreamland:/root<span class=\"token comment\"># cat /etc/issue &gt; hello.txt</span>\nroot@dreamland:/root<span class=\"token comment\"># cat hello.txt</span>\nUbuntu <span class=\"token number\">16.04</span> LTS <span class=\"token punctuation\">\\</span>n <span class=\"token punctuation\">\\</span>l<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>启动一个新的Shell窗口，查看一下该容器使用的AUFS文件系统。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~/docker.sh$ <span class=\"token function\">sudo</span> tree dreamland/\ndreamland/\n└── rwlayer\n    ├── old_root\n    └── root\n        └── hello.txt\n\n<span class=\"token number\">2</span> directories, <span class=\"token number\">1</span> <span class=\"token function\">file</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>从结果我们可以看到，我们新建的文件及创建的老根文件系统的挂载点目录都出现在了读写层。我们再查看一下新创建的文件。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~/docker.sh$ <span class=\"token function\">sudo</span> <span class=\"token function\">cat</span> dreamland/rwlayer/root/hello.txt\nUbuntu <span class=\"token number\">16.04</span> LTS <span class=\"token punctuation\">\\</span>n <span class=\"token punctuation\">\\</span>l<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>文件内容是Ubuntu 16.04的发行版信息。</p>\n<p>通过联合加载，我们实现了在容器中的读写不会影响使用的镜像。这样使用ubuntu1604镜像创建多个容器时，彼此之间就不会相互影响了。</p>\n<h2 id=\"5-卷\">5.卷</h2>\n<h3 id=\"5-1-卷简介\">5.1.卷简介</h3>\n<p>卷是容器内的一个目录，这个目录可以绕过联合文件系统，提供数据共享（容器所使用的的联合文件系统不应该被主机或其他容器访问）与数据持久化的功能。</p>\n<p>举个例子，假如容器有个目录为/data的卷，我们向这个卷写入的内容不会出现在联合文件系统的读写层，而是直接出现在这个目录里。主机与其他容器也可以访问该目录，从而达到数据共享与数据持久化的目的。</p>\n<p>卷位于联合文件系统中，通常来说写入该目录的内容会被写入容器的读写层中，那么怎样才能是写入卷的目录直接出现在该目录中，而不是容器读写层呢？其实方法很简单，只要我们将该目录变成一个挂载点就行，变成挂载点后，这个目录中的内容就不属于联合文件系统了，写入该目录的内容自然会保存在挂载到该挂载点的设备中。</p>\n<h3 id=\"5-2-docker-sh\">5.2 docker.sh</h3>\n<p>有了以上关于卷的介绍，我们就可以将卷功能加入到docker.sh中了。卷功能将放在container.sh脚本中，带下划线的行是我们为实现卷功能而新添的代码。修改后的container.sh脚本如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token function\">hostname</span> <span class=\"token variable\">$container</span>\n\n<span class=\"token function\">mkdir</span> -p /sys/fs/cgroup/memory/<span class=\"token variable\">$container</span>\n<span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$$</span> <span class=\"token operator\">&gt;</span> /sys/fs/cgroup/memory/<span class=\"token variable\">$container</span>/cgroup.procs\n<span class=\"token builtin class-name\">echo</span> <span class=\"token variable\">$memory</span> <span class=\"token operator\">&gt;</span> /sys/fs/cgroup/memory/<span class=\"token variable\">$container</span>/memory.limit_in_bytes\n\n<span class=\"token function\">mkdir</span> -p <span class=\"token variable\">$container</span>/rwlayer\n<span class=\"token function\">mount</span> -t aufs -o <span class=\"token assign-left variable\">dirs</span><span class=\"token operator\">=</span><span class=\"token variable\">$container</span>/rwlayer:./images/<span class=\"token variable\">$image</span> none <span class=\"token variable\">$container</span>\n\n<span class=\"token function\">mkdir</span> -p <span class=\"token variable\">$volume</span>\n<span class=\"token function\">mkdir</span> -p <span class=\"token variable\">$container</span>/<span class=\"token variable\">$volume</span>\n<span class=\"token function\">mount</span> --bind <span class=\"token variable\">$volume</span> <span class=\"token variable\">$container</span>/<span class=\"token variable\">$volume</span>\n\n<span class=\"token function\">mkdir</span> -p <span class=\"token variable\">$container</span>/old_root\n<span class=\"token builtin class-name\">cd</span> <span class=\"token variable\">$container</span>\npivot_root <span class=\"token builtin class-name\">.</span> ./old_root\n\n<span class=\"token function\">mount</span> -t proc proc /proc\n<span class=\"token function\">umount</span> -l /old_root\n\n<span class=\"token builtin class-name\">exec</span> <span class=\"token variable\">$program</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>首先，我们根据卷的名字创建主机卷目录，我们在容器内部对卷的修改，都将作用于此目录。命令如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">mkdir</span> -p <span class=\"token variable\">$volume</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>然后，我们在容器内部创建同名卷目录，该目录本身会出现在容器的读写层中，因为该目录是在AUFS文件系统中创建的。因为<img src=\"https://math.now.sh?inline=container%E7%9B%AE%E5%BD%95%E4%B8%BA%E5%AE%B9%E5%99%A8%E7%9A%84%E6%A0%B9%E7%9B%AE%E5%BD%95%EF%BC%8C%E6%89%80%E4%BB%A5%E5%AE%B9%E5%99%A8%E5%86%85%E9%83%A8%E5%8D%B7%E7%9B%AE%E5%BD%95%E7%9A%84%E8%B7%AF%E5%BE%84%E4%B8%BA%2F\" style=\"filter: opacity(90%);transform:scale(0.85);text-align:center;display:inline-block;margin: 0;\">volume。命令如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">mkdir</span> -p <span class=\"token variable\">$container</span>/<span class=\"token variable\">$volume</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>将主机上的卷目录bind mount到容器内部的卷目录上，这样容器内部对卷目录的修改，都将作用于主机卷目录。命令如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">mount</span> --bind <span class=\"token variable\">$volume</span> <span class=\"token variable\">$container</span>/<span class=\"token variable\">$volume</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>现在，我们运行docker.sh，并在卷目录（/data1）中创建一个文件。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~/docker.sh$ <span class=\"token function\">sudo</span> ./docker.sh -c run -m 100M -C dreamland -I ubuntu1604 -V data1 -P /bin/bash\nroot@dreamland:/<span class=\"token comment\"># cd /data1</span>\nroot@dreamland:/data1<span class=\"token comment\"># echo \"hello to data1 volume from ubuntu16.04\" &gt;&gt; hello.txt</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>启动一个新的Shell窗口，查看一下该容器使用的AUFS文件系统中的内容。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~/docker.sh$ <span class=\"token function\">sudo</span> tree dreamland/\ndreamland/\n└── rwlayer\n    ├── data1\n    ├── old_root\n    └── root\n        └── hello.txt\n\n<span class=\"token number\">4</span> directories, <span class=\"token number\">1</span> <span class=\"token function\">file</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>从结果我们可以看到，我们使用的卷目录被创建在了容器的读写层，但是我们在卷目录中新建的文件却没有出现在读写层中。</p>\n<p>我们再来查看一下主机卷目录的内容。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~/docker.sh$ <span class=\"token function\">sudo</span> tree data1/\ndata1/\n└── hello.txt\n\n<span class=\"token number\">0</span> directories, <span class=\"token number\">1</span> <span class=\"token function\">file</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>从结果我们可以看到，在容器内部对卷目录的修改直接作用在了主机上的卷目录。我们再来查看一下主机卷目录下hello.txt中的内容。命令及结果如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">phl@kernelnewbies:~/docker.sh$ <span class=\"token function\">sudo</span> <span class=\"token function\">cat</span> data1/hello.txt\nhello to data1 volume from ubuntu16.04<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>从结果我们可以看到，该文件的内容与我们在容器内部写入hello.txt的内容一致。</p>\n<p>通过卷目录，我们实现了容器之间数据共享与数据持久化的功能。</p>\n<h2 id=\"6-后记\">6.后记</h2>\n<p>至此，我们通过一系列的实验对docker的底层技术有了一个感性的认识。我们在使用docker时，也能够对其是如何运作的有了一个大致的了解。当然，这对于掌握docker技术来说还远远不够，有很多知识我们没有涉及，例如user namespace、容器安全、其他的CGroups、虚拟网络等。</p>\n<p>编辑整理 <a target=\"_blank\" rel=\"noopener\" href=\"https://www.toutiao.com/i6890898988879315468/?tt_from=weixin&amp;utm_campaign=client_share&amp;wxshare_count=1&amp;timestamp=1647576105&amp;app=news_article&amp;utm_source=weixin&amp;utm_medium=toutiao_android&amp;use_new_style=1&amp;req_id=202203181201440101511900790A2CBE46&amp;share_token=b2d9351e-4cb1-4a25-ae82-f70543ce2a3b&amp;group_id=6890898988879315468\">ScratchLab</a></p>\n<link rel=\"stylesheet\" href=\"/css/bilicard.css\" type=\"text/css\">",
            "tags": [
                "linux",
                "docker",
                "shell"
            ]
        },
        {
            "id": "https://blog.17lai.site/posts/593cc323/",
            "url": "https://blog.17lai.site/posts/593cc323/",
            "title": "Earthly 一个更加强大的镜像构建工具",
            "date_published": "2021-10-31T23:25:00.000Z",
            "content_html": "<h2 id=\"一、Earthly-介绍\">一、Earthly 介绍</h2>\n<blockquote>\n<p>开局一张图，功能全靠吹。</p>\n</blockquote>\n<p><img src=\"https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/11/0120211101210057.png\" alt=\"img\"></p>\n<p>Earthly 是一个更加高级的 Docker 镜像构建工具，Earthly 通过自己定义的 Earthfile 来代替传统的 Dockerfile 完成镜像构建；Earthfile 就如同 Earthly 官方所描述:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">**Makefile + Dockerfile = Earthfile**<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>在使用 Earthly 进行构建镜像时目前强依赖于 buildkit，Earthly 通过 buildkit 支持了一些 Dockerfile 的扩展语法，同时将 Dockerfile 与 Makefile 整合，使得多平台构建和代码化 Dockerfile 变得更加简单；使用 Earthly 可以更加方便的完成 Dockerfile 的代码复用以及更加友好的 CI 自动集成。</p>\n<h2 id=\"二、快速开始\">二、快速开始</h2>\n<h3 id=\"2-1、安装依赖\">2.1、安装依赖</h3>\n<p>Earthly 目前依赖于 Docker 和 Git，所以安装 Earthly 前请确保机器已经安装了 Docker 和 Git。</p>\n<h3 id=\"2-2、安装-Earthly\">2.2、安装 Earthly</h3>\n<p>Earthly 采用 Go 编写，所以主要就一个二进制文件，Linux 下安装可以直接参考官方的安装脚本:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> /bin/sh -c <span class=\"token string\">'wget https://github.com/earthly/earthly/releases/latest/download/earthly-linux-amd64 -O /usr/local/bin/earthly &amp;&amp; chmod +x /usr/local/bin/earthly &amp;&amp; /usr/local/bin/earthly bootstrap --with-autocomplete'</span>Copy<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>安装完成后 Earthly 将会启动一个 buildkitd 容器: <code>earthly-buildkitd</code>。</p>\n<h3 id=\"2-3、语法高亮\">2.3、语法高亮</h3>\n<p>目前 Earthly 官方支持 VS Code、VIM 以及 Sublime Text 三种编辑器的语法高亮，具体如何安装请参考 <a target=\"_blank\" rel=\"noopener\" href=\"https://earthly.dev/get-earthly\">官方文档</a>。</p>\n<h3 id=\"2-4、基本使用\">2.4、基本使用</h3>\n<p>本示例源于官方 Basic 教程，以下示例以编译 Go 项目为样例:</p>\n<p>首先创建一个任意名称的目录，目录中存在项目源码文件以及一个 <code>Earthfile</code> 文件；</p>\n<p><strong>main.go</strong></p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\"><span class=\"token keyword\">package</span> main\n\n<span class=\"token keyword\">import</span> <span class=\"token string\">\"fmt\"</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello world\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>Copy<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>Earthfile</strong></p>\n<pre class=\"line-numbers language-dockerfile\" data-language=\"dockerfile\"><code class=\"language-dockerfile\">FROM golang:1.17-alpine\nWORKDIR /go-example\n\nbuild:\n    COPY main.go .\n    RUN go build -o build/go-example main.go\n    SAVE ARTIFACT build/go-example /go-example AS LOCAL build/go-example\n\ndocker:\n    COPY +build/go-example .\n    ENTRYPOINT [\"/go-example/go-example\"]\n    SAVE IMAGE go-example:latestCopy<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>有了 <code>Earthfile</code> 以后我们就可以使用 <code>Earthly</code> 将其打包为镜像；</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 目录结构</span>\n~/t/earthlytest ❯❯❯ tree\n<span class=\"token builtin class-name\">.</span>\n├── Earthfile\n└── main.go\n\n<span class=\"token number\">0</span> directories, <span class=\"token number\">2</span> files\n\n<span class=\"token comment\"># 通过 earthly 进行构建</span>\n~/t/earthlytest ❯❯❯ earthly +dockerCopy<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><img src=\"https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/11/0120211101210338.png\" alt=\"img\"></p>\n<p>构建完成后我们就可以直接从 docker 的 images 列表中查看刚刚构建的镜像，并运行:</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/11/0120211101212129.png\" alt=\"img\"></p>\n<h2 id=\"三、进阶使用\">三、进阶使用</h2>\n<h3 id=\"3-1、多阶段构建\">3.1、多阶段构建</h3>\n<p>Earthfile 中包含类似 Makefile 一样的 <code>target</code>，不同的 <code>target</code> 之间还可以通过特定语法进行引用，每个 <code>target</code> 都可以被单独执行，执行过程中 earthly 会自动解析这些依赖关系。</p>\n<p>这种多阶段构建时语法很弹性，我们可以在每个阶段运行独立的命令以及使用不同的基础镜像；从快速开始中可以看到，我们始终使用了一个基础镜像(<code>golang:1.17-alpine</code>)，对于 Go 这种编译后自带运行时不依赖其语言 SDK 的应用，我们事实上可以将 “发布物” 仅放在简单的运行时系统镜像内，从而减少最终镜像体积:</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/11/0120211101210338-2.png\" alt=\"img\"></p>\n<p>由于使用了多个 target，所以我们可以单独的运行 <code>build</code> 这个 target 来验证我们的编译流程，<strong>这种多 target 的设计方便我们构建应用时对编译、打包步骤的细化拆分，同时也方便我们进行单独的验证。</strong> 例如我们单独执行 <code>build</code> 这个 target 来验证我们的编译流程是否正确:</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/11/0120211101210338-3.png\" alt=\"img\"></p>\n<p>在其他阶段验证完成后，我们可以直接运行最终的 target，earthly 会自动识别到这种依赖关系从而自动运行其依赖的 target:</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/11/0120211101210338-4.png\" alt=\"img\"></p>\n<h3 id=\"3-2、扩展指令\">3.2、扩展指令</h3>\n<h4 id=\"3-2-1、SAVE\">3.2.1、SAVE</h4>\n<p>SAVE 指令是 Earthly 自己的一个扩展指令，实际上分为 <code>SAVE ARTIFACT</code> 和 <code>SAVE IMAGE</code>；其中 <code>SAVE ARTIFACT</code> 指令格式如下:</p>\n<pre class=\"line-numbers language-dockerfile\" data-language=\"dockerfile\"><code class=\"language-dockerfile\">SAVE ARTIFACT [--keep-ts] [--keep-own] [--if-exists] [--force] &lt;src&gt; [&lt;artifact-dest-path&gt;] [AS LOCAL &lt;local-path&gt;]Copy<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><code>SAVE ARTIFACT</code> 指令用于将文件或目录从 build 运行时环境保存到 target 的 artifact 环境；当保存到 artifact 环境后，可以通过 <code>COPY</code> 等命令在其他位置进行引用，类似于 Dockerfile 的 <code>COPY --from...</code> 语法；不同的是 <code>SAVE ARTIFACT</code> 支持 <code>AS LOCAL &lt;local-path&gt;</code> 附加参数，一但指定此参数后，earthly 会同时将文件或目录在宿主机复制一份，一般用于调试等目的。<code>SAVE ARTIFACT</code> 命令在上面的样例中已经展示了，在运行完 <code>earthly +build</code> 命令后实际上会在本地看到被 SAVE 出来的 ARTIFACT:</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/11/0120211101210338-5.png\" alt=\"img\"></p>\n<p>而另一个 <code>SAVE IMAGE</code> 指令则主要用于将当前的 build 环境 SAVE 为一个 IMAGE，<strong>如果指定了 <code>--push</code> 选项，同时在执行 <code>earthly +target</code> 命令时也加入 <code>--push</code> 选项，该镜像将会自动被推送到目标 Registry 上。</strong><code>SAVE IMAGE</code> 指令格式如下:</p>\n<pre class=\"line-numbers language-dockerfile\" data-language=\"dockerfile\"><code class=\"language-dockerfile\">SAVE IMAGE [--cache-from=&lt;cache-image&gt;] [--push] &lt;image-name&gt;...Copy<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p><img src=\"https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/11/0120211101210338-6.png\" alt=\"img\"></p>\n<h4 id=\"3-2-2、GIT-CLONE\">3.2.2、GIT CLONE</h4>\n<p><code>GIT CLONE</code> 指令用于将指定 git 仓库 clone 到 build 环境中；与 <code>RUN git clone...</code> 命令不同的是，<strong><code>GIT CLONE</code> 通过宿主机的 git 命令运行，它不依赖于容器内的 git 命令，同时还可以直接为 earthly 配置 git 认证，从而避免将这些安全信息泄漏到 build 环境中；</strong> 关于如何配置 earthly 的 git 认证请参考 <a target=\"_blank\" rel=\"noopener\" href=\"https://docs.earthly.dev/docs/guides/auth\">官方文档</a>；下面是 <code>GIT CLONE</code> 指令的样例</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/11/0120211101213746.png\" alt=\"img\"></p>\n<h4 id=\"3-2-3、COPY\">3.2.3、COPY</h4>\n<p><code>COPY</code> 指令与标准的 Dockerfile COPY 指令类似，除了支持 Dockerfile 标准的 COPY 功能以外，<strong>earthly 中的 <code>COPY</code> 指令可以引用其他 target 环节产生的 artifact，在引用时会自动声明依赖关系；即当在 <code>B</code> target 中存在 <code>COPY +A/xxxxx /path/to/copy</code> 类似的指令时，如果只单纯的执行 <code>earthly +B</code>，那么 earthly 根据依赖分析会得出在 COPY 之前需要执行 target A。</strong><code>COPY</code> 指令的语法格式如下:</p>\n<pre class=\"line-numbers language-dockerfile\" data-language=\"dockerfile\"><code class=\"language-dockerfile\"># 与 Dockerfile 相同的使用方式，从上下文复制\nCOPY [options...] &lt;src&gt;... &lt;dest&gt;\n\n# 扩展支持的从 target 复制方式\nCOPY [options...] &lt;src-artifact&gt;... &lt;dest&gt;Copy<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"3-2-4、RUN\">3.2.4、RUN</h4>\n<p><code>RUN</code> 指令在标准使用上与 Dockerfile 里保持一致，除此之外增加了更多的扩展选项，其指令格式如下:</p>\n<pre class=\"line-numbers language-dockerfile\" data-language=\"dockerfile\"><code class=\"language-dockerfile\"># shell 方式运行(/bin/sh -c)\nRUN [--push] [--entrypoint] [--privileged] [--secret &lt;env-var&gt;=&lt;secret-ref&gt;] [--ssh] [--mount &lt;mount-spec&gt;] [--] &lt;command&gt;\n\n# exec 方式运行\nRUN [[&lt;flags&gt;...], \"&lt;executable&gt;\", \"&lt;arg1&gt;\", \"&lt;arg2&gt;\", ...]Copy<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>其中 <code>--privileged</code> 选项允许运行的命令使用 <code>privileged capabilities</code>，但是需要 earthly 在运行 target 时增加 <code>--allow-privileged</code> 选项；<code>--interactive / --interactive-keep</code> 选项用于交互式执行一些命令，在完成交互后 build 继续进行，<strong>在交互过程中进行的操作都会被持久化到 镜像中:</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/11/0120211101210338-8.png\" alt=\"img\"></p>\n<p>限于篇幅原因，其他的具体指令请查阅官方文档 <a target=\"_blank\" rel=\"noopener\" href=\"https://docs.earthly.dev/docs/earthfile\">Earthfile reference</a>。</p>\n<h3 id=\"3-3、UDCS\">3.3、UDCS</h3>\n<p>UDCs 全称 “User-defined commands”，即用户定义指令；通过 UDCs 我们可以将 Earthfile 中特定的命令剥离出来，从而实现更加通用和统一的代码复用；下面是一个定义 UDCs 指令的样例:</p>\n<pre class=\"line-numbers language-dockerfile\" data-language=\"dockerfile\"><code class=\"language-dockerfile\"># 定义一个 Command\n# ⚠️ 注意: 语法必须满足以下规则\n# 1、名称全大写\n# 2、名称下划线分割\n# 3、首个命令必须为 COMMAND(后面没有冒号)\nMY_COPY:\n    COMMAND\n    ARG src\n    ARG dest=./\n    ARG recursive=false\n    RUN cp $(if $recursive =  \"true\"; then printf -- -r; fi) \"$src\" \"$dest\"\n\n# target 中引用\nbuild:\n    FROM alpine:3.13\n    WORKDIR /udc-example\n    RUN echo \"hello\" &gt;./foo\n    # 通过 DO 关键字引用 UDCs\n    DO +MY_COPY --src=./foo --dest=./bar\n    RUN cat ./bar # prints \"hello\"Copy<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>UDCs 不光可以定义在一个 Earthfile 中，UDCs 可以跨文件、跨目录引用:</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/11/0120211101212525.png\" alt=\"img\"></p>\n<p>有了 UDCs 以后，我们可以通过这种方式将对基础镜像的版本统一控制、对特殊镜像的通用处理等操作全部抽象出来，然后每个 Earthfile 根据需要进行引用；关于 UDCs 的使用样例可以参考我的 <a target=\"_blank\" rel=\"noopener\" href=\"https://github.com/mritd/autobuild\">autobuild</a> 项目，其中的 <a target=\"_blank\" rel=\"noopener\" href=\"https://github.com/mritd/autobuild/tree/main/earthfiles/udcs\">udcs</a> 目录定义了大量的通用 UDCs，这些 UDCs 被其他目标镜的 Earthfile 批量引用。</p>\n<h3 id=\"3-4、多平台构建\">3.4、多平台构建</h3>\n<p>在以前使用 Dockerfile 的时候，我们需要自己配置然后开启 buildkit 来实现多平台构建；在配置过程中可能会很繁琐，现在使用 earthly 可以默认帮我们实现多平台的交叉编译，我们需要做的仅仅是在 Earthfile 中声明需要支持哪些平台而已:</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/11/0120211101210338-10.png\" alt=\"img\"></p>\n<p>以上 Earthfile 在执行 <code>earthly --push +all</code> 构建时，将会自动构建四个平台的镜像，并保持单个 tag，同时由于使用了 <code>--push</code> 选项还会自动推送到 Docker Hub 上:</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/11/0120211101210338-11.png\" alt=\"img\"></p>\n<h2 id=\"四、总结\">四、总结</h2>\n<p>Earthly 弥补了 Dockerfile 的很多不足，解决了很多痛点问题；但同样可能需要一些学习成本，但是如果已经熟悉了 Dockerfile 其实学习成本不高；所以目前还是比较推荐将 Dockerfile 切换为 Earthfile 进行统一和版本化管理的。本文由于篇幅所限(懒)很多地方没有讲，比如共享缓存等，所以关于 Earthly 更多的详细使用等最好还是仔细阅读一下<a target=\"_blank\" rel=\"noopener\" href=\"https://docs.earthly.dev/docs/guides\">官方文档</a>。</p>\n<blockquote>\n<p>整理转载：<a target=\"_blank\" rel=\"noopener\" href=\"https://mritd.com/2021/10/27/the-best-image-build-tool-earthly/\">the-best-image-build-tool-earthly</a></p>\n</blockquote>\n<h2 id=\"系列教程-10\"><strong>系列教程</strong></h2>\n<p><a href=\"https://blog.17lai.site/atom.xml\">全部文章RSS订阅</a></p>\n<p><strong>Docker系列</strong> <a href=\"https://blog.17lai.site/categories/docker/atom.xml\"><strong>Docker 分类 RSS 订阅</strong></a></p>\n<ul>\n<li><a href=\"https://blog.17lai.site/posts/42b6a86d/\">Docker使用简明教程</a></li>\n<li><a href=\"https://blog.17lai.site/posts/9912bd5d/\">使用jeckett,sonarr,iyuu,qt,emby打造全自动追剧流程</a></li>\n<li><a href=\"https://blog.17lai.site/posts/1802a8a7/\">为知笔记私有化Docker部署</a></li>\n<li><a href=\"https://blog.17lai.site/posts/593cc323/\">Earthly 一个更加强大的镜像构建工具</a></li>\n<li><a href=\"https://blog.17lai.site/posts/90e60aac/\">使用 Shell 脚本实现一个简单 Docker</a></li>\n<li><a href=\"https://blog.17lai.site/posts/465d2738/\">如何使用Traefik V2 在Ubuntu20.04 上面来做 Dockers</a></li>\n<li><a href=\"https://blog.17lai.site/posts/462f1e5c/\">通过IPV6访问Qnap NAS中Docker的服务</a></li>\n</ul>\n<link rel=\"stylesheet\" href=\"/css/bilicard.css\" type=\"text/css\">",
            "tags": [
                "docker",
                "earthly"
            ]
        },
        {
            "id": "https://blog.17lai.site/posts/465d2738/",
            "url": "https://blog.17lai.site/posts/465d2738/",
            "title": "如何使用Traefik V2 在Ubuntu20.04 上面来做 Dockers Containers 的反向代理",
            "date_published": "2021-10-14T11:25:00.000Z",
            "content_html": "<p>How To Use Traefik v2 as a Reverse Proxy for Docker Containers on Ubuntu 20.04</p>\n<blockquote>\n<p>Traefik 适合配合Dockers swarm 做服务， Dockers portainer 做管理，ELK集群做监控日志。</p>\n</blockquote>\n<p><img src=\"https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/10/1420211014200800.png\" alt=\"Traefik\"></p>\n<p><code>traefik</code> 与 <code>nginx</code> 一样，是一款优秀的反向代理工具，或者叫 <code>Edge Router</code>。至于使用它的原因则基于以下几点</p>\n<ul>\n<li>无须重启即可更新配置</li>\n<li>自动的服务发现与负载均衡</li>\n<li>与 <code>docker</code> 完美集成，基于 <code>container label</code> 的配置</li>\n<li>漂亮的 <code>dashboard</code> 界面</li>\n<li><code>metrics</code> 的支持，支持对 <code>prometheus</code> 和 <code>k8s</code> 集成</li>\n</ul>\n<h3 id=\"Introduction\">Introduction</h3>\n<p><a target=\"_blank\" rel=\"noopener\" href=\"https://www.docker.com/\">Docker</a> can be an efficient way to run web applications in production, but you may want to run multiple applications on the same Docker host. In this situation, you’ll need to set up a reverse proxy. This is because you only want to expose ports <code>80</code> and <code>443</code> to the rest of the world.</p>\n<p><a target=\"_blank\" rel=\"noopener\" href=\"https://traefik.io/\">Traefik</a> is a Docker-aware reverse proxy that includes a monitoring dashboard. Traefik v1 has been widely used for a while, and <a target=\"_blank\" rel=\"noopener\" href=\"https://www.digitalocean.com/community/tutorials/how-to-use-traefik-as-a-reverse-proxy-for-docker-containers-on-ubuntu-20-04\">you can follow this earlier tutorial to install Traefik v1</a>). But in this tutorial, you’ll install and configure Traefik v2, which includes quite a few differences.</p>\n<p>The biggest difference between Traefik v1 and v2 is that <em>frontends</em> and <em>backends</em> were removed and their combined functionality spread out across <em>routers</em>, <em>middlewares</em>, and <em>services</em>. Previously a backend did the job of making modifications to requests and getting that request to whatever was supposed to handle it. Traefik v2 provides more separation of concerns by introducing middlewares that can modify requests before sending them to a service. Middlewares make it easier to specify a single modification step that might be used by a lot of different routes so that they can be reused (such as HTTP Basic Auth, which you’ll see later). A router can also use many different middlewares.</p>\n<p>In this tutorial you’ll configure Traefik v2 to route requests to two different web application containers: a <a target=\"_blank\" rel=\"noopener\" href=\"http://wordpress.org/\">Wordpress</a> container and an <a target=\"_blank\" rel=\"noopener\" href=\"https://www.adminer.org/\">Adminer</a> container, each talking to a <a target=\"_blank\" rel=\"noopener\" href=\"https://www.mysql.com/\">MySQL</a> database. You’ll configure Traefik to serve everything over HTTPS using <a target=\"_blank\" rel=\"noopener\" href=\"https://letsencrypt.org/\">Let’s Encrypt</a>.</p>\n<h2 id=\"Prerequisites\">Prerequisites</h2>\n<p>To complete this tutorial, you will need the following:</p>\n<ul>\n<li><a target=\"_blank\" rel=\"noopener\" href=\"https://www.digitalocean.com/products/linux-distribution/ubuntu/\">One Ubuntu 20.04 server</a> with a sudo non-root user and a firewall. You can set this up by following our <a target=\"_blank\" rel=\"noopener\" href=\"https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-20-04\">Ubuntu 20.04 initial server setup guide</a>.</li>\n<li>Docker installed on your server, which you can accomplish by following <strong>Steps 1 and 2</strong> of <a target=\"_blank\" rel=\"noopener\" href=\"https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-20-04\">How to Install and Use Docker on Ubuntu 20.04</a>.</li>\n<li>Docker Compose installed using the instructions from <strong>Step 1</strong> of <a target=\"_blank\" rel=\"noopener\" href=\"https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-compose-on-ubuntu-20-04\">How to Install Docker Compose on Ubuntu 20.04</a>.</li>\n<li>A domain and three A records, <code>db-admin.your_domain</code>, <code>blog.your_domain</code> and <code>monitor.your_domain</code>. Each should point to the IP address of your server. You can learn how to point domains to DigitalOcean Droplets by reading through <a target=\"_blank\" rel=\"noopener\" href=\"https://www.digitalocean.com/docs/networking/dns/\">DigitalOcean’s Domains and DNS documentation</a>. Throughout this tutorial, substitute your domain for <code>your_domain</code> in the configuration files and examples.</li>\n</ul>\n<h2 id=\"Step-1-—-Configuring-and-Running-Traefik\">Step 1 — Configuring and Running Traefik</h2>\n<p>The Traefik project has an <a target=\"_blank\" rel=\"noopener\" href=\"https://hub.docker.com/_/traefik\">official Docker image</a>, so you will use that to run Traefik in a Docker container.</p>\n<p>But before you get your Traefik container up and running, you need to create a configuration file and set up an encrypted password so you can access the monitoring dashboard.</p>\n<p>You’ll use the <code>htpasswd</code> utility to create this encrypted password. First, install the utility, which is included in the <code>apache2-utils</code> package:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> apache2-utils<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>Then generate the password with <code>htpasswd</code>. Substitute <code>secure_password</code> with the password you’d like to use for the Traefik admin user:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">htpasswd -nb admin secure_password<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>The output from the program will look like this:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Outputadmin:$apr1$ruca84Hq$mbjdMZBAG.KWn7vfN/SNK/<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>You’ll use this output in the Traefik configuration file to set up HTTP Basic Authentication for the Traefik health check and monitoring dashboard. Copy the entire output line so you can paste it later.</p>\n<p>To configure the Traefik server, you’ll create two new configuration files called <code>traefik.toml</code> and <code>traefik_dynamic.toml</code> using the TOML format. <a target=\"_blank\" rel=\"noopener\" href=\"https://github.com/toml-lang/toml\">TOML</a> is a configuration language similar to INI files, but standardized. <a target=\"_blank\" rel=\"noopener\" href=\"https://docs.traefik.io/providers/overview/\">These files let us configure the Traefik server and various integrations</a>, or <code>providers</code>, that you want to use. In this tutorial, you will use three of Traefik’s available providers: <code>api</code>, <code>docker</code>, and <code>acme</code>. The last of these, <code>acme</code>, supports TLS certificates using Let’s Encrypt.</p>\n<p>Create and open <code>traefik.toml</code> using <code>nano</code> or your preferred text editor:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">nano</span> traefik.toml<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>First, you want to specify the ports that Traefik should listen on using the <code>entryPoints</code> section of your config file. You want two because you want to listen on port <code>80</code> and <code>443</code>. Let’s call these <code>web</code> (port <code>80</code>) and <code>websecure</code> (port <code>443</code>).</p>\n<p>Add the following configurations:</p>\n<p>traefik.toml</p>\n<pre class=\"line-numbers language-toml\" data-language=\"toml\"><code class=\"language-toml\"><span class=\"token punctuation\">[</span><span class=\"token table class-name\">entryPoints</span><span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">[</span><span class=\"token table class-name\">entryPoints.web</span><span class=\"token punctuation\">]</span>\n    <span class=\"token key property\">address</span> <span class=\"token punctuation\">=</span> <span class=\"token string\">\":80\"</span>\n    <span class=\"token punctuation\">[</span><span class=\"token table class-name\">entryPoints.web.http.redirections.entryPoint</span><span class=\"token punctuation\">]</span>\n      <span class=\"token key property\">to</span> <span class=\"token punctuation\">=</span> <span class=\"token string\">\"websecure\"</span>\n      <span class=\"token key property\">scheme</span> <span class=\"token punctuation\">=</span> <span class=\"token string\">\"https\"</span>\n\n  <span class=\"token punctuation\">[</span><span class=\"token table class-name\">entryPoints.websecure</span><span class=\"token punctuation\">]</span>\n    <span class=\"token key property\">address</span> <span class=\"token punctuation\">=</span> <span class=\"token string\">\":443\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>Note that you are also automatically redirecting traffic to be handled over TLS.</p>\n<p>Next, configure the Traefik <code>api</code>, which gives you access to both the API and your dashboard interface. The heading of <code>[api]</code> is all that you need because the dashboard is then enabled by default, but you’ll be explicit for the time being.</p>\n<p>Add the following code:</p>\n<p>traefik.toml</p>\n<pre class=\"line-numbers language-toml\" data-language=\"toml\"><code class=\"language-toml\"><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">[</span><span class=\"token table class-name\">api</span><span class=\"token punctuation\">]</span>\n  <span class=\"token key property\">dashboard</span> <span class=\"token punctuation\">=</span> <span class=\"token boolean\">true</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>To finish securing your web requests you want to use Let’s Encrypt to generate valid TLS certificates. Traefik v2 supports Let’s Encrypt out of the box and you can configure it by creating a <em>certificates resolver</em> of the type <code>acme</code>.</p>\n<p>Let’s configure your certificates resolver now using the name <code>lets-encrypt</code>:</p>\n<p>traefik.toml</p>\n<pre class=\"line-numbers language-toml\" data-language=\"toml\"><code class=\"language-toml\"><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">[</span><span class=\"token table class-name\">certificatesResolvers.lets-encrypt.acme</span><span class=\"token punctuation\">]</span>\n  <span class=\"token key property\">email</span> <span class=\"token punctuation\">=</span> <span class=\"token string\">\"your_email@your_domain\"</span>\n  <span class=\"token key property\">storage</span> <span class=\"token punctuation\">=</span> <span class=\"token string\">\"acme.json\"</span>\n  <span class=\"token punctuation\">[</span><span class=\"token table class-name\">certificatesResolvers.lets-encrypt.acme.tlsChallenge</span><span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>This section is called <code>acme</code> because <a target=\"_blank\" rel=\"noopener\" href=\"https://github.com/ietf-wg-acme/acme/\">ACME</a> is the name of the protocol used to communicate with Let’s Encrypt to manage certificates. The Let’s Encrypt service requires registration with a valid email address, so to have Traefik generate certificates for your hosts, set the <code>email</code> key to your email address. You then specify that you will store the information that you will receive from Let’s Encrypt in a JSON file called <code>acme.json</code>.</p>\n<p>The <code>acme.tlsChallenge</code> section allows us to specify how Let’s Encrypt can verify that the certificate. You’re configuring it to serve a file as part of the challenge over port <code>443</code>.</p>\n<p>Finally, you need to configure Traefik to work with Docker.</p>\n<p>Add the following configurations:</p>\n<p>traefik.toml</p>\n<pre class=\"line-numbers language-toml\" data-language=\"toml\"><code class=\"language-toml\"><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">[</span><span class=\"token table class-name\">providers.docker</span><span class=\"token punctuation\">]</span>\n  <span class=\"token key property\">watch</span> <span class=\"token punctuation\">=</span> <span class=\"token boolean\">true</span>\n  <span class=\"token key property\">network</span> <span class=\"token punctuation\">=</span> <span class=\"token string\">\"web\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>The <code>docker</code> provider enables Traefik to act as a proxy in front of Docker containers. You’ve configured the provider to <code>watch</code> for new containers on the <code>web</code> network, which you’ll create soon.</p>\n<p>Our final configuration uses the <code>file</code> provider. With Traefik v2, static and dynamic configurations can’t be mixed and matched. To get around this, you will use <code>traefik.toml</code> to define your static configurations and then keep your dynamic configurations in another file, which you will call <code>traefik_dynamic.toml</code>. Here you are using the <code>file</code> provider to tell Traefik that it should read in dynamic configurations from a different file.</p>\n<p>Add the following <code>file</code> provider:</p>\n<p>traefik.toml</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token punctuation\">[</span>providers.file<span class=\"token punctuation\">]</span>\n  filename <span class=\"token operator\">=</span> <span class=\"token string\">\"traefik_dynamic.toml\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>Your completed <code>traefik.toml</code> will look like this:</p>\n<p>traefik.toml</p>\n<pre class=\"line-numbers language-toml\" data-language=\"toml\"><code class=\"language-toml\"><span class=\"token punctuation\">[</span><span class=\"token table class-name\">entryPoints</span><span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">[</span><span class=\"token table class-name\">entryPoints.web</span><span class=\"token punctuation\">]</span>\n    <span class=\"token key property\">address</span> <span class=\"token punctuation\">=</span> <span class=\"token string\">\":80\"</span>\n    <span class=\"token punctuation\">[</span><span class=\"token table class-name\">entryPoints.web.http.redirections.entryPoint</span><span class=\"token punctuation\">]</span>\n      <span class=\"token key property\">to</span> <span class=\"token punctuation\">=</span> <span class=\"token string\">\"websecure\"</span>\n      <span class=\"token key property\">scheme</span> <span class=\"token punctuation\">=</span> <span class=\"token string\">\"https\"</span>\n\n  <span class=\"token punctuation\">[</span><span class=\"token table class-name\">entryPoints.websecure</span><span class=\"token punctuation\">]</span>\n    <span class=\"token key property\">address</span> <span class=\"token punctuation\">=</span> <span class=\"token string\">\":443\"</span>\n\n<span class=\"token punctuation\">[</span><span class=\"token table class-name\">api</span><span class=\"token punctuation\">]</span>\n  <span class=\"token key property\">dashboard</span> <span class=\"token punctuation\">=</span> <span class=\"token boolean\">true</span>\n\n<span class=\"token punctuation\">[</span><span class=\"token table class-name\">certificatesResolvers.lets-encrypt.acme</span><span class=\"token punctuation\">]</span>\n  <span class=\"token key property\">email</span> <span class=\"token punctuation\">=</span> <span class=\"token string\">\"your_email@your_domain\"</span>\n  <span class=\"token key property\">storage</span> <span class=\"token punctuation\">=</span> <span class=\"token string\">\"acme.json\"</span>\n  <span class=\"token punctuation\">[</span><span class=\"token table class-name\">certificatesResolvers.lets-encrypt.acme.tlsChallenge</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token punctuation\">[</span><span class=\"token table class-name\">providers.docker</span><span class=\"token punctuation\">]</span>\n  <span class=\"token key property\">watch</span> <span class=\"token punctuation\">=</span> <span class=\"token boolean\">true</span>\n  <span class=\"token key property\">network</span> <span class=\"token punctuation\">=</span> <span class=\"token string\">\"web\"</span>\n\n<span class=\"token punctuation\">[</span><span class=\"token table class-name\">providers.file</span><span class=\"token punctuation\">]</span>\n  <span class=\"token key property\">filename</span> <span class=\"token punctuation\">=</span> <span class=\"token string\">\"traefik_dynamic.toml\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>Save and close the file.</p>\n<p>Now let’s create <code>traefik_dynamic.toml</code>.</p>\n<p>The dynamic configuration values that you need to keep in their own file are the <em>middlewares</em> and the <em>routers</em>. To put your dashboard behind a password you need to customize the API’s <em>router</em> and configure a <em>middleware</em> to handle HTTP basic authentication. Let’s start by setting up the middleware.</p>\n<p>The middleware is configured on a per-protocol basis and since you’re working with HTTP you’ll specify it as a section chained off of <code>http.middlewares</code>. Next comes the name of your middleware so that you can reference it later, followed by the type of middleware that it is, which will be <code>basicAuth</code> in this case. Let’s call your middleware <code>simpleAuth</code>.</p>\n<p>Create and open a new file called <code>traefik_dynamic.toml</code>:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">nano</span> traefik_dynamic.toml<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>Add the following code. This is where you’ll paste the output from the <code>htpasswd</code> command:</p>\n<p>traefik_dynamic.toml</p>\n<pre class=\"line-numbers language-toml\" data-language=\"toml\"><code class=\"language-toml\"><span class=\"token punctuation\">[</span><span class=\"token table class-name\">http.middlewares.simpleAuth.basicAuth</span><span class=\"token punctuation\">]</span>\n  <span class=\"token key property\">users</span> <span class=\"token punctuation\">=</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">\"admin:$apr1$ruca84Hq$mbjdMZBAG.KWn7vfN/SNK/\"</span>\n  <span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>To configure the router for the api you’ll once again be chaining off of the protocol name, but instead of using <code>http.middlewares</code>, you’ll use <code>http.routers</code> followed by the name of the router. In this case, the <code>api</code> provides its own named router that you can configure by using the <code>[http.routers.api]</code> section. You’ll configure the domain that you plan on using with your dashboard also by setting the <code>rule</code> key using a host match, the entrypoint to use <code>websecure</code>, and the middlewares to include <code>simpleAuth</code>.</p>\n<p>Add the following configurations:</p>\n<p>traefik_dynamic.toml</p>\n<pre class=\"line-numbers language-toml\" data-language=\"toml\"><code class=\"language-toml\"><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n<span class=\"token punctuation\">[</span><span class=\"token table class-name\">http.routers.api</span><span class=\"token punctuation\">]</span>\n  <span class=\"token key property\">rule</span> <span class=\"token punctuation\">=</span> <span class=\"token string\">\"Host(`monitor.your_domain`)\"</span>\n  <span class=\"token key property\">entrypoints</span> <span class=\"token punctuation\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"websecure\"</span><span class=\"token punctuation\">]</span>\n  <span class=\"token key property\">middlewares</span> <span class=\"token punctuation\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"simpleAuth\"</span><span class=\"token punctuation\">]</span>\n  <span class=\"token key property\">service</span> <span class=\"token punctuation\">=</span> <span class=\"token string\">\"api@internal\"</span>\n  <span class=\"token punctuation\">[</span><span class=\"token table class-name\">http.routers.api.tls</span><span class=\"token punctuation\">]</span>\n    <span class=\"token key property\">certResolver</span> <span class=\"token punctuation\">=</span> <span class=\"token string\">\"lets-encrypt\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>The <code>web</code> entry point handles port <code>80</code>, while the <code>websecure</code> entry point uses port <code>443</code> for TLS/SSL. You automatically redirect all of the traffic on port <code>80</code> to the <code>websecure</code> entry point to force secure connections for all requests.</p>\n<p>Notice the last three lines here configure a <em>service</em>, enable tls, and configure <code>certResolver</code> to <code>\"lets-encrypt\"</code>. Services are the final step to determining where a request is finally handled. The <code>api@internal</code> service is a built-in service that sits behind the API that you expose. Just like routers and middlewares, services can be configured in this file, but you won’t need to do that to achieve your desired result.</p>\n<p>Your completed <code>traefik_dynamic.toml</code> file will look like this:</p>\n<p>traefik_dynamic.toml</p>\n<pre class=\"line-numbers language-toml\" data-language=\"toml\"><code class=\"language-toml\"><span class=\"token punctuation\">[</span><span class=\"token table class-name\">http.middlewares.simpleAuth.basicAuth</span><span class=\"token punctuation\">]</span>\n  <span class=\"token key property\">users</span> <span class=\"token punctuation\">=</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">\"admin:$apr1$ruca84Hq$mbjdMZBAG.KWn7vfN/SNK/\"</span>\n  <span class=\"token punctuation\">]</span>\n\n<span class=\"token punctuation\">[</span><span class=\"token table class-name\">http.routers.api</span><span class=\"token punctuation\">]</span>\n  <span class=\"token key property\">rule</span> <span class=\"token punctuation\">=</span> <span class=\"token string\">\"Host(`monitor.your_domain`)\"</span>\n  <span class=\"token key property\">entrypoints</span> <span class=\"token punctuation\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"websecure\"</span><span class=\"token punctuation\">]</span>\n  <span class=\"token key property\">middlewares</span> <span class=\"token punctuation\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"simpleAuth\"</span><span class=\"token punctuation\">]</span>\n  <span class=\"token key property\">service</span> <span class=\"token punctuation\">=</span> <span class=\"token string\">\"api@internal\"</span>\n  <span class=\"token punctuation\">[</span><span class=\"token table class-name\">http.routers.api.tls</span><span class=\"token punctuation\">]</span>\n    <span class=\"token key property\">certResolver</span> <span class=\"token punctuation\">=</span> <span class=\"token string\">\"lets-encrypt\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>Save the file and exit the editor.</p>\n<p>With these configurations in place, you will now start Traefik.</p>\n<h2 id=\"Step-2-–-Running-the-Traefik-Container\">Step 2 – Running the Traefik Container</h2>\n<p>In this step you will create a Docker network for the proxy to share with containers. You will then access the Traefik dashboard. The Docker network is necessary so that you can use it with applications that are run using Docker Compose.</p>\n<p>Create a new Docker network called <code>web</code>:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> network create web<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>When the Traefik container starts, you will add it to this network. Then you can add additional containers to this network later for Traefik to proxy to.</p>\n<p>Next, create an empty file that will hold your Let’s Encrypt information. You’ll share this into the container so Traefik can use it:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">touch</span> acme.json<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>Traefik will only be able to use this file if the root user inside of the container has unique read and write access to it. To do this, lock down the permissions on <code>acme.json</code> so that only the owner of the file has read and write permission.</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">chmod</span> <span class=\"token number\">600</span> acme.json<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>Once the file gets passed to Docker, the owner will automatically change to the <strong>root</strong> user inside the container.</p>\n<p>Finally, create the Traefik container with this command:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> run -d <span class=\"token punctuation\">\\</span>\n  -v /var/run/docker.sock:/var/run/docker.sock <span class=\"token punctuation\">\\</span>\n  -v <span class=\"token environment constant\">$PWD</span>/traefik.toml:/traefik.toml <span class=\"token punctuation\">\\</span>\n  -v <span class=\"token environment constant\">$PWD</span>/traefik_dynamic.toml:/traefik_dynamic.toml <span class=\"token punctuation\">\\</span>\n  -v <span class=\"token environment constant\">$PWD</span>/acme.json:/acme.json <span class=\"token punctuation\">\\</span>\n  -p <span class=\"token number\">80</span>:80 <span class=\"token punctuation\">\\</span>\n  -p <span class=\"token number\">443</span>:443 <span class=\"token punctuation\">\\</span>\n  --network web <span class=\"token punctuation\">\\</span>\n  --name traefik <span class=\"token punctuation\">\\</span>\n  traefik:v2.2<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>This command is a little long. Let’s break it down.</p>\n<p>You use the <code>-d</code> flag to run the container in the background as a daemon. You then share your <code>docker.sock</code> file into the container so that the Traefik process can listen for changes to containers. You also share the <code>traefik.toml</code> and <code>traefik_dynamic.toml</code> configuration files into the container, as well as <code>acme.json</code>.</p>\n<p>Next, you map ports <code>:80</code> and <code>:443</code> of your Docker host to the same ports in the Traefik container so Traefik receives all HTTP and HTTPS traffic to the server.</p>\n<p>You set the network of the container to <code>web</code>, and you name the container <code>traefik</code>.</p>\n<p>Finally, you use the <code>traefik:v2.2</code> image for this container so that you can guarantee that you’re not running a completely different version than this tutorial is written for.</p>\n<p><a target=\"_blank\" rel=\"noopener\" href=\"https://docs.docker.com/engine/reference/builder/#entrypoint\">A Docker image’s <code>ENTRYPOINT</code> is a command that always runs when a container is created from the image</a>. In this case, the command is the <code>traefik</code> binary within the container. You can pass additional arguments to that command when you launch the container, but you’ve configured all of your settings in the <code>traefik.toml</code> file.</p>\n<p>With the container started, you now have a dashboard you can access to see the health of your containers. You can also use this dashboard to visualize the routers, services, and middlewares that Traefik has registered. You can try to access the monitoring dashboard by pointing your browser to <code>https://monitor.your_domain/dashboard/</code> (the trailing <code>/</code> is required).</p>\n<p>You will be prompted for your username and password, which are <strong>admin</strong> and the password you configured in Step 1.</p>\n<p>Once logged in, you’ll see the Traefik interface:</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/10/1420211014200207.png\" alt=\"Empty Traefik dashboard\"></p>\n<p>You will notice that there are already some routers and services registered, but those are the ones that come with Traefik and the router configuration that you wrote for the API.</p>\n<p>You now have your Traefik proxy running, and you’ve configured it to work with Docker and monitor other containers. In the next step you will start some containers for Traefik to proxy.</p>\n<h2 id=\"Step-3-—-Registering-Containers-with-Traefik\">Step 3 — Registering Containers with Traefik</h2>\n<p>With the Traefik container running, you’re ready to run applications behind it. Let’s launch the following containers behind Traefik:</p>\n<ol>\n<li>A blog using the <a target=\"_blank\" rel=\"noopener\" href=\"https://hub.docker.com/_/wordpress/\">official WordPress image</a>.</li>\n<li>A database management server using the <a target=\"_blank\" rel=\"noopener\" href=\"https://hub.docker.com/_/adminer/\">official Adminer image</a>.</li>\n</ol>\n<p>You’ll manage both of these applications with Docker Compose using a <code>docker-compose.yml</code> file.</p>\n<p>Create and open the <code>docker-compose.yml</code> file in your editor:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">nano</span> docker-compose.yml<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>Add the following lines to the file to specify the version and the networks you’ll use:</p>\n<p>docker-compose.yml</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">version</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"3\"</span>\n\n<span class=\"token key atrule\">networks</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">web</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">external</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n  <span class=\"token key atrule\">internal</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">external</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">false</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>You use Docker Compose version <code>3</code> because it’s the newest major version of the Compose file format.</p>\n<p>For Traefik to recognize your applications, they must be part of the same network, and since you created the network manually, you pull it in by specifying the network name of <code>web</code> and setting <code>external</code> to <code>true</code>. Then you define another network so that you can connect your exposed containers to a database container that you won’t expose through Traefik. You’ll call this network <code>internal</code>.</p>\n<p>Next, you’ll define each of your <code>services</code>, one at a time. Let’s start with the <code>blog</code> container, which you’ll base on the official WordPress image. Add this configuration to the bottom of the file:</p>\n<p>docker-compose.yml</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"><span class=\"token punctuation\">...</span>\n\n<span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">blog</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> wordpress<span class=\"token punctuation\">:</span>4.9.8<span class=\"token punctuation\">-</span>apache\n    <span class=\"token key atrule\">environment</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">WORDPRESS_DB_PASSWORD</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">labels</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> traefik.http.routers.blog.rule=Host(`blog.your_domain`)\n      <span class=\"token punctuation\">-</span> traefik.http.routers.blog.tls=true\n      <span class=\"token punctuation\">-</span> traefik.http.routers.blog.tls.certresolver=lets<span class=\"token punctuation\">-</span>encrypt\n      <span class=\"token punctuation\">-</span> traefik.port=80\n    <span class=\"token key atrule\">networks</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> internal\n      <span class=\"token punctuation\">-</span> web\n    <span class=\"token key atrule\">depends_on</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> mysql<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>The <code>environment</code> key lets you specify environment variables that will be set inside of the container. By not setting a value for <code>WORDPRESS_DB_PASSWORD</code>, you’re telling Docker Compose to get the value from your shell and pass it through when you create the container. You will define this environment variable in your shell before starting the containers. This way you don’t hard-code passwords into the configuration file.</p>\n<p>The <code>labels</code> section is where you specify configuration values for Traefik. Docker labels don’t do anything by themselves, but Traefik reads these so it knows how to treat containers. Here’s what each of these labels does:</p>\n<ul>\n<li><code>traefik.http.routers.adminer.rule=Host(`````blog.your_domain`````)</code> creates a new <em>router</em> for your container and then specifies the routing rule used to determine if a request matches this container.</li>\n<li><code>traefik.routers.custom_name.tls=true</code> specifies that this router should use TLS.</li>\n<li><code>traefik.routers.custom_name.tls.certResolver=lets-encrypt</code> specifies that the certificates resolver that you created earlier called <code>lets-encrypt</code> should be used to get a certificate for this route.</li>\n<li><code>traefik.port</code> specifies the exposed port that Traefik should use to route traffic to this container.</li>\n</ul>\n<p>With this configuration, all traffic sent to your Docker host on port <code>80</code> or <code>443</code> with the domain of <code>blog.your_domain</code> will be routed to the <code>blog</code> container.</p>\n<p>You assign this container to two different networks so that Traefik can find it via the <code>web</code> network and it can communicate with the database container through the <code>internal</code> network.</p>\n<p>Lastly, the <code>depends_on</code> key tells Docker Compose that this container needs to start <em>after</em> its dependencies are running. Since WordPress needs a database to run, you must run your <code>mysql</code> container before starting your <code>blog</code> container.</p>\n<p>Next, configure the MySQL service:</p>\n<p>docker-compose.yml</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n<span class=\"token punctuation\">...</span>\n  <span class=\"token key atrule\">mysql</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> mysql<span class=\"token punctuation\">:</span><span class=\"token number\">5.7</span>\n    <span class=\"token key atrule\">environment</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">MYSQL_ROOT_PASSWORD</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">networks</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> internal\n    <span class=\"token key atrule\">labels</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> traefik.enable=false<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>You’re using the official MySQL 5.7 image for this container. You’ll notice that you’re once again using an <code>environment</code> item without a value. The <code>MYSQL_ROOT_PASSWORD</code> and <code>WORDPRESS_DB_PASSWORD</code> variables will need to be set to the same value to make sure that your WordPress container can communicate with the MySQL. You don’t want to expose the <code>mysql</code> container to Traefik or the outside world, so you’re only assigning this container to the <code>internal</code> network. Since Traefik has access to the Docker socket, the process will still expose a router for the <code>mysql</code> container by default, so you’ll add the label <code>traefik.enable=false</code> to specify that Traefik should not expose this container.</p>\n<p>Finally, define the Adminer container:</p>\n<p>docker-compose.yml</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n<span class=\"token punctuation\">...</span>\n  <span class=\"token key atrule\">adminer</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> adminer<span class=\"token punctuation\">:</span>4.6.3<span class=\"token punctuation\">-</span>standalone\n    <span class=\"token key atrule\">labels</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> traefik.http.routers.adminer.rule=Host(`db<span class=\"token punctuation\">-</span>admin.your_domain`)\n      <span class=\"token punctuation\">-</span> traefik.http.routers.adminer.tls=true\n      <span class=\"token punctuation\">-</span> traefik.http.routers.adminer.tls.certresolver=lets<span class=\"token punctuation\">-</span>encrypt\n      <span class=\"token punctuation\">-</span> traefik.port=8080\n    <span class=\"token key atrule\">networks</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> internal\n      <span class=\"token punctuation\">-</span> web\n    <span class=\"token key atrule\">depends_on</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> mysql<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>This container is based on the official Adminer image. The <code>network</code> and <code>depends_on</code> configuration for this container exactly match what you’re using for the <code>blog</code> container.</p>\n<p>The line <code>traefik.http.routers.adminer.rule=Host(`````db-admin.your_domain`````)</code> tells Traefik to examine the host requested. If it matches the pattern of <code>db-admin.your_domain</code>, Traefik will route the traffic to the <code>adminer</code> container over port <code>8080</code>.</p>\n<p>Your completed <code>docker-compose.yml</code> file will look like this:</p>\n<p>docker-compose.yml</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">version</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"3\"</span>\n\n<span class=\"token key atrule\">networks</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">web</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">external</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n  <span class=\"token key atrule\">internal</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">external</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">false</span>\n\n<span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">blog</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> wordpress<span class=\"token punctuation\">:</span>4.9.8<span class=\"token punctuation\">-</span>apache\n    <span class=\"token key atrule\">environment</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">WORDPRESS_DB_PASSWORD</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">labels</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> traefik.http.routers.blog.rule=Host(`blog.your_domain`)\n      <span class=\"token punctuation\">-</span> traefik.http.routers.blog.tls=true\n      <span class=\"token punctuation\">-</span> traefik.http.routers.blog.tls.certresolver=lets<span class=\"token punctuation\">-</span>encrypt\n      <span class=\"token punctuation\">-</span> traefik.port=80\n    <span class=\"token key atrule\">networks</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> internal\n      <span class=\"token punctuation\">-</span> web\n    <span class=\"token key atrule\">depends_on</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> mysql\n\n  <span class=\"token key atrule\">mysql</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> mysql<span class=\"token punctuation\">:</span><span class=\"token number\">5.7</span>\n    <span class=\"token key atrule\">environment</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">MYSQL_ROOT_PASSWORD</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">networks</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> internal\n    <span class=\"token key atrule\">labels</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> traefik.enable=false\n\n  <span class=\"token key atrule\">adminer</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> adminer<span class=\"token punctuation\">:</span>4.6.3<span class=\"token punctuation\">-</span>standalone\n    <span class=\"token key atrule\">labels</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">labels</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> traefik.http.routers.adminer.rule=Host(`db<span class=\"token punctuation\">-</span>admin.your_domain`)\n      <span class=\"token punctuation\">-</span> traefik.http.routers.adminer.tls=true\n      <span class=\"token punctuation\">-</span> traefik.http.routers.adminer.tls.certresolver=lets<span class=\"token punctuation\">-</span>encrypt\n      <span class=\"token punctuation\">-</span> traefik.port=8080\n    <span class=\"token key atrule\">networks</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> internal\n      <span class=\"token punctuation\">-</span> web\n    <span class=\"token key atrule\">depends_on</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> mysql<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>Save the file and exit the text editor.</p>\n<p>Next, set values in your shell for the <code>WORDPRESS_DB_PASSWORD</code> and <code>MYSQL_ROOT_PASSWORD</code> variables:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">WORDPRESS_DB_PASSWORD</span><span class=\"token operator\">=</span>secure_database_password\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">MYSQL_ROOT_PASSWORD</span><span class=\"token operator\">=</span>secure_database_password<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>Substitute <code>secure_database_password</code> with your desired database password. Remember to use the same password for both <code>WORDPRESS_DB_PASSWORD</code> and <code>MYSQL_ROOT_PASSWORD</code>.</p>\n<p>With these variables set, run the containers using <code>docker-compose</code>:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">docker-compose</span> up -d<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>Now watch the Traefik admin dashboard while it populates.</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/10/1420211014200110.png\" alt=\"Populated Traefik dashboard\"></p>\n<p>If you explore the <strong>Routers</strong> section you will find routers for <code>adminer</code> and <code>blog</code> configured with TLS:</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/10/1420211014200142.png\" alt=\"HTTP Routers w/ TLS\"></p>\n<p>Navigate to <code>blog.your_domain</code>, substituting <code>your_domain</code> with your domain. You’ll be redirected to a TLS connection and you can now complete the WordPress setup:</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/10/1420211014200114.png\" alt=\"WordPress setup screen\"></p>\n<p>Now access Adminer by visiting <code>db-admin.your_domain</code> in your browser, again substituting <code>your_domain</code> with your domain. The <code>mysql</code> container isn’t exposed to the outside world, but the <code>adminer</code> container has access to it through the <code>internal</code> Docker network that they share using the <code>mysql</code> container name as a hostname.</p>\n<p>On the Adminer login screen, enter <code>root</code> for <strong>Username</strong>, enter <code>mysql</code> for <strong>Server</strong>, and enter the value you set for <code>MYSQL_ROOT_PASSWORD</code> for the <strong>Password</strong>. Leave <strong>Database</strong> empty. Now press <strong>Login</strong>.</p>\n<p>Once logged in, you’ll see the Adminer user interface.</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/10/1420211014200132.png\" alt=\"Adminer connected to the MySQL database\"></p>\n<p>Both sites are now working, and you can use the dashboard at <code>monitor.your_domain</code> to keep an eye on your applications.</p>\n<h2 id=\"Conclusion\">Conclusion</h2>\n<p>In this tutorial, you configured Traefik v2 to proxy requests to other applications in Docker containers.</p>\n<p>Traefik’s declarative configuration at the application container level makes it easy to configure more services, and there’s no need to restart the <code>traefik</code> container when you add new applications to proxy traffic to since Traefik notices the changes immediately through the Docker socket file it’s monitoring.</p>\n<p>To learn more about what you can do with Traefik v2, head over to <a target=\"_blank\" rel=\"noopener\" href=\"https://doc.traefik.io/traefik/\">the official Traefik documentation</a>.</p>\n<h2 id=\"服务集群\">服务集群</h2>\n<blockquote>\n<p>k8s 太重了,虽然也有 k3s 之类的轻量级 k8s 解决方案，不过我还是选择了原生的 docker swarm。VPS 安装好 Docker 之后，不需要额外安装软件，就可以马上建立集群。</p>\n</blockquote>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 集群初始化，节点成为 manager 节点</span>\n<span class=\"token function\">docker</span> swarm init --advertise-addr<span class=\"token operator\">=</span>x.x.x.x\n\n<span class=\"token comment\"># 集群丢失 Leader 时，强制重建集群</span>\n<span class=\"token function\">docker</span> swarm init --advertise-addr<span class=\"token operator\">=</span>x.x.x.x --force-new-cluster\n\n<span class=\"token comment\"># 获取作为 worker 节点加入集群的命令</span>\n<span class=\"token function\">docker</span> swarm join-token worker\n\n<span class=\"token comment\"># 获取作为 manager 节点加入集群的命令</span>\n<span class=\"token function\">docker</span> swarm join-token manager\n\n<span class=\"token comment\"># 加入集群</span>\n<span class=\"token function\">docker</span> swarm <span class=\"token function\">join</span> --token xxx x.x.x.x:xxx --advertise-addr<span class=\"token operator\">=</span>x.x.x.x\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"参考：-2\">参考：</h2>\n<ul>\n<li><a target=\"_blank\" rel=\"noopener\" href=\"https://www.digitalocean.com/community/tutorials/how-to-use-traefik-v2-as-a-reverse-proxy-for-docker-containers-on-ubuntu-20-04\">digitalocean</a></li>\n<li><a target=\"_blank\" rel=\"noopener\" href=\"https://shanyue.tech/op/traefik.html\">shanyue</a></li>\n</ul>\n<h2 id=\"系列教程-8\"><strong>系列教程</strong></h2>\n<p><a href=\"https://blog.17lai.site/atom.xml\">全部文章RSS订阅</a></p>\n<p><strong>Docker系列</strong> <a href=\"https://blog.17lai.site/categories/docker/atom.xml\"><strong>Docker 分类 RSS 订阅</strong></a></p>\n<ul>\n<li><a href=\"https://blog.17lai.site/posts/42b6a86d/\">Docker使用简明教程</a></li>\n<li><a href=\"https://blog.17lai.site/posts/9912bd5d/\">使用jeckett,sonarr,iyuu,qt,emby打造全自动追剧流程</a></li>\n<li><a href=\"https://blog.17lai.site/posts/1802a8a7/\">为知笔记私有化Docker部署</a></li>\n<li><a href=\"https://blog.17lai.site/posts/593cc323/\">Earthly 一个更加强大的镜像构建工具</a></li>\n<li><a href=\"https://blog.17lai.site/posts/90e60aac/\">使用 Shell 脚本实现一个简单 Docker</a></li>\n<li><a href=\"https://blog.17lai.site/posts/465d2738/\">如何使用Traefik V2 在Ubuntu20.04 上面来做 Dockers</a></li>\n<li><a href=\"https://blog.17lai.site/posts/462f1e5c/\">通过IPV6访问Qnap NAS中Docker的服务</a></li>\n</ul>\n<link rel=\"stylesheet\" href=\"/css/bilicard.css\" type=\"text/css\">",
            "tags": [
                "docker",
                "traefik",
                "proxy",
                "swarm",
                "ubuntu"
            ]
        },
        {
            "id": "https://blog.17lai.site/posts/462f1e5c/",
            "url": "https://blog.17lai.site/posts/462f1e5c/",
            "title": "通过IPV6访问Qnap NAS中Docker的服务",
            "date_published": "2021-10-12T05:42:55.000Z",
            "content_html": "<h2 id=\"环境\">环境</h2>\n<p>系统：QTS 4.3.6<br>\n网络：IPV4 &amp; IPV6<br>\nDocker: 由Container Station提供</p>\n<h2 id=\"问题-2\">问题</h2>\n<p>通过ipv6地址可以打开NAS的管理页面，但是无法访问Docker对应端口的服务。</p>\n<h2 id=\"排查\">排查</h2>\n<p>QTS中Docker使用的虚拟交换机网络没有启动IPV6，且无法在虚拟交换机设置中手动启动。<br>\n这样一来，Docker只监听了tcp4的端口，对于主机上tcp6的端口的访问无法映射到docker容器上。</p>\n<h2 id=\"解决方案-2\">解决方案</h2>\n<p>在主机上开一个tcp6的端口，将其转发到主机上与docker关联的tcp4端口。<br>\n即：<br>\ndocker(tcp4)–&gt;host(tcp4)–&gt;host(tcp6)</p>\n<ul>\n<li>在qts上安装包管理器：Entware. https://github.com/Entware/Entware/wiki/Install-on-QNAP-NAS</li>\n<li>执行opkg update,更新</li>\n<li>安装端口转发工具，这里使用socat：opkg install socat</li>\n<li>设置转发host(tcp6)–&gt;host(tcp4):(socat TCP6-LISTEN:6880,reuseaddr,fork TCP4:127.0.0.1:7880 &amp;)</li>\n<li>大功告成</li>\n</ul>\n<h2 id=\"系列教程-7\"><strong>系列教程</strong></h2>\n<p><a href=\"https://blog.17lai.site/atom.xml\">全部文章RSS订阅</a></p>\n<p><strong>Docker系列</strong> <a href=\"https://blog.17lai.site/categories/docker/atom.xml\"><strong>Docker 分类 RSS 订阅</strong></a></p>\n<ul>\n<li><a href=\"https://blog.17lai.site/posts/42b6a86d/\">Docker使用简明教程</a></li>\n<li><a href=\"https://blog.17lai.site/posts/9912bd5d/\">使用jeckett,sonarr,iyuu,qt,emby打造全自动追剧流程</a></li>\n<li><a href=\"https://blog.17lai.site/posts/1802a8a7/\">为知笔记私有化Docker部署</a></li>\n<li><a href=\"https://blog.17lai.site/posts/593cc323/\">Earthly 一个更加强大的镜像构建工具</a></li>\n<li><a href=\"https://blog.17lai.site/posts/90e60aac/\">使用 Shell 脚本实现一个简单 Docker</a></li>\n<li><a href=\"https://blog.17lai.site/posts/465d2738/\">如何使用Traefik V2 在Ubuntu20.04 上面来做 Dockers</a></li>\n<li><a href=\"https://blog.17lai.site/posts/462f1e5c/\">通过IPV6访问Qnap NAS中Docker的服务</a></li>\n</ul>\n<link rel=\"stylesheet\" href=\"/css/bilicard.css\" type=\"text/css\">",
            "tags": [
                "qnap",
                "nas",
                "docker",
                "ipv6"
            ]
        },
        {
            "id": "https://blog.17lai.site/posts/1802a8a7/",
            "url": "https://blog.17lai.site/posts/1802a8a7/",
            "title": "为知笔记私有化Docker部署",
            "date_published": "2021-09-09T01:25:00.000Z",
            "content_html": "<blockquote>\n<p>已经不建议使用！</p>\n<ul>\n<li>\n<p>格式私有，不支持导出数据到其它类型笔记软件。数据进入后，基本只能用为知笔记编辑了，导出图片和<code>PDF</code>? <code>what?</code></p>\n</li>\n<li>\n<p>收费吃相难看，VIP到期后，功能限制严重！</p>\n</li>\n<li>\n<p>不推荐任何不支持导入导出数据的笔记软件。推荐使用开放格式的 Joplin 软件</p>\n</li>\n</ul>\n</blockquote>\n<p>登陆NAS，打开套件中心，搜索docker，并安装。</p>\n<p>搜索wiznote，找到wiznote/wizserver，双击下载</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/09/0920210909114640.png\" alt=\"\"></p>\n<p>在NAS中创建共享目录，用于存放笔记数据</p>\n<ol>\n<li>\n<p>启动File Station</p>\n</li>\n<li>\n<p>在docker目录下创建文件夹：</p>\n<p>wiz</p>\n</li>\n<li>\n<p>在wiz文件夹下创建文件夹：data</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/09/0920210909114704.png\" alt=\"\"></p>\n</li>\n<li>\n<p>双击创建容器，启用资源限制，设置为内存限制4096MB，官方介绍说需要4G内存</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/09/0920210909114710.jpeg\" alt=\"\"></p>\n</li>\n<li>\n<p>高级设置，启动自动重新启动</p>\n</li>\n<li>\n<p>卷设置，使用刚才我们创建的data目录进行配置，装载路径<code>/wiz/storage</code>，<code>docker/wiz/config</code>装载路径<code>/wiz/app/wizserver/config</code></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/09/0920210909114724.png\" alt=\"\"></p>\n</li>\n<li>\n<p>网络设置不动，端口设置添加映射：8888映射80端口（8888可以随便设置，跟访问地址有关）</p>\n</li>\n</ol>\n<p><img src=\"https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/09/0920210909114731.png\" alt=\"\"></p>\n<ol start=\"8\">\n<li>\n<p>设置环境变量</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/09/0920210909114732.png\" alt=\"\"></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token assign-left variable\">SEARCH</span><span class=\"token operator\">=</span>true <span class=\"token assign-left variable\">TZ</span><span class=\"token operator\">=</span>Asia/Shanghai<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n</li>\n<li>\n<p>直接应用，启动docker，然后就静静的等待吧，可以看看镜像的日志，看到这些基本上就差不多启动好了（最新的镜像在NAS上首次启动非常慢，本人等了一个多小时才完全启动完毕，在本地安装速度非常快）<img src=\"https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/09/0920210909114738.jpeg\" alt=\"\"></p>\n</li>\n<li>\n<p>通过 <code>http://NAS的IP:8888</code>，进行访问，就可以看到已经启动完成</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/09/0920210909114744.jpeg\" alt=\"为知笔记启动界面\"></p>\n</li>\n</ol>\n<blockquote>\n<p>默认管理员账号：admin@wiz.cn，密码：123456</p>\n<p>管理后台登陆地址：http://IP地址:端口/wapp/pages/admin</p>\n</blockquote>\n<h2 id=\"NAS开启SSH\">NAS开启SSH</h2>\n<p>首先在NAS上启动SSH</p>\n<p>登陆NAS，打开<code>控制面板-终端机和SNMP</code>，在<code>启动SSH功能</code>前打上勾</p>\n<p>打开命令行，输入</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">ssh</span> NAS管理员账号@NAS的IP地址 ssh端口号默认是22<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>看到提示符，输入账号的密码，输入时不可见，输入完成按回车，看到命令行提示符变了，登陆成功。</p>\n<h2 id=\"进入容器\">进入容器</h2>\n<p>在命令行中输入</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> <span class=\"token function\">ps</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>可能提示输入密码，就输入NAS管理员的密码即可，显示列表，查看到如下列表，找到其中运行了为知笔记的一行</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/09/0920210909114805.png\" alt=\"\"></p>\n<p>复制为知笔记的<code>CONTAINER ID</code>，然后再输入如下命令并回车：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">docker</span> <span class=\"token builtin class-name\">exec</span> -it 粘贴刚复制好的ID号 /bin/bash<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>至此进入到容器中</p>\n<h2 id=\"修改配置文件\">修改配置文件</h2>\n<p>输入如下命令打开配置文件进行编辑：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">vi</span> /wiz/app/wizserver/config/default.json<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>vi命令的具体使用方法请自行百度，保存好后退出，重启容器生效。</p>\n<p>进入docker，修改文件/wiz/wizserver/app/config/default.json</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\"><span class=\"token property\">\"as\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n     <span class=\"token property\">\"admin\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"admin@wiz.cn\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n     <span class=\"token property\">\"share\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n       <span class=\"token property\">\"admin\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"admin@wiz.cn\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n       <span class=\"token property\">\"enableHttps\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>\n       <span class=\"token property\">\"enableSubDomain\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>\n       <span class=\"token property\">\"appShareUrl\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"127.0.0.1:5001\"</span>\n     <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>其中<code>127.0.0.1:5001</code>修改为自己的服务器访问地址，可以给docker做个端口映射（因为群晖NAS占用了5001端口），譬如映射8889端口到容器的5001端口，则设置为<code>xxx.xxx.xxx.xxx:8889</code>，分享后的链接即为该链接。</p>\n<p>在NAS上可以用反向代理来解决二级域名的问题。</p>\n<p>分享功能需要用户绑定手机，并完成认证，在docker中登陆数据库，并修改数据</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">mysql <span class=\"token operator\">-</span>u root <span class=\"token operator\">-</span>p<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>输入密码，密码在docker中<code>/wiz/wizserver/app/config/default.json</code>中查看</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\"><span class=\"token property\">\"mysql\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"as\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token property\">\"host\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"127.0.0.1\"</span><span class=\"token punctuation\">,</span>\n   <span class=\"token property\">\"user\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"root\"</span><span class=\"token punctuation\">,</span>\n   <span class=\"token property\">\"password\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"******************\"</span><span class=\"token punctuation\">,</span>\n   <span class=\"token property\">\"database\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"wizasent\"</span><span class=\"token punctuation\">,</span>\n   <span class=\"token property\">\"connectionLimit\"</span><span class=\"token operator\">:</span> <span class=\"token number\">50</span><span class=\"token punctuation\">,</span>\n   <span class=\"token property\">\"connectTimeout\"</span><span class=\"token operator\">:</span> <span class=\"token number\">60000</span><span class=\"token punctuation\">,</span>\n   <span class=\"token property\">\"aquireTimeout\"</span><span class=\"token operator\">:</span> <span class=\"token number\">60000</span><span class=\"token punctuation\">,</span>\n   <span class=\"token property\">\"waitForConnections\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>其中<code>password</code>就是密码，进入mysql控制台后，执行以下命令：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">use</span> wizasent<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">update</span> wiz_user <span class=\"token keyword\">set</span> MOBILE<span class=\"token operator\">=</span><span class=\"token string\">'你的手机号'</span><span class=\"token punctuation\">,</span> MOBILE_VERIFY<span class=\"token operator\">=</span><span class=\"token string\">'1'</span> <span class=\"token keyword\">where</span> ID<span class=\"token operator\">=</span><span class=\"token string\">'1'</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>web端登陆为知笔记，并修改默认账号后，修改后的账号无法登陆管理后台，需要做以下配置，修改文件<code>/wiz/wizserver/app/config/default.json</code>，找到以下代码：</p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\"><span class=\"token property\">\"as\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"admin\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"admin@wiz.cn\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"share\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"admin\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"admin@wiz.cn\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"enableHttps\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"enableSubDomain\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"appShareUrl\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"127.0.0.1:5001\"</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>其中<code>admin@wiz.cn</code>修改为修改后的账号。</p>\n<p>登陆NAS，打开<code>控制面板-应用程序门户-反向代理</code></p>\n<p>点击新增，然后输入如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/09/0920210909114813.png\" alt=\"\"></p>\n<p>实际测试来源协议选择https时只有网页端可以登陆，客户端无法登陆，暂时还是选择http为好，也可以网页端通过https登陆，客户端通过http登陆，配置两个不同的端口（记得要在路由上配置端口映射）。</p>\n<p>修改<code>default.json</code></p>\n<pre class=\"line-numbers language-json\" data-language=\"json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"debug\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"enableHttps\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"storage\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n     <span class=\"token property\">\"__comments\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"oss|local|s3|cos\"</span><span class=\"token punctuation\">,</span>\n     <span class=\"token property\">\"use\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"local\"</span><span class=\"token punctuation\">,</span>\n     <span class=\"token property\">\"oss\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n       <span class=\"token property\">\"bucket\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"data_root\"</span><span class=\"token punctuation\">,</span>\n       <span class=\"token property\">\"region\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"test\"</span><span class=\"token punctuation\">,</span>\n       <span class=\"token property\">\"accessKeyId\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"test\"</span><span class=\"token punctuation\">,</span>\n       <span class=\"token property\">\"accessKeySecret\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"test\"</span><span class=\"token punctuation\">,</span>\n       <span class=\"token property\">\"internal\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span>\n     <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>其中<code>enableHttps</code>配置成<code>true</code></p>\n<p>重启服务</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">cd</span> /wiz/app/wizserver\npm2 restart all<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>删除<code>/wiz/storage/index/.search</code>文件和<code>/wiz/storage/index/nodes</code>目录</p>\n<p>重启容器</p>\n<p>链接数据库，执行下列SQL</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\"><span class=\"token keyword\">update</span> wizksent<span class=\"token punctuation\">.</span>wiz_kb_stat <span class=\"token keyword\">set</span> index_new_status<span class=\"token operator\">=</span><span class=\"token number\">4</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>进入容器，执行</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">cd</span> /wiz/app/wizserver\npm2 start app.js --name<span class=\"token operator\">=</span><span class=\"token string\">\"index2\"</span>  -f -- -c <span class=\"token number\">1</span> -i <span class=\"token number\">1</span> -t <span class=\"token number\">2</span> -s index\npm2 start app.js --name<span class=\"token operator\">=</span><span class=\"token string\">\"index2\"</span>  -f --  -s copy<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>查看日志</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">pm2 logs index2<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>下载官方插件，并安装到Chrome中</p>\n<p>http://www.wiz.cn/downloads-webclipperchrome.html</p>\n<p>在浏览器中输入<code>chrome://extensions/</code>打开插件列表，开启开发者模式</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/09/0920210909114820.png\" alt=\"\"></p>\n<p>看ID号，在浏览器中输入<code>chrome://inspect/#extensions</code>在打开的列表中找到<code>WizClipper</code>，点击<code>inspect</code>，开启调试窗口。</p>\n<p>选择<code>Sources</code>标签，并打开文件<code>Scripts\\wiz\\WizConstant.js</code></p>\n<p>在代码中查看<code>note.wiz.cn</code>和<code>api.wiz.cn</code>的网址全部替换成自己私有云的地址，实测，登陆没问题，保存失败。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2021/09/0920210909114826.jpeg\" alt=\"\"></p>\n<h2 id=\"管理功能\">管理功能</h2>\n<ol>\n<li>\n<p>增加重建索引功能，以备不时之需</p>\n</li>\n<li>\n<p>增加备份与恢复功能</p>\n</li>\n<li>\n<p>增加markdown语法扩展：</p>\n<p>flow（流程图）、sequence（时序图）、mermaid（流程图、时序图、甘特图）、LaTeX（公式）</p>\n</li>\n<li>\n<p>增加手动配置分享链接</p>\n</li>\n<li>\n<p>支持社交绑定的配置</p>\n</li>\n<li>\n<p>支持对象存储或webdav存储</p>\n</li>\n</ol>\n<h2 id=\"Web-Mac客户端\">Web&amp;Mac客户端</h2>\n<ol>\n<li>\n<p>增加自定义模板</p>\n</li>\n<li>\n<p>增加偏好设置，自定义快捷键（主要是编辑和预览切换的快捷键非常不适应）</p>\n</li>\n<li>\n<p>增加同步预览模式，可以参考下Typora，Bear都不错</p>\n</li>\n<li>\n<p>增加https访问方式</p>\n</li>\n<li>\n<p>支持导出jpg、png、docx格式</p>\n</li>\n</ol>\n<h2 id=\"浏览器插件\">浏览器插件</h2>\n<ol>\n<li>增加支持私有云登陆</li>\n</ol>\n<p>【部署环境】<br>\n群晖DS1517+（DSM6.2.2）<br>\n容器分配内存4G，CPU*2核</p>\n<p>【出现的问题】</p>\n<ol>\n<li>\n<p>网页版上提示，自动保存失败，网络错误，请尽快保存（最后发现是时区不通道导致的，第8点解决了此问题）</p>\n</li>\n<li>\n<p>所有社交平台账号无法绑定</p>\n</li>\n<li>\n<p>mywiz邮箱不可修改</p>\n</li>\n<li>\n<p>绑定手机无法收到验证码，即无法绑定手机（通过修改数据库搞定）</p>\n</li>\n<li>\n<p>存储设置功能多余（因为已经本地化部署了），改成数据备份/恢复就好了</p>\n</li>\n<li>\n<p>支付信息是支付到为知去的，这个功能容易产生误解（如果多人使用的话）</p>\n</li>\n<li>\n<p>docker容器的时区与宿主机时区不同，添加环境变量解决，TZ=Asia/Shanghai</p>\n</li>\n</ol>\n<h2 id=\"数据导出\">数据导出</h2>\n<blockquote>\n<p>方法很困难。</p>\n</blockquote>\n<h3 id=\"ExportToMd\"><a target=\"_blank\" rel=\"noopener\" href=\"https://github.com/lzuliuyun/ExportToMd\">ExportToMd</a></h3>\n<blockquote>\n<p>最新版Wiznote测试这个插件已经不可用了。</p>\n</blockquote>\n<h3 id=\"WizNotePlus\"><strong><a target=\"_blank\" rel=\"noopener\" href=\"https://github.com/altairwei/WizNotePlus\">WizNotePlus</a></strong></h3>\n<blockquote>\n<p>第三方客户端导出，作者正在开发中，讲如下链接。</p>\n<p>https://github.com/altairwei/WizNotePlus/issues/182</p>\n</blockquote>\n<h3 id=\"Memocast客户端\">Memocast客户端</h3>\n<p>随后搜索到<a target=\"_blank\" rel=\"noopener\" href=\"https://github.com/TankNee/Memocast\">Memocast</a>，是重写为知笔记的客户端。</p>\n<h3 id=\"使用OpenAPI\">使用OpenAPI</h3>\n<p>为知笔记提供了<code>OpenAPI</code>来查看和编辑笔记，Memocast也是类似方式，<a target=\"_blank\" rel=\"noopener\" href=\"https://www.wiz.cn/wapp/pages/book/bb8f0f10-48ca-11ea-b27a-ef51fb9d4bb4/700c0ba0-48cb-11ea-a61a-d3d58d67def9\">服务说明及登录</a>和<a target=\"_blank\" rel=\"noopener\" href=\"https://www.wiz.cn/wapp/pages/book/bb8f0f10-48ca-11ea-b27a-ef51fb9d4bb4/475c9ef0-4e1a-11ea-8f5c-a7618da01da2\">笔记接口</a>介绍了如何登录获取Token，如何查询文件夹文档，下载html，下载资源(图片)等接口。</p>\n<blockquote>\n<p>对于为知笔记来说，所有的笔记保存为html，所以下载后需要做转换。</p>\n</blockquote>\n<p>通过<code>Postman</code>的接口测试发现完全可行，那么就可以编程导出了。具体的<a target=\"_blank\" rel=\"noopener\" href=\"https://github.com/GalaIO/wiz_export\">代码</a>。html转md的库使用<a target=\"_blank\" rel=\"noopener\" href=\"https://github.com/JohannesKaufmann/html-to-markdown\">html-to-markdown</a>，案例代码<a target=\"_blank\" rel=\"noopener\" href=\"https://github.com/JohannesKaufmann/html-to-markdown/blob/master/examples/github_flavored/main.go\">在这</a>。</p>\n<p>如何使用？按照下面提示输入账户和密码，然后设置导出的文件夹即可。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">go <span class=\"token function\">install</span> github.com/GalaIO/wiz_export@latest\nwiz_export --output <span class=\"token string\">'./'</span> --userId <span class=\"token string\">'xx'</span> --password <span class=\"token string\">'xx'</span> --folders <span class=\"token string\">'/日记/,/工作/'</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"借助Pandoc转换到HTML再转换到Markdown\">借助Pandoc转换到HTML再转换到Markdown</h3>\n<p>For .html files within a directory</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">for f in *.html ; do pandoc ${f} -f html -t markdown -s -o ${f}.md ; done<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>or</p>\n<p>For recursive directory conversion with subfolders</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">find . -name \"*.ht*\" | while read i; do pandoc -f html -t markdown \"$i\" -o \"${i%.*}.md\"; done<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"wiz2joplin\"><a target=\"_blank\" rel=\"noopener\" href=\"https://github.com/zrong/wiz2joplin\">wiz2joplin</a></h3>\n<p>这个需要Mac环境，看提交记录时间，可行性很高。</p>\n<p>参考：</p>\n<ul>\n<li><a target=\"_blank\" rel=\"noopener\" href=\"https://mp.weixin.qq.com/s/JQBUqdq1YNsGqolQ0jjfNg\">大大木头 [为知社区]</a></li>\n<li><a target=\"_blank\" rel=\"noopener\" href=\"https://zhuanlan.zhihu.com/p/488613809\">如何导出为知笔记？</a></li>\n<li><a target=\"_blank\" rel=\"noopener\" href=\"https://discourse.joplinapp.org/t/importing-notes-from-other-notebook-applications/22425\">Importing notes from other notebook applications</a></li>\n</ul>\n<h2 id=\"系列教程-35\"><strong>系列教程</strong></h2>\n<p><a href=\"https://blog.17lai.site/atom.xml\">全部文章RSS订阅</a></p>\n<p><strong>Docker系列</strong> <a href=\"https://blog.17lai.site/categories/docker/atom.xml\"><strong>Docker 分类 RSS 订阅</strong></a></p>\n<ul>\n<li><a href=\"https://blog.17lai.site/posts/42b6a86d/\">Docker使用简明教程</a></li>\n<li><a href=\"https://blog.17lai.site/posts/9912bd5d/\">使用jeckett,sonarr,iyuu,qt,emby打造全自动追剧流程</a></li>\n<li><a href=\"https://blog.17lai.site/posts/1802a8a7/\">为知笔记私有化Docker部署</a></li>\n<li><a href=\"https://blog.17lai.site/posts/593cc323/\">Earthly 一个更加强大的镜像构建工具</a></li>\n<li><a href=\"https://blog.17lai.site/posts/90e60aac/\">使用 Shell 脚本实现一个简单 Docker</a></li>\n<li><a href=\"https://blog.17lai.site/posts/465d2738/\">如何使用Traefik V2 在Ubuntu20.04 上面来做 Dockers</a></li>\n<li><a href=\"https://blog.17lai.site/posts/462f1e5c/\">通过IPV6访问Qnap NAS中Docker的服务</a></li>\n</ul>\n<p><strong>笔记系列</strong>  <a href=\"https://blog.17lai.site/categories/note/atom.xml\"><strong>Note分类RSS订阅</strong></a></p>\n<ul>\n<li><a href=\"https://blog.17lai.site/posts/a8535f26/\">完美笔记进化论</a></li>\n</ul>\n<blockquote>\n<p>经历了很长时间，使用了各种各样的方案，最终选择了一种相对完美的方式。docker私有部署运行的joplin，使用markdown语法，github作为图床，picgo作为图像自动上传后端，pypora作为MD编辑器，Snipaste作为截图工具。后备gitlab ee selfhost备份，自建图床VPS多线负载均衡。cloudflare partner cdn加速，jsdelivr加速。</p>\n<ul>\n<li>pigo图床搭建与配置</li>\n<li>Joplin教程</li>\n<li>Snipaste截图工具</li>\n<li>Typora 作为Markdown编辑器最强</li>\n</ul>\n</blockquote>\n<ul>\n<li><a target=\"_blank\" rel=\"noopener\" href=\"https://blog.17lai.fun/posts/e6086437/\">Joplin入门指南&amp;实践方案</a></li>\n</ul>\n<blockquote>\n<ul>\n<li>Joplin和使用</li>\n<li>Joplin同步与备份</li>\n<li>Joplin导入与导出</li>\n</ul>\n</blockquote>\n<ul>\n<li><a target=\"_blank\" rel=\"noopener\" href=\"https://blog.17lai.fun/posts/45f878cd/\">替代Evernote免费开源笔记Joplin-网盘同步笔记历史版本Markdown可视化</a></li>\n</ul>\n<blockquote>\n<ul>\n<li>Joplin安装使用，调用外部编辑器，网盘同步等等</li>\n</ul>\n</blockquote>\n<ul>\n<li><a href=\"https://blog.17lai.site/posts/92d347d6/\">Joplin 插件以及其Markdown语法。All in One!</a></li>\n</ul>\n<blockquote>\n<ul>\n<li>Joplin简明教程</li>\n<li>markdown语法简明教程</li>\n</ul>\n</blockquote>\n<ul>\n<li><a href=\"https://blog.17lai.site/posts/e3ee7f8b/\">Joplin 插件使用推荐</a></li>\n</ul>\n<blockquote>\n<ul>\n<li>教你用各种插件打造一个强大的笔记工具。</li>\n</ul>\n</blockquote>\n<ul>\n<li><a href=\"https://blog.17lai.site/posts/1802a8a7/\">为知笔记私有化Docker部署</a></li>\n</ul>\n<blockquote>\n<ul>\n<li>如何部署自己私有的为知笔记。</li>\n<li>其实博主更推荐私有部署joplin</li>\n</ul>\n</blockquote>\n<p><strong>Gitbook使用系列</strong> <a href=\"https://blog.17lai.site/categories/gitbook/atom.xml\">Gitbook分类RSS订阅</a></p>\n<ul>\n<li>\n<p><a href=\"https://blog.17lai.site/posts/7fe86002/\">GitBook+GitLab撰写发布技术文档-Part1:GitBook篇</a></p>\n</li>\n<li>\n<p><a href=\"https://blog.17lai.site/posts/7790e989/\">GitBook+GitLab撰写发布技术文档-Part2:GitLab篇</a></p>\n</li>\n<li>\n<p><a href=\"https://blog.17lai.site/posts/d6bad1e5/\">自己动手制作电子书的最佳方式（支持PDF、ePub、mobi等格式）</a></p>\n</li>\n</ul>\n<p><strong>Gitlab 使用系列</strong>  <a href=\"https://blog.17lai.site/categories/gitlab/atom.xml\"><strong>Gitlab RSS 分类订阅</strong></a></p>\n<ul>\n<li><a href=\"https://blog.17lai.site/posts/acc13b70/\"><strong>Gitlab的安装及使用教程完全版</strong></a></li>\n<li><a href=\"https://blog.17lai.site/posts/29a820b3/\">破解Gitlab EE</a></li>\n<li><a href=\"https://blog.17lai.site/posts/d08eb7b/\">Gitlab的安装及使用</a></li>\n<li><a href=\"https://blog.17lai.site/posts/1879721e/\">CI/CD与Git Flow与GitLab</a></li>\n</ul>\n<p><strong>Hexo系列</strong>  <a href=\"https://blog.17lai.site/categories/hexo/atom.xml\"><strong>HexoRSS分类订阅</strong></a></p>\n<p>[三万字教程]基于Hexo的matery主题搭建博客并深度优化完全一站式教程</p>\n<ul>\n<li>\n<p><a href=\"https://blog.17lai.site/posts/40300608/\">Hexo Docker环境与Hexo基础配置篇</a></p>\n</li>\n<li>\n<p><a href=\"https://blog.17lai.site/posts/4d8a0b22/\">hexo博客自定义修改篇</a></p>\n</li>\n<li>\n<p><a href=\"https://blog.17lai.site/posts/9b056c86/\">hexo博客网络优化篇</a></p>\n</li>\n<li>\n<p><a href=\"https://blog.17lai.site/posts/5311b619/\">hexo博客增强部署篇</a></p>\n</li>\n<li>\n<p><a href=\"https://blog.17lai.site/posts/4a2050e2/\">hexo博客个性定制篇</a></p>\n</li>\n<li>\n<p><a href=\"https://blog.17lai.site/posts/84b4059a/\">hexo博客常见问题篇</a></p>\n</li>\n<li>\n<p><a href=\"https://blog.17lai.site/posts/cf0f47fd/\">Hexo Markdown以及各种插件功能测试</a></p>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>markdown 各种其它语法插件</li>\n<li>latex公式支持</li>\n<li>mermaid图表</li>\n<li>plant uml图表</li>\n<li>URL卡片</li>\n<li>bilibili卡片</li>\n<li>github卡片</li>\n<li>豆瓣卡片</li>\n<li>插入音乐和视频</li>\n<li>插入脑图</li>\n</ul>\n</blockquote>\n<link rel=\"stylesheet\" href=\"/css/bilicard.css\" type=\"text/css\">",
            "tags": [
                "linux",
                "nas",
                "wiz",
                "docker",
                "note"
            ]
        },
        {
            "id": "https://blog.17lai.site/posts/42b6a86d/",
            "url": "https://blog.17lai.site/posts/42b6a86d/",
            "title": "docker使用简明教程",
            "date_published": "2021-08-01T12:25:00.000Z",
            "content_html": "<p>关于docker安装，查看，镜像管理，以及一个实用Dockerfile， LAMP，PHP，LTMJ。</p>\n<ul>\n<li>关于本blog，<strong>图床</strong>一般使用<strong>github</strong>，已经配置了CDN，如果图片还是未显示请自行代理解决</li>\n</ul>\n<h2 id=\"一、Docker安装\">一、Docker安装</h2>\n<ul>\n<li>在Ubuntu系统下安装：</li>\n</ul>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\"><span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> <span class=\"token function\">docker</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<ul>\n<li>在Fedora/CentOS系统下安装：</li>\n</ul>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">yum <span class=\"token function\">install</span> <span class=\"token function\">docker</span>\ndnf <span class=\"token function\">install</span> <span class=\"token function\">docker</span> <span class=\"token comment\"># Fedora 25+</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<ul>\n<li>在SUSE系统下安装：</li>\n</ul>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\"><span class=\"token function\">zypper</span> <span class=\"token function\">install</span> <span class=\"token function\">docker</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h2 id=\"二、Docker容器\">二、Docker容器</h2>\n<ul>\n<li>首先启动Docker</li>\n</ul>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\"><span class=\"token comment\"># 启动Docker</span>\nsystemctl start <span class=\"token function\">docker</span>\n<span class=\"token comment\"># 设置开机自启动，可选</span>\nsystemctl <span class=\"token builtin class-name\">enable</span> <span class=\"token function\">docker</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>启动Docker测试容器</li>\n</ul>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\"><span class=\"token function\">docker</span> run <span class=\"token string\">\"hello-world\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<ul>\n<li>在启动容器时，如果使用的镜像在本地不存在，会尝试从网络上获取。</li>\n<li>在一般情况下，启动Web服务的容器，使用以下命令：</li>\n</ul>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\"><span class=\"token comment\"># -d：daemon，使容器在后台运行</span>\n<span class=\"token comment\"># -p：port，指定容器的端口，这里是将容器的80端口映射到主机的8001端口</span>\n<span class=\"token function\">docker</span> run -d -p <span class=\"token number\">8001</span>:80 <span class=\"token string\">\"image_name\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>查看容器运行情况</li>\n</ul>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\"><span class=\"token function\">docker</span> <span class=\"token function\">ps</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<ul>\n<li>Docker会为容器分配一个Container ID和一个Container Name，Name可以在运行时通过<code>-name</code>自行指定，这两个可以用来标识容器。</li>\n<li>需要停止容器时，使用以下命令：</li>\n</ul>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\"><span class=\"token function\">docker</span> stop <span class=\"token string\">\"container_name\"</span>\n<span class=\"token comment\"># 或使用ID查找</span>\n<span class=\"token function\">docker</span> stop <span class=\"token string\">\"container_id\"</span>\n<span class=\"token comment\"># 重启</span>\n<span class=\"token function\">docker</span> restart <span class=\"token string\">\"container_id\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"三、Docker镜像\">三、Docker镜像</h2>\n<h3 id=\"Dokerfile编译镜像\">Dokerfile编译镜像</h3>\n<ul>\n<li>Docker容器是运行的Docker镜像实例，一般情况下，我们需要制作自己的Docker镜像。</li>\n<li>Docker镜像的制作依赖于Dockerfile，我们稍后在讨论Dockerfile的编写，这里假定我们有一个编写好的Dockerfile。</li>\n<li>下面的命令将在当前路径查找Dockerfile并构建一个名为“image_name”的镜像。</li>\n</ul>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\"><span class=\"token function\">docker</span> build -t <span class=\"token string\">\"image_name\"</span> ./<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"查看本地所有镜像\">查看本地所有镜像</h3>\n<ul>\n<li>在构建过程中需要在网络上下载来源镜像，可能需要一段时间。</li>\n<li>如果Dockerfile中的命令都正确结束（Exit code 0），那么Docker镜像的构建也将顺利完成，我们可以通过下面的命令查看我们的所有镜像：</li>\n</ul>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\"><span class=\"token function\">docker</span> images<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"导出备份已有镜像文件\">导出备份已有镜像文件</h3>\n<ul>\n<li>我们还可以导出我们制作好的Docker镜像，下面的命令将image_name镜像导出为image_name.tar</li>\n</ul>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\"><span class=\"token function\">docker</span> save <span class=\"token string\">\"image_name\"</span> <span class=\"token operator\">&gt;</span> image_name.tar<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"导入已有镜像备份\">导入已有镜像备份</h3>\n<ul>\n<li>在另一台机器上，我们不需要网络就可以导入并使用该镜像：</li>\n</ul>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\"><span class=\"token function\">docker</span> load <span class=\"token operator\">&lt;</span> image_name.tar<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h2 id=\"四、Dockerfile\">四、Dockerfile</h2>\n<ul>\n<li>Dockerfile本质上是一组命令集合，用于自动化构建镜像，下面以几个实例来说明Dockerfile的编写方法：</li>\n</ul>\n<h3 id=\"实例一：LAMP（Linux-Apache-MySQL-PHP）环境配置\">实例一：LAMP（Linux+Apache+MySQL+PHP）环境配置</h3>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"><span class=\"token comment\"># 来源镜像，一般可以使用标准的系统或者带有各种环境的系统</span>\n<span class=\"token comment\"># 显然这里使用的是标准的Ubuntu 14.04系统</span>\nFROM ubuntu<span class=\"token punctuation\">:</span><span class=\"token number\">14.04</span>\n<span class=\"token comment\"># 镜像作者</span>\nMAINTAINER wrlu\n<span class=\"token comment\"># 刷新日期</span>\nENV REFRESHED_AT 2018<span class=\"token punctuation\">-</span>08<span class=\"token punctuation\">-</span><span class=\"token number\">05</span>\n<span class=\"token comment\"># 设定字符集</span>\nENV LANG C.UTF<span class=\"token punctuation\">-</span><span class=\"token number\">8</span>\n<span class=\"token comment\"># RUN命令用于执行系统命令</span>\n<span class=\"token comment\"># 因为需要自动化安装，所以最好通过-y命令跳过确认</span>\n<span class=\"token comment\"># 更新APT软件源</span>\nRUN apt<span class=\"token punctuation\">-</span>get update <span class=\"token punctuation\">-</span>y\n<span class=\"token comment\"># 安装MySQL</span>\nRUN apt<span class=\"token punctuation\">-</span>get <span class=\"token punctuation\">-</span>y install mysql<span class=\"token punctuation\">-</span>server\n<span class=\"token comment\"># 安装Apache</span>\nRUN apt<span class=\"token punctuation\">-</span>get <span class=\"token punctuation\">-</span>y install apache2\n<span class=\"token comment\"># 安装PHP5</span>\nRUN apt<span class=\"token punctuation\">-</span>get <span class=\"token punctuation\">-</span>y install php5 libapache2<span class=\"token punctuation\">-</span>mod<span class=\"token punctuation\">-</span>php5\nRUN apt<span class=\"token punctuation\">-</span>get install <span class=\"token punctuation\">-</span>yqq php5<span class=\"token punctuation\">-</span>mysql php5<span class=\"token punctuation\">-</span>curl php5<span class=\"token punctuation\">-</span>gd php5<span class=\"token punctuation\">-</span>intl php<span class=\"token punctuation\">-</span>pear php5<span class=\"token punctuation\">-</span>imagick php5<span class=\"token punctuation\">-</span>imap php5<span class=\"token punctuation\">-</span>mcrypt php5<span class=\"token punctuation\">-</span>memcache php5<span class=\"token punctuation\">-</span>ming php5<span class=\"token punctuation\">-</span>ps php5<span class=\"token punctuation\">-</span>pspell php5<span class=\"token punctuation\">-</span>recode php5<span class=\"token punctuation\">-</span>snmp php5<span class=\"token punctuation\">-</span>sqlite php5<span class=\"token punctuation\">-</span>tidy php5<span class=\"token punctuation\">-</span>xmlrpc php5<span class=\"token punctuation\">-</span>xsl\n<span class=\"token comment\"># 删除Apache2列出目录配置</span>\nRUN sed <span class=\"token punctuation\">-</span>i 's/Options Indexes FollowSymLinks/Options None/' /etc/apache2/apache2.conf\n<span class=\"token comment\"># COPY命令可以复制文件，但是似乎不能递归复制文件</span>\nCOPY IncludeAirline/* /var/www/html/\nCOPY IncludeAirline/airlines/* /var/www/html/airlines/\n<span class=\"token comment\"># 删除默认的主页</span>\nRUN rm /var/www/html/index.html\n<span class=\"token comment\"># 复制启动脚本</span>\nCOPY start.sh /root/start.sh\nRUN chmod +x /root/start.sh\n<span class=\"token comment\"># 设置启动目录以及启动脚本</span>\nENTRYPOINT cd /root; ./start.sh\n<span class=\"token comment\"># 设置需要暴露的端口</span>\nEXPOSE 80<span class=\"token punctuation\">,</span><span class=\"token number\">3306</span> <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>本例中还有一个启动脚本<code>start.sh</code>，用于导入数据库，编写如下：</li>\n</ul>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"><span class=\"token comment\">#!/bin/bash</span>\n<span class=\"token comment\"># 启动后延时</span>\nsleep 1\n<span class=\"token comment\"># 启动Apache服务器</span>\n/etc/init.d/apache2 start\n<span class=\"token comment\"># 启动MySQL数据库</span>\nfind /var/lib/mysql <span class=\"token punctuation\">-</span>type f <span class=\"token punctuation\">-</span>exec touch <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> ; <span class=\"token important\">&amp;&amp;</span> service mysql start\n<span class=\"token comment\"># 定义SQL文件路径</span>\nsqlfile=/var/www/html/includeAirline.sql\nif <span class=\"token punctuation\">[</span> <span class=\"token punctuation\">-</span>f $flagfile <span class=\"token punctuation\">]</span>; then\n\t<span class=\"token comment\"># 修改MySQL的密码</span>\n    mysqladmin <span class=\"token punctuation\">-</span>u root password \"root\"\n    <span class=\"token comment\"># 登录MySQL并导入SQL文件执行</span>\n    mysql <span class=\"token punctuation\">-</span>uroot <span class=\"token punctuation\">-</span>proot &lt; $sqlfile\n    <span class=\"token comment\"># 删除SQL文件</span>\n    rm <span class=\"token punctuation\">-</span>f $sqlfile\nfi\n<span class=\"token comment\"># 此处注意，如果命令执行完后脚本退出</span>\n<span class=\"token comment\"># 则Docker容器也会因为没有前台应用运行而中止</span>\n<span class=\"token comment\"># 所以这里使用一个前台命令来保活Docker容器</span>\ntail <span class=\"token punctuation\">-</span>f /var/log/apache2/error.log<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"实例二：PHP环境配置：\">实例二：PHP环境配置：</h3>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"><span class=\"token comment\"># 来源镜像，自带Apache+PHP环境</span>\nFROM php<span class=\"token punctuation\">:</span>7.0<span class=\"token punctuation\">-</span>apache\nMAINTAINER tl\nENV REFRESHED_AT 2018‐08‐03\nENV LANG C.UTF‐8\n<span class=\"token comment\"># ADD命令在COPY命令的基础上，具有自动解包tar的功能</span>\nADD web_tired.tar /var/www/html/\nEXPOSE 80<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"实例三：LTMJ（Linux-Tomcat-MySQL-JSP）环境配置\">实例三：LTMJ（Linux+Tomcat+MySQL+JSP）环境配置</h3>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">FROM ubuntu<span class=\"token punctuation\">:</span><span class=\"token number\">16.04</span>\nMAINTAINER wrlu\nENV REFRESHED_AT 2018<span class=\"token punctuation\">-</span>08<span class=\"token punctuation\">-</span><span class=\"token number\">05</span>\nENV LANG C.UTF<span class=\"token punctuation\">-</span><span class=\"token number\">8</span>\nRUN apt<span class=\"token punctuation\">-</span>get update <span class=\"token punctuation\">-</span>y\nRUN apt<span class=\"token punctuation\">-</span>get <span class=\"token punctuation\">-</span>y install mysql<span class=\"token punctuation\">-</span>server\n<span class=\"token comment\"># 安装wget，因为Docker提供的镜像是最小镜像，所以用到的其他工具需要自行安装</span>\nRUN apt<span class=\"token punctuation\">-</span>get <span class=\"token punctuation\">-</span>y install wget\n<span class=\"token comment\"># 安装Java 8</span>\nRUN apt<span class=\"token punctuation\">-</span>get <span class=\"token punctuation\">-</span>y install openjdk<span class=\"token punctuation\">-</span>8<span class=\"token punctuation\">-</span>jre\n<span class=\"token comment\"># 下载Tomcat 8服务器</span>\nRUN wget http<span class=\"token punctuation\">:</span>//mirrors.hust.edu.cn/apache/tomcat/tomcat<span class=\"token punctuation\">-</span>8/v8.5.32/bin/apache<span class=\"token punctuation\">-</span>tomcat<span class=\"token punctuation\">-</span>8.5.32.tar.gz\n<span class=\"token comment\"># 解压tar.gz</span>\nRUN tar <span class=\"token punctuation\">-</span>xzf apache<span class=\"token punctuation\">-</span>tomcat<span class=\"token punctuation\">-</span>8.5.32.tar.gz <span class=\"token punctuation\">-</span>C /root\nRUN mv /root/apache<span class=\"token punctuation\">-</span>tomcat<span class=\"token punctuation\">-</span>8.5.32 /root/tomcat\n<span class=\"token comment\"># 删除默认页面</span>\nRUN rm <span class=\"token punctuation\">-</span>rf /root/tomcat/webapps/*\n<span class=\"token comment\"># 拷贝war文件</span>\nCOPY CAAC<span class=\"token punctuation\">-</span>SQL<span class=\"token punctuation\">-</span>Injection.war /root/tomcat/webapps/\nCOPY wafwtf.sql /root/\nCOPY start.sh /root/start.sh\nRUN chmod +x /root/start.sh\nENTRYPOINT cd /root; ./start.sh\n<span class=\"token comment\"># Tomcat使用8080端口，不同于Apache</span>\nEXPOSE 8080<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<ul>\n<li>启动脚本如下：</li>\n</ul>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"><span class=\"token comment\">#!/bin/bash</span>\nsleep 1\nfind /var/lib/mysql <span class=\"token punctuation\">-</span>type f <span class=\"token punctuation\">-</span>exec touch <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> ; <span class=\"token important\">&amp;&amp;</span> service mysql start\nchmod +x /root/tomcat/bin/startup.sh\n<span class=\"token comment\"># 启动Tomcat服务器</span>\n/root/tomcat/bin/startup.sh\nsqlfile=/root/wafwtf.sql\nif <span class=\"token punctuation\">[</span> <span class=\"token punctuation\">-</span>f $flagfile <span class=\"token punctuation\">]</span>; then\n    mysqladmin <span class=\"token punctuation\">-</span>u root password \"root\"\n    mysql <span class=\"token punctuation\">-</span>uroot <span class=\"token punctuation\">-</span>proot &lt; $sqlfile\n    rm <span class=\"token punctuation\">-</span>f $sqlfile\nfi\n<span class=\"token comment\"># 容器保活</span>\ntail <span class=\"token punctuation\">-</span>f /root/tomcat/conf/server.xml<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"系列教程-4\"><strong>系列教程</strong></h2>\n<p><a href=\"https://blog.17lai.site/atom.xml\">全部文章RSS订阅</a></p>\n<p><strong>Docker系列</strong> <a href=\"https://blog.17lai.site/categories/docker/atom.xml\"><strong>Docker 分类 RSS 订阅</strong></a></p>\n<ul>\n<li><a href=\"https://blog.17lai.site/posts/42b6a86d/\">Docker使用简明教程</a></li>\n<li><a href=\"https://blog.17lai.site/posts/9912bd5d/\">使用jeckett,sonarr,iyuu,qt,emby打造全自动追剧流程</a></li>\n<li><a href=\"https://blog.17lai.site/posts/1802a8a7/\">为知笔记私有化Docker部署</a></li>\n<li><a href=\"https://blog.17lai.site/posts/593cc323/\">Earthly 一个更加强大的镜像构建工具</a></li>\n<li><a href=\"https://blog.17lai.site/posts/90e60aac/\">使用 Shell 脚本实现一个简单 Docker</a></li>\n<li><a href=\"https://blog.17lai.site/posts/465d2738/\">如何使用Traefik V2 在Ubuntu20.04 上面来做 Dockers</a></li>\n<li><a href=\"https://blog.17lai.site/posts/462f1e5c/\">通过IPV6访问Qnap NAS中Docker的服务</a></li>\n</ul>\n<link rel=\"stylesheet\" href=\"/css/bilicard.css\" type=\"text/css\">",
            "tags": [
                "linux",
                "mysql",
                "docker",
                "lamp",
                "php",
                "tomcat"
            ]
        }
    ]
}