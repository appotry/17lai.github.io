<!DOCTYPE HTML><html lang="zh-CN"><head><link href="https://cdn.jsdelivr.net/npm/hexo-tag-common@0.0.5/css/index.css" rel="stylesheet"><meta charset="utf-8"><meta name="keywords" content="docker, shell, linux"><meta name="description" content="通过一系列的实验使用户对docker的底层技术，如Namespace、CGroups、rootfs、联合加载等有一个感性的认识。在此过程中，我们还将通过Shell脚本一步一步地实现一个简易的docker，以期使读者在使用docker的过程中知其然知其所以然。"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="apple-mobile-web-app-title" content="夜法之书"><meta name="theme-color" content="#7e9fc4"><meta name="msapplication-TileImage" content="/medias_webp/icons/android-chrome-192x192.png"><meta name="msapplication-TileColor" content="#7e9fc4"><link rel="apple-touch-icon" href="/medias_webp/icons/apple-touch-icon.png"><meta name="referrer" content="no-referrer-when-downgrade"><title>使用 Shell 脚本实现一个简单 Docker | 夜法之书</title><link rel="manifest" href="/manifest.json"><link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/appotry/hexo@2.41/favicon.png"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/appotry/hexo@2.41/libs/awesome/css/all.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/appotry/hexo@2.41/libs/materialize/materialize.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/appotry/hexo@2.41/libs/aos/aos.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/appotry/hexo@2.41/libs/animate/animate.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/appotry/hexo@2.41/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/appotry/hexo@2.41/css/matery.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/appotry/hexo@2.41/css/my.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/appotry/hexo@2.41/css/dark.css"><link rel="alternate" type="application/atom+xml" title="所有订阅--夜法之书" href="https://blog.17lai.site/atom.xml"><script src="https://cdn.jsdelivr.net/gh/appotry/hexo@2.41/libs/jquery/jquery-3.6.0.min.js"></script><meta name="generator" content="Hexo 6.1.0"><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style></head><style>body{background-image:url(https://cdn.jsdelivr.net/gh/appotry/hexo@latest/medias_webp/sea.webp);background-repeat:no-repeat;background-size:100% 100%;background-attachment:fixed}</style><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"> <a href="/" class="waves-effect waves-light"><img no-lazy src="https://cdn.jsdelivr.net/gh/appotry/hexo@2.41/medias/logo.png" style="width:40px;height:45px" class="logo-img" alt="LOGO"> <span class="logo-span">夜法之书</span></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fas fa-home" style="zoom:.6"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="https://nav.17lai.site/" class="waves-effect waves-light"><i class="fas fa-suitcase" style="zoom:.6"></i> <span>导航</span></a></li><li class="hide-on-med-and-down nav-item"><a href="" class="waves-effect waves-light"><i class="fas fa-music" style="zoom:.6"></i> <span>多媒体</span><i class="fas fa-chevron-down" aria-hidden="true" style="zoom:.6"></i></a><ul class="sub-nav menus_item_child"><li><a href="/musics"><i class="fas fa-music" style="margin-top:-20px;zoom:.6"></i> <span>音乐</span></a></li><li><a href="/galleries"><i class="fas fa-image" style="margin-top:-20px;zoom:.6"></i> <span>相册</span></a></li><li><a href="/movies"><i class="fas fa-film" style="margin-top:-20px;zoom:.6"></i> <span>视频</span></a></li><li><a href="https://musicplayer.17lai.site/"><i class="fas fa-music" style="margin-top:-20px;zoom:.6"></i> <span>在线云音乐</span></a></li><li><a href="https://music.17lai.site/"><i class="fas fa-music" style="margin-top:-20px;zoom:.6"></i> <span>音乐播放器</span></a></li></ul></li><li class="hide-on-med-and-down nav-item"><a href="" class="waves-effect waves-light"><i class="fas fa-folder-plus" style="zoom:.6"></i> <span>文章</span><i class="fas fa-chevron-down" aria-hidden="true" style="zoom:.6"></i></a><ul class="sub-nav menus_item_child"><li><a href="/tags"><i class="fas fa-tags" style="margin-top:-20px;zoom:.6"></i> <span>标签</span></a></li><li><a href="/categories"><i class="fas fa-bookmark" style="margin-top:-20px;zoom:.6"></i> <span>分类</span></a></li><li><a href="/archives"><i class="fas fa-archive" style="margin-top:-20px;zoom:.6"></i> <span>归档</span></a></li></ul></li><li class="hide-on-med-and-down nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fas fa-link" style="zoom:.6"></i> <span>友链</span></a></li><li class="hide-on-med-and-down nav-item"><a href="" class="waves-effect waves-light"><i class="fas fa-comments" style="zoom:.6"></i> <span>交流</span><i class="fas fa-chevron-down" aria-hidden="true" style="zoom:.6"></i></a><ul class="sub-nav menus_item_child"><li><a href="/contact"><i class="fas fa-comments" style="margin-top:-20px;zoom:.6"></i> <span>留言</span></a></li><li><a href="https://t.me/joinchat/Sg3__qc4LBE2VsLO"><i class="fab fa-telegram-plane" style="margin-top:-20px;zoom:.6"></i> <span>TG群</span></a></li></ul></li><li class="hide-on-med-and-down nav-item"><a href="" class="waves-effect waves-light"><i class="fas fa-code" style="zoom:.6"></i> <span>快查</span><i class="fas fa-chevron-down" aria-hidden="true" style="zoom:.6"></i></a><ul class="sub-nav menus_item_child"><li><a href="/cheatsheets/Vim_CN.docset/Contents/Resources/Documents/"><i class="fab fa-vimeo-v" style="margin-top:-20px;zoom:.6"></i> <span>Vim快查表</span></a></li><li><a href="/cheatsheets/Visual_Studio_Code.docset/Contents/Resources/Documents/"><i class="fas fa-code" style="margin-top:-20px;zoom:.6"></i> <span>VSCode快查表</span></a></li><li><a href="/cheatsheets/Git.docset/Contents/Resources/Documents/"><i class="fab fa-git-square" style="margin-top:-20px;zoom:.6"></i> <span>Git快查表</span></a></li><li><a href="/cheatsheets/SQLite.docset/Contents/Resources/Documents/"><i class="fas fa-database" style="margin-top:-20px;zoom:.6"></i> <span>SQLite快查表</span></a></li><li><a href="/cheatsheets/tmux.docset/Contents/Resources/Documents/"><i class="fas fa-terminal" style="margin-top:-20px;zoom:.6"></i> <span>Tmux快查表</span></a></li><li><a href="/cheatsheets/Bash_Shortcuts.docset/Contents/Resources/Documents/"><i class="fas fa-terminal" style="margin-top:-20px;zoom:.6"></i> <span>Bash快查表</span></a></li><li><a href="/dash/"><i class="fas fa-laptop-code" style="margin-top:-20px;zoom:.6"></i> <span>更多快查表</span></a></li></ul></li><li class="hide-on-med-and-down nav-item"><a href="" class="waves-effect waves-light"><i class="fas fa-toolbox" style="zoom:.6"></i> <span>工具</span><i class="fas fa-chevron-down" aria-hidden="true" style="zoom:.6"></i></a><ul class="sub-nav menus_item_child"><li><a href="https://linux-command.17lai.site/"><i class="fas fa-terminal" style="margin-top:-20px;zoom:.6"></i> <span>Linux命令</span></a></li><li><a href="http://encode.chahuo.com/"><i class="fas fa-tools" style="margin-top:-20px;zoom:.6"></i> <span>加密解密</span></a></li><li><a href="https://markmap.js.org/repl"><i class="fas fa-brain" style="margin-top:-20px;zoom:.6"></i> <span>思维导图</span></a></li><li><a href="https://fontawesome.com/v5.15/icons"><i class="fab fa-font-awesome" style="margin-top:-20px;zoom:.6"></i> <span>Awesome</span></a></li><li><a href="http://ping.chinaz.com/"><i class="fas fa-tools" style="margin-top:-20px;zoom:.6"></i> <span>站长工具</span></a></li><li><a href="http://tool.chinaz.com/port/"><i class="fas fa-tools" style="margin-top:-20px;zoom:.6"></i> <span>端口扫描</span></a></li><li><a href="https://ssh.17lai.site/"><i class="fas fa-tools" style="margin-top:-20px;zoom:.6"></i> <span>WebSSH</span></a></li><li><a href="https://so.17lai.site/"><i class="fas fa-tools" style="margin-top:-20px;zoom:.6"></i> <span>安全搜索</span></a></li><li><a href="/nav"><i class="fas fa-tools" style="margin-top:-20px;zoom:.6"></i> <span>网址导航</span></a></li><li><a href="https://devtool.tech/"><i class="fas fa-tools" style="margin-top:-20px;zoom:.6"></i> <span>Devtools</span></a></li></ul></li><li class="hide-on-med-and-down nav-item"><a href="" class="waves-effect waves-light"><i class="fas fa-id-badge" style="zoom:.6"></i> <span>关于</span><i class="fas fa-chevron-down" aria-hidden="true" style="zoom:.6"></i></a><ul class="sub-nav menus_item_child"><li><a href="/about"><i class="fas fa-user-circle" style="margin-top:-20px;zoom:.6"></i> <span>关于我</span></a></li><li><a href="/myTeck"><i class="fas fa-address-card" style="margin-top:-20px;zoom:.6"></i> <span>我的技术</span></a></li><li><a href="/myProject"><i class="fas fa-laptop-code" style="margin-top:-20px;zoom:.6"></i> <span>我的项目</span></a></li><li><a href="/myPost"><i class="fas fa-pen-nib" style="margin-top:-20px;zoom:.6"></i> <span>我的文章</span></a></li><li><a href="/needtoread"><i class="fas fa-exclamation-circle" style="margin-top:-20px;zoom:.6"></i> <span>博客须知</span></a></li></ul></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fas fa-search" title="搜索" style="zoom:.85"></i></a></li><li><a class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色"><i id="sum-moon-icon" class="fas fa-sun" style="zoom:.85"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><div> <img no-lazy src="https://cdn.jsdelivr.net/gh/appotry/hexo@2.41/medias/logo.png" style="width:40px;height:45px" class="logo-img circle responsive-img" alt="LOGO"><div class="logo-name">夜法之书</div><div class="logo-desc"> ~软件驱动世界~</div></div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa-fw fas fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="https://nav.17lai.site/" class="waves-effect waves-light"><i class="fa-fw fas fa-suitcase"></i> 导航</a></li><li class="m-nav-item"><a href="javascript:;"><i class="fa-fw fas fa-music"></i> 多媒体<span class="m-icon"><i class="fas fa-chevron-right"></i></span></a><ul style=""><li><a href="/musics" style="margin-left:75px"><i class="fa fas fa-music" style="position:absolute;left:50px"></i> <span>音乐</span></a></li><li><a href="/galleries" style="margin-left:75px"><i class="fa fas fa-image" style="position:absolute;left:50px"></i> <span>相册</span></a></li><li><a href="/movies" style="margin-left:75px"><i class="fa fas fa-film" style="position:absolute;left:50px"></i> <span>视频</span></a></li><li><a href="https://musicplayer.17lai.site/" style="margin-left:75px"><i class="fa fas fa-music" style="position:absolute;left:50px"></i> <span>在线云音乐</span></a></li><li><a href="https://music.17lai.site/" style="margin-left:75px"><i class="fa fas fa-music" style="position:absolute;left:50px"></i> <span>音乐播放器</span></a></li></ul></li><li class="m-nav-item"><a href="javascript:;"><i class="fa-fw fas fa-folder-plus"></i> 文章<span class="m-icon"><i class="fas fa-chevron-right"></i></span></a><ul style=""><li><a href="/tags" style="margin-left:75px"><i class="fa fas fa-tags" style="position:absolute;left:50px"></i> <span>标签</span></a></li><li><a href="/categories" style="margin-left:75px"><i class="fa fas fa-bookmark" style="position:absolute;left:50px"></i> <span>分类</span></a></li><li><a href="/archives" style="margin-left:75px"><i class="fa fas fa-archive" style="position:absolute;left:50px"></i> <span>归档</span></a></li></ul></li><li class="m-nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa-fw fas fa-link"></i> 友链</a></li><li class="m-nav-item"><a href="javascript:;"><i class="fa-fw fas fa-comments"></i> 交流<span class="m-icon"><i class="fas fa-chevron-right"></i></span></a><ul style=""><li><a href="/contact" style="margin-left:75px"><i class="fa fas fa-comments" style="position:absolute;left:50px"></i> <span>留言</span></a></li><li><a href="https://t.me/joinchat/Sg3__qc4LBE2VsLO" style="margin-left:75px"><i class="fa fab fa-telegram-plane" style="position:absolute;left:50px"></i> <span>TG群</span></a></li></ul></li><li class="m-nav-item"><a href="javascript:;"><i class="fa-fw fas fa-code"></i> 快查<span class="m-icon"><i class="fas fa-chevron-right"></i></span></a><ul style=""><li><a href="/cheatsheets/Vim_CN.docset/Contents/Resources/Documents/" style="margin-left:75px"><i class="fa fab fa-vimeo-v" style="position:absolute;left:50px"></i> <span>Vim快查表</span></a></li><li><a href="/cheatsheets/Visual_Studio_Code.docset/Contents/Resources/Documents/" style="margin-left:75px"><i class="fa fas fa-code" style="position:absolute;left:50px"></i> <span>VSCode快查表</span></a></li><li><a href="/cheatsheets/Git.docset/Contents/Resources/Documents/" style="margin-left:75px"><i class="fa fab fa-git-square" style="position:absolute;left:50px"></i> <span>Git快查表</span></a></li><li><a href="/cheatsheets/SQLite.docset/Contents/Resources/Documents/" style="margin-left:75px"><i class="fa fas fa-database" style="position:absolute;left:50px"></i> <span>SQLite快查表</span></a></li><li><a href="/cheatsheets/tmux.docset/Contents/Resources/Documents/" style="margin-left:75px"><i class="fa fas fa-terminal" style="position:absolute;left:50px"></i> <span>Tmux快查表</span></a></li><li><a href="/cheatsheets/Bash_Shortcuts.docset/Contents/Resources/Documents/" style="margin-left:75px"><i class="fa fas fa-terminal" style="position:absolute;left:50px"></i> <span>Bash快查表</span></a></li><li><a href="/dash/" style="margin-left:75px"><i class="fa fas fa-laptop-code" style="position:absolute;left:50px"></i> <span>更多快查表</span></a></li></ul></li><li class="m-nav-item"><a href="javascript:;"><i class="fa-fw fas fa-toolbox"></i> 工具<span class="m-icon"><i class="fas fa-chevron-right"></i></span></a><ul style=""><li><a href="https://linux-command.17lai.site/" style="margin-left:75px"><i class="fa fas fa-terminal" style="position:absolute;left:50px"></i> <span>Linux命令</span></a></li><li><a href="http://encode.chahuo.com/" style="margin-left:75px"><i class="fa fas fa-tools" style="position:absolute;left:50px"></i> <span>加密解密</span></a></li><li><a href="https://markmap.js.org/repl" style="margin-left:75px"><i class="fa fas fa-brain" style="position:absolute;left:50px"></i> <span>思维导图</span></a></li><li><a href="https://fontawesome.com/v5.15/icons" style="margin-left:75px"><i class="fa fab fa-font-awesome" style="position:absolute;left:50px"></i> <span>Awesome</span></a></li><li><a href="http://ping.chinaz.com/" style="margin-left:75px"><i class="fa fas fa-tools" style="position:absolute;left:50px"></i> <span>站长工具</span></a></li><li><a href="http://tool.chinaz.com/port/" style="margin-left:75px"><i class="fa fas fa-tools" style="position:absolute;left:50px"></i> <span>端口扫描</span></a></li><li><a href="https://ssh.17lai.site/" style="margin-left:75px"><i class="fa fas fa-tools" style="position:absolute;left:50px"></i> <span>WebSSH</span></a></li><li><a href="https://so.17lai.site/" style="margin-left:75px"><i class="fa fas fa-tools" style="position:absolute;left:50px"></i> <span>安全搜索</span></a></li><li><a href="/nav" style="margin-left:75px"><i class="fa fas fa-tools" style="position:absolute;left:50px"></i> <span>网址导航</span></a></li><li><a href="https://devtool.tech/" style="margin-left:75px"><i class="fa fas fa-tools" style="position:absolute;left:50px"></i> <span>Devtools</span></a></li></ul></li><li class="m-nav-item"><a href="javascript:;"><i class="fa-fw fas fa-id-badge"></i> 关于<span class="m-icon"><i class="fas fa-chevron-right"></i></span></a><ul style=""><li><a href="/about" style="margin-left:75px"><i class="fa fas fa-user-circle" style="position:absolute;left:50px"></i> <span>关于我</span></a></li><li><a href="/myTeck" style="margin-left:75px"><i class="fa fas fa-address-card" style="position:absolute;left:50px"></i> <span>我的技术</span></a></li><li><a href="/myProject" style="margin-left:75px"><i class="fa fas fa-laptop-code" style="position:absolute;left:50px"></i> <span>我的项目</span></a></li><li><a href="/myPost" style="margin-left:75px"><i class="fa fas fa-pen-nib" style="position:absolute;left:50px"></i> <span>我的文章</span></a></li><li><a href="/needtoread" style="margin-left:75px"><i class="fa fas fa-exclamation-circle" style="position:absolute;left:50px"></i> <span>博客须知</span></a></li></ul></li></ul></div></div></nav></header><script src="https://cdn.jsdelivr.net/gh/appotry/hexo@2.41/libs/cryptojs/crypto-js.min.js"></script><script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script><div class="bg-cover pd-header post-cover" style="background-image:url(https://cdn.jsdelivr.net/gh/appotry/hexo@2.41/medias_webp/cover/docker.webp)"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">使用 Shell 脚本实现一个简单 Docker</h1></div></div></div></div></div><main class="post-container content"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/appotry/hexo@2.41/libs/tocbot/tocbot.css"><style>#articleContent h1::before,#articleContent h2::before,#articleContent h3::before,#articleContent h4::before,#articleContent h5::before,#articleContent h6::before{display:block;content:" ";height:100px;margin-top:-100px;visibility:hidden}#articleContent :focus{outline:0}.toc-fixed{position:fixed;top:64px}.toc-widget{width:345px;padding-left:20px}.toc-widget .toc-title{padding:35px 0 15px 17px;font-size:1.5rem;font-weight:700;line-height:1.5rem}.toc-widget ol{padding:0;list-style:none}#toc-content{padding-bottom:30px;overflow:auto}#toc-content ol{padding-left:10px}#toc-content ol li{padding-left:10px}#toc-content .toc-link:hover{color:#42b983;font-weight:700;text-decoration:underline}#toc-content .toc-link::before{background-color:transparent;max-height:25px;position:absolute;right:23.5vw;display:block}#toc-content .is-active-link{color:#42b983}#floating-toc-btn{position:fixed;right:15px;bottom:76px;padding-top:15px;margin-bottom:0;z-index:998}#floating-toc-btn .btn-floating{width:48px;height:48px}#floating-toc-btn .btn-floating i{line-height:48px;font-size:1.4rem}</style><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"> <a href="/tags/linux/"><span class="chip bg-color">linux</span></a> <a href="/tags/docker/"><span class="chip bg-color">docker</span></a> <a href="/tags/shell/"><span class="chip bg-color">shell</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/docker/" class="post-category">docker</a><link rel="alternate" type="application/atom+xml" title="分类订阅--docker" href="https://blog.17lai.site/categories/docker/atom.xml"></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="far fa-calendar-minus fa-fw"></i> 发布日期:&nbsp;&nbsp; 2022-03-18</div><div class="post-date info-break-policy"><i class="far fa-calendar-check fa-fw"></i> 更新日期:&nbsp;&nbsp; 2022-03-19</div><div class="info-break-policy"><i class="far fa-file-word fa-fw"></i> 文章字数:&nbsp;&nbsp; 14.6k</div><div class="info-break-policy"><i class="far fa-clock fa-fw"></i> 阅读时长:&nbsp;&nbsp; 61 分</div><div id="busuanzi_container_page_pv" class="info-break-policy"><i class="far fa-eye fa-fw"></i> 阅读次数:&nbsp;&nbsp;<span id="busuanzi_value_page_pv"></span></div></div></div><hr class="clearfix"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/appotry/hexo@2.41/libs/prism/prism.css"><style type="text/css">code[class*=language-],pre[class*=language-]{white-space:pre-wrap!important}</style><div class="card-content article-card-content"><div id="articleContent"><blockquote><p>《使用 Shell 脚本实现 Docker》旨在通过一系列的实验使用户对 docker 的底层技术，如 Namespace、CGroups、rootfs、联合加载等有一个感性的认识。在此过程中，我们还将通过 Shell 脚本一步一步地实现一个简易的 docker，以期使读者在使用 docker 的过程中知其然知其所以然。</p></blockquote><p>我们的实验环境为 Ubuntu 18.04 64bit，简易 docker 工程的名字为 docker.sh，该工程仓库地址如下：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">https://github.com/pandengyang/docker.sh.git
https://github.com/appotry/docker.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>《使用 Shell 脚本实现 Docker》目录如下：</p><pre class="line-numbers language-none"><code class="language-none">1. Namespace
1.1. Namespace简介
1.2. uts namespace
1.2.1. uts namespace简介
1.2.2. docker.sh
1.3. mount namespace
1.3.1. /etc/mtab、/proc/self/mounts
1.3.2. /proc/self/mountinfo
1.3.3. bind mount
1.3.4. mount namespace简介
1.3.5. docker.sh
1.4. pid namespace
1.4.1. unshare的--fork选项
1.4.2. pid namespace简介
1.4.3. pid嵌套
1.4.4. docker.sh
2. CGroups
2.1. CGroups简介
2.2. 限制内存
2.2.1. 用CGroups限制内存
2.2.2. docker.sh
3. 切换根文件系统
3.1. 根文件系统
3.2. pivot_root
3.3. docker.sh
4. 联合加载
4.1. 联合加载简介
4.2. AUFS
4.3. docker.sh
5. 卷
5.1. 卷简介
5.2. docker.sh
6. 后记<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-Namespace">1.Namespace</h2><h3 id="1-1-Namespace简介">1.1.Namespace 简介</h3><p>传统上，在 Linux 中，许多资源是全局管理的。例如，系统中的所有进程按照惯例是通过 PID 标识的，这意味着内核必须管理一个全局的 PID 列表。而且，所有调用者通过 uname 系统调用返回的系统相关信息都是相同的。用户 id 的管理方式类似，即各个用户是通过一个全局唯一的 UID 标识。</p><p>Namespace 是 Linux 用来隔离上述全局资源的一种方式。把一个或多个进程加入到同一个 namespace 中后，这些进程只会看到该 namespace 中的资源。namespace 是后来加入到 Linux 中的，为了兼容之前的全局资源管理方式，Linux 为每一种资源准备了一个全局的 namespace。Linux 中的每一个进程都默认加入了这些全局 namespace。</p><p>Linux 中的每个进程都有一个 /proc/[pid]/ns/ 目录，里面包含了该进程所属的 namespace 信息。我们查看一下当前 Shell 的 /proc/[pid]/ns 目录，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">sudo</span> <span class="token function">ls</span> -l /proc/<span class="token variable">$$</span>/ns
total <span class="token number">0</span>
lrwxrwxrwx <span class="token number">1</span> phl phl <span class="token number">0</span> Jan <span class="token number">22</span> 08:43 cgroup -<span class="token operator">&gt;</span> cgroup:<span class="token punctuation">[</span><span class="token number">4026531835</span><span class="token punctuation">]</span>
lrwxrwxrwx <span class="token number">1</span> phl phl <span class="token number">0</span> Jan <span class="token number">22</span> 08:43 ipc -<span class="token operator">&gt;</span> ipc:<span class="token punctuation">[</span><span class="token number">4026531839</span><span class="token punctuation">]</span>
lrwxrwxrwx <span class="token number">1</span> phl phl <span class="token number">0</span> Jan <span class="token number">22</span> 08:43 mnt -<span class="token operator">&gt;</span> mnt:<span class="token punctuation">[</span><span class="token number">4026531840</span><span class="token punctuation">]</span>
lrwxrwxrwx <span class="token number">1</span> phl phl <span class="token number">0</span> Jan <span class="token number">22</span> 08:43 net -<span class="token operator">&gt;</span> net:<span class="token punctuation">[</span><span class="token number">4026531993</span><span class="token punctuation">]</span>
lrwxrwxrwx <span class="token number">1</span> phl phl <span class="token number">0</span> Jan <span class="token number">22</span> 08:43 pid -<span class="token operator">&gt;</span> pid:<span class="token punctuation">[</span><span class="token number">4026531836</span><span class="token punctuation">]</span>
lrwxrwxrwx <span class="token number">1</span> phl phl <span class="token number">0</span> Jan <span class="token number">22</span> 08:43 pid_for_children -<span class="token operator">&gt;</span> pid:<span class="token punctuation">[</span><span class="token number">4026531836</span><span class="token punctuation">]</span>
lrwxrwxrwx <span class="token number">1</span> phl phl <span class="token number">0</span> Jan <span class="token number">22</span> 08:43 user -<span class="token operator">&gt;</span> user:<span class="token punctuation">[</span><span class="token number">4026531837</span><span class="token punctuation">]</span>
lrwxrwxrwx <span class="token number">1</span> phl phl <span class="token number">0</span> Jan <span class="token number">22</span> 08:43 uts -<span class="token operator">&gt;</span> uts:<span class="token punctuation">[</span><span class="token number">4026531838</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该目录下有很多符号链接，每个符号链接代表一个该进程所属的 namespace。用 readlink 读取这些符号链接可以查看进程所属的 namespace id。我们读一下当前 Shell 所属的 uts namespace id，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">sudo</span> readlink /proc/<span class="token variable">$$</span>/ns/uts
uts:<span class="token punctuation">[</span><span class="token number">4026531838</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>后文中我们将介绍 uts namespace、mount namespace、pid namespace 的用法。</p><h3 id="1-2-uts-namespace">1.2.uts namespace</h3><h4 id="1-2-1-uts-namespace简介">1.2.1.uts namespace 简介</h4><p>uts namespace 用于隔离系统的主机名等信息，我们将通过实验学习其用法。在实验过程中，我们采用如下的步骤：</p><ol><li>查看全局 uts namespace 信息</li><li>新建一个 uts namespace，查看其信息并作出修改</li><li>查看全局 uts namespace，查看其是否被新建的 uts namespace 影响到</li></ol><p>对于其他 namespace，我们也采取类似的步骤进行实验学习。</p><p>首先，我们查看一下全局的 hostname 及 uts namespace id。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">hostname</span>
kernelnewbies

phl@kernelnewbies:~$ <span class="token function">sudo</span> readlink /proc/<span class="token variable">$$</span>/ns/uts
uts:<span class="token punctuation">[</span><span class="token number">4026531838</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，我们创建一个新的 uts namespace，并查看其 namespce id。</p><p>在继续之前，需要介绍一个 namespace 工具 unshare。利用 unshare 我们可以新建一个的 namespace，并在新 namespace 中执行一条命令。unshare 执行时需要 root 权限。unshare 的使用方法如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">unshare <span class="token punctuation">[</span>options<span class="token punctuation">]</span> <span class="token punctuation">[</span>program <span class="token punctuation">[</span>arguments<span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行 unshare 时，我们可以指定要新建的 namespace 的类型以及要执行的命令。unshare 提供了一系列选项，当指定某个选项时可新建指定的 namespace。namespace 类型选项如下：</p><ul><li>--uts 创建新的 uts namespace</li><li>--mount 创建新的 mount namespace</li><li>--pid 创建新的 pid namespace</li><li>--user 创建新的 user namespace</li></ul><p>介绍完 unshare 之后，我们继续之前的实验。我们用 unshare 创建一个新的 uts namespace，并在新的 uts namespace 中执行 /bin/bash 命令，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">sudo</span> unshare --uts /bin/bash
root@kernelnewbies:~<span class="token comment">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们用 unshare 创建了一个新的 uts namespace。在新的 uts namespace 中查看其 hostname 和 namespace id，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@kernelnewbies:~$ <span class="token function">hostname</span>
kernelnewbies

root@kernelnewbies:~<span class="token comment"># readlink /proc/$$/ns/uts</span>
uts:<span class="token punctuation">[</span><span class="token number">4026532177</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从结果我们可以看到，新 uts namespace 的 id 与全局 uts namespace 的 id 不一致。这说明 /bin/bash 已运行在一个新的 uts namespace 中了。</p><p>我们将新 uts namespace 的 hostname 改为 dreamland，并强制更新 Shell 提示符。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@kernelnewbies:~<span class="token comment"># hostname dreamland</span>
root@kernelnewbies:~<span class="token comment"># hostname</span>
dreamland

root@kernelnewbies:~<span class="token comment"># exec /bin/bash</span>
root@dreamland:~<span class="token comment">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从结果我们可以看到，新 uts namespace 的 hostname 的确是被修改了，exec /bin/bash 用于强制更新 Shell 的提示符。</p><p>我们重新打开一个 Shell 窗口，该 Shell 位于全局 uts namespace 中。在新的 Shell 窗口中查看全局 uts namespace id 及 hostname，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">hostname</span>
kernelnewbies

phl@kernelnewbies:~$ <span class="token function">sudo</span> readlink /proc/<span class="token variable">$$</span>/ns/uts
uts:<span class="token punctuation">[</span><span class="token number">4026531838</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从结果我们可以看到，我们在新 uts namespace 中所作的修改并未影响到全局的 uts namespace。</p><p>父进程创建子进程时只有提供创建新 namespace 的标志，才可创建新的 namespace，并使子进程处于新的 namespace 中。默认情况下，子进程与父进程处于相同的 namespace 中。我们在新的 uts namespace 中创建一个子进程，然后查看该子进程的 uts namespace id，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">sudo</span> unshare --uts /bin/bash
root@kernelnewbies:~<span class="token comment"># readlink /proc/$$/ns/uts</span>
uts:<span class="token punctuation">[</span><span class="token number">4026532305</span><span class="token punctuation">]</span>

root@kernelnewbies:~<span class="token comment"># bash</span>
root@kernelnewbies:~<span class="token comment"># readlink /proc/$$/ns/uts</span>
uts:<span class="token punctuation">[</span><span class="token number">4026532305</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从结果我们可以看到，子进程所属 uts namespace 的 id 与其父进程相同。其他 namespae 与 uts namespace 类似，子进程与父进程同属一个 namespace。</p><h4 id="1-2-2-docker-sh">1.2.2.docker.sh</h4><p>有了以上关于 uts namespace 的介绍，我们就可以将 uts namespace 加入到 docker.sh 中了。docker.sh 工程分为两个脚本：docker.sh 和 container.sh。</p><p>docker.sh 用于收集用户输入、调用 unshare 创建 namespace 并执行 container.sh 脚本，docker.sh 脚本如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token function-name function">usage</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token builtin class-name">echo</span> -e <span class="token string">"<span class="token entity" title="\033">\033</span>[31mIMPORTANT: Run As Root<span class="token entity" title="\033">\033</span>[0m"</span>
        <span class="token builtin class-name">echo</span> <span class="token string">""</span>
        <span class="token builtin class-name">echo</span> <span class="token string">"Usage:    docker.sh [OPTIONS]"</span>
        <span class="token builtin class-name">echo</span> <span class="token string">""</span>
        <span class="token builtin class-name">echo</span> <span class="token string">"A docker written by shell"</span>
        <span class="token builtin class-name">echo</span> <span class="token string">""</span>
        <span class="token builtin class-name">echo</span> <span class="token string">"Options:"</span>
        <span class="token builtin class-name">echo</span> <span class="token string">"          -c string       docker command"</span>
        <span class="token builtin class-name">echo</span> <span class="token string">"                          (<span class="token entity" title="\&quot;">\"</span>run<span class="token entity" title="\&quot;">\"</span>)"</span>
        <span class="token builtin class-name">echo</span> <span class="token string">"          -m              memory"</span>
        <span class="token builtin class-name">echo</span> <span class="token string">"                          (<span class="token entity" title="\&quot;">\"</span>100M, 200M, 300M...<span class="token entity" title="\&quot;">\"</span>)"</span>
        <span class="token builtin class-name">echo</span> <span class="token string">"          -C string       container name"</span>
        <span class="token builtin class-name">echo</span> <span class="token string">"          -I string       image name"</span>
        <span class="token builtin class-name">echo</span> <span class="token string">"          -V string       volume"</span>
        <span class="token builtin class-name">echo</span> <span class="token string">"          -P string       program to run in container"</span>

        <span class="token builtin class-name">return</span> <span class="token number">0</span>
<span class="token punctuation">}</span>

<span class="token keyword">if</span> <span class="token builtin class-name">test</span> <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">whoami</span><span class="token variable">)</span></span>"</span> <span class="token operator">!=</span> root
<span class="token keyword">then</span>
        usage
        <span class="token builtin class-name">exit</span> -1
<span class="token keyword">fi</span>

<span class="token keyword">while</span> <span class="token builtin class-name">getopts</span> c:m:C:I:V:P: option
<span class="token keyword">do</span>
        <span class="token keyword">case</span> <span class="token string">"<span class="token variable">$option</span>"</span>
        <span class="token keyword">in</span>
                c<span class="token punctuation">)</span> <span class="token assign-left variable">cmd</span><span class="token operator">=</span><span class="token variable">$OPTARG</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
                m<span class="token punctuation">)</span> <span class="token assign-left variable">memory</span><span class="token operator">=</span><span class="token variable">$OPTARG</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
                C<span class="token punctuation">)</span> <span class="token assign-left variable">container</span><span class="token operator">=</span><span class="token variable">$OPTARG</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
                I<span class="token punctuation">)</span> <span class="token assign-left variable">image</span><span class="token operator">=</span><span class="token variable">$OPTARG</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
                V<span class="token punctuation">)</span> <span class="token assign-left variable">volume</span><span class="token operator">=</span><span class="token variable">$OPTARG</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
                P<span class="token punctuation">)</span> <span class="token assign-left variable">program</span><span class="token operator">=</span><span class="token variable">$OPTARG</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
                <span class="token punctuation">\</span>?<span class="token punctuation">)</span> usage
                    <span class="token builtin class-name">exit</span> -2<span class="token punctuation">;</span><span class="token punctuation">;</span>
        <span class="token keyword">esac</span>
<span class="token keyword">done</span>

<span class="token builtin class-name">export</span> <span class="token assign-left variable">cmd</span><span class="token operator">=</span><span class="token variable">$cmd</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable">memory</span><span class="token operator">=</span><span class="token variable">$memory</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable">container</span><span class="token operator">=</span><span class="token variable">$container</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable">image</span><span class="token operator">=</span><span class="token variable">$image</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable">volume</span><span class="token operator">=</span><span class="token variable">$volume</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable">program</span><span class="token operator">=</span><span class="token variable">$program</span>

unshare --uts ./container.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>脚本最开始为 usage 函数，该函数为 docker.sh 的使用说明。当用户以非预期的方式使用 docker.sh 时，该函数会被调用。该函数输出如下信息：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">IMPORTANT: Run As Root

Usage:  docker.sh <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span>

A <span class="token function">docker</span> written by shell

Options:
                -c string       <span class="token function">docker</span> <span class="token builtin class-name">command</span>
                                <span class="token punctuation">(</span><span class="token string">"run"</span><span class="token punctuation">)</span>
                -m              memory
                                <span class="token punctuation">(</span><span class="token string">"100M, 200M, 300M..."</span><span class="token punctuation">)</span>
                -C string       container name
                -I string       image name
                -V string       volume
                -P string       program to run <span class="token keyword">in</span> container<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从 usage 函数的输出我们可以看到，执行 docker.sh 时需要 root 权限且需要正确地传递参数。</p><p>docker.sh 首先对当前用户进行检测，如果用户不为 root，则打印使用说明并退出脚本；如果用户为 root，则继续执行。检测用户的脚本如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">if</span> <span class="token builtin class-name">test</span> <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">whoami</span><span class="token variable">)</span></span>"</span> <span class="token operator">!=</span> root
<span class="token keyword">then</span>
        usage
        <span class="token builtin class-name">exit</span> -1
<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，docker.sh 使用 getopts 从命令行提取参数，然后赋值给合适的变量。从命令行提取参数的脚本如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token keyword">while</span> <span class="token builtin class-name">getopts</span> c:m:C:I:V:P: option
<span class="token keyword">do</span>
        <span class="token keyword">case</span> <span class="token string">"<span class="token variable">$option</span>"</span>
        <span class="token keyword">in</span>
                c<span class="token punctuation">)</span> <span class="token assign-left variable">cmd</span><span class="token operator">=</span><span class="token variable">$OPTARG</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
                m<span class="token punctuation">)</span> <span class="token assign-left variable">memory</span><span class="token operator">=</span><span class="token variable">$OPTARG</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
                C<span class="token punctuation">)</span> <span class="token assign-left variable">container</span><span class="token operator">=</span><span class="token variable">$OPTARG</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
                I<span class="token punctuation">)</span> <span class="token assign-left variable">image</span><span class="token operator">=</span><span class="token variable">$OPTARG</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
                V<span class="token punctuation">)</span> <span class="token assign-left variable">volume</span><span class="token operator">=</span><span class="token variable">$OPTARG</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
                P<span class="token punctuation">)</span> <span class="token assign-left variable">program</span><span class="token operator">=</span><span class="token variable">$OPTARG</span><span class="token punctuation">;</span><span class="token punctuation">;</span>
                <span class="token punctuation">\</span>?<span class="token punctuation">)</span> usage
                    <span class="token builtin class-name">exit</span> -2<span class="token punctuation">;</span><span class="token punctuation">;</span>
        <span class="token keyword">esac</span>
<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果用户的输入不正确，则打印使用说明并退出脚本；如果用户输入正确，则解析命令行参数并赋值给合适的变量。</p><p>为了简化，用户在运行 docker.sh 时需提供完整的参数列表，示例如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> ./docker.sh -c run -m 100M -C dreamland -I ubuntu1604 -V data1 -P /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当然，如果当前用户就是 root，就不需要 sudo 了。下表列出了各个参数的含义及示例：</p><p><img src="/medias_webp/loading.svg" data-original="https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2022/03/1820220318143125.png" alt="使用 Shell 脚本实现 Docker"></p><p>docker.sh 将命令行参数赋值给变量后，需要将这些变量导出，以传递给 container.sh。导出变量的脚本如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">cmd</span><span class="token operator">=</span><span class="token variable">$cmd</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable">memory</span><span class="token operator">=</span><span class="token variable">$memory</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable">container</span><span class="token operator">=</span><span class="token variable">$container</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable">image</span><span class="token operator">=</span><span class="token variable">$image</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable">volume</span><span class="token operator">=</span><span class="token variable">$volume</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable">program</span><span class="token operator">=</span><span class="token variable">$program</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里说明一下为什么要将 docker.sh 工程拆分为 docker.sh 和 container.sh 两个脚本。因为调用 unshare 创建新的 namespace 时，会执行一个命令，该命令在新的 namespace 中运行。该命令一旦结束，unshare 也就结束了，unshare 创建的新 namespace 也就不存在了。</p><p>docker.sh 不会并发地执行 unshare 命令与 unshare 之后的脚本，因此，只有 unshare 结束了，后续脚本才可继续运行。但是当 unshare 结束了，准备执行后续脚本时，新的 namespae 已经不存在了。因此一些加入 cgroups、切换根文件系统等工作必须在 unshare 执行的命令中进行，所以我们采用在 unshare 中执行 container.sh 脚本的方式完成后续的工作。</p><p>最后，docker.sh 调用 unshare 创建新的 uts namespace，并执行 container.sh 脚本。调用 unshare 的脚本如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">unshare --uts ./container.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>container.sh 将容器的 hostname 修改为通过 - C 传递的容器的名字，然后执行通过 - P 传递的程序。container.sh 脚本如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token function">hostname</span> <span class="token variable">$container</span>
<span class="token builtin class-name">exec</span> <span class="token variable">$program</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>现在，我们运行 docker.sh，并查看其 hostname。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/docker.sh$ <span class="token function">sudo</span> ./docker.sh -c run -m 100M -C dreamland -I ubuntu1604 -V data1 -P /bin/bash
root@dreamland:~/docker.sh<span class="token comment"># hostname</span>
dreamland<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>从结果我们可以看到，容器的 hostname 已经改变为我们传递的容器名字 dreamland 了。</p><h3 id="1-3-mount-namespace">1.3.mount namespace</h3><h4 id="1-3-1-etc-mtab、-proc-self-mounts">1.3.1./etc/mtab、/proc/self/mounts</h4><p>早期的 Linux 使用 /etc/mtab 文件来记录当前的挂载点信息。每次 mount/umount 文件系统时会更新 /etc/mtab 文件中的信息。</p><p>后来，linux 引入了 mount namespace，每个进程都有一份自己的挂载点信息。当然，处于同一个 mount namespace 里面的进程，其挂载点信息是相同的。进程的挂载点信息通过 /proc/[pid]/mounts 文件导出给用户。</p><p>为了兼容以前的 /etc/mtab，/etc/mtab 变成了指向 /proc/self/mounts 的符号链接。通过 readlink 查看 /etc/mtab 指向的文件，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ readlink /etc/mtab
<span class="token punctuation">..</span>/proc/self/mounts<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>通过读取 /proc/self/mounts 文件，可以查看当前的挂载点信息，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">cat</span> /proc/self/mounts
sysfs /sys sysfs rw,nosuid,nodev,noexec,relatime <span class="token number">0</span> <span class="token number">0</span>
proc /proc proc rw,nosuid,nodev,noexec,relatime <span class="token number">0</span> <span class="token number">0</span>
/dev/sda1 / ext4 rw,relatime,errors<span class="token operator">=</span>remount-ro <span class="token number">0</span> <span class="token number">0</span>
securityfs /sys/kernel/security securityfs rw,nosuid,nodev,noexec,relatime <span class="token number">0</span> <span class="token number">0</span>
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于该文件中内容太多，我们省略了一部分，只保留了一些比较重要的挂载点信息。每行的信息分为六个字段，各字段的含义及示例如下：</p><p><img src="/medias_webp/loading.svg" data-original="https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2022/03/1820220318143143.png" alt="使用 Shell 脚本实现 Docker"></p><p>由于该文件有点过时，被后文介绍的 /proc/self/mountinfo 替换掉，所以不做过多介绍。</p><h4 id="1-3-2-proc-self-mountinfo">1.3.2./proc/self/mountinfo</h4><p>/proc/self/mountinfo 包含了进程 mount namespace 中的挂载点信息。 它提供了旧的 /proc/[pid]/mounts 文件中缺少的各种信息（传播状态，挂载点 id，父挂载点 id 等），并解决了 /proc/[pid]/mounts 文件的一些其他缺陷。我们查看进程挂载点信息时应优先使用该文件。</p><p>该文件中每一行代表一个挂载点信息，每个挂载点信息分为 11 个字段。挂载点信息的示例如下：</p><p><img src="/medias_webp/loading.svg" data-original="https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2022/03/1820220318143124.png" alt="使用 Shell 脚本实现 Docker"></p><p>各字段的含义及示例如下：</p><p><img src="/medias_webp/loading.svg" data-original="https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2022/03/1820220318143118.png" alt="使用 Shell 脚本实现 Docker"></p><p>我们主要关注可选字段中的传播状态选项。首先，我们看一下关于 mount namespace 的问题。问题如下：</p><p>当创建 mount namespace 时，新 mount namespace 会拷贝一份老 mount namespace 里面的挂载点信息。例如，全局 mount namespace 中有一个 /a 挂载点，新建的 mount namespace 中也会有一个 /a 挂载点。那么我们在新 mount namespace 中的 /a 下创建或删除一个挂载点，全局 mount namespace 中的 /a 会同步创建或删除该挂载点吗？或者在全局 mount namespace 中的 /a 下创建或删除一个挂载点，新 mount namespace 中的 /a 会同步创建或删除该挂载点吗？</p><p>mountinfo 文件中可选字段的传播状态就是控制在一个挂载点下进行创建 / 删除挂载点操作时是否会传播到其他挂载点的选项。传播状态有四种可取值，常见的有如下两种：</p><ul><li>shared 表示创建 / 删除挂载点的操作会传播到其他挂载点</li><li> private 表示创建 / 删除挂载点的操作不会传播到其他挂载点</li></ul><p>由于在容器技术中要保证主机与容器的挂载点信息互不影响，因此要求容器中的挂载点的传播状态为 private。</p><h4 id="1-3-3-bind-mount">1.3.3.bind mount</h4><p>bind mount 可以将一个目录（源目录）挂载到另一个目录（目的目录），在目的目录里面的读写操作将直接作用于源目录。</p><p>下面我们通过实验了解一下 bind mount 的功能，首先，我们准备一下实验所需要的的目录及文件。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">mkdir</span> <span class="token builtin class-name">bind</span>
phl@kernelnewbies:~$ <span class="token builtin class-name">cd</span> bind/
phl@kernelnewbies:~/bind$ <span class="token function">mkdir</span> a
phl@kernelnewbies:~/bind$ <span class="token function">mkdir</span> b
phl@kernelnewbies:~/bind$ <span class="token builtin class-name">echo</span> hello, a <span class="token operator">&gt;</span> a/a.txt
phl@kernelnewbies:~/bind$ <span class="token builtin class-name">echo</span> hello, b <span class="token operator">&gt;</span> b/b.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，我们将 a 目录 bind mount 到 b 目录并查看 b 目录下的内容。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/bind$ <span class="token function">sudo</span> <span class="token function">mount</span> --bind a b
phl@kernelnewbies:~/bind$ tree b
b
└── a.txt
<span class="token number">0</span> directories, <span class="token number">1</span> <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从结果我们可以看到，b 目录下原先的内容被隐藏，取而代之的是 a 目录下的内容。</p><p>然后，我们修改 b 目录下的内容，修改完毕后，从 b 目录上卸载掉 a 目录。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/bind$ <span class="token builtin class-name">echo</span> hello, a from b <span class="token operator">&gt;</span> b/a.txt
phl@kernelnewbies:~/bind$ <span class="token function">sudo</span> <span class="token function">umount</span> b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们读取一下 a 目录中 a.txt，看看其内容是否被改变。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/bind$ <span class="token function">cat</span> a/a.txt
hello, a from b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>从结果我们可以看到，a 目录中的内容确实被当 a 被 bind mount 到 b 时对 b 目录的操作所修改了。</p><p>bind mount 在容器技术中有很重要的用途，后文会有涉及。</p><h4 id="1-3-4-mount-namespace简介">1.3.4.mount namespace 简介</h4><p>mount namespace 用来隔离文件系统的挂载点信息，使得不同的 mount namespace 拥有自己独立的挂载点信息。不同的 namespace 之间不会相互影响，其在 unshare 中的选项为 --mount。</p><p>当用 unshare 创建新的 mount namespace 时，新创建的 namespace 将拷贝一份老 namespace 里的挂载点信息，但从这之后，他们就没有关系了。这是 unshare 将新 namespace 里面的所有挂载点的传播状态设置为 private 实现的。通过 mount 和 umount 增加和删除各自 mount namespace 里面的挂载点都不会相互影响。</p><p>下面我们将演示 mount namespace 的用法。首先，我们准备需要的目录和文件，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">mkdir</span> -p hds/hd1 hds/hd2 <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">cd</span> hds

phl@kernelnewbies:~/hds$ <span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>/dev/zero <span class="token assign-left variable">bs</span><span class="token operator">=</span>1M <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">of</span><span class="token operator">=</span>hd1.img <span class="token operator">&amp;&amp;</span> mkfs.ext2 hd1.img
phl@kernelnewbies:~/hds$ <span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>/dev/zero <span class="token assign-left variable">bs</span><span class="token operator">=</span>1M <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">of</span><span class="token operator">=</span>hd2.img <span class="token operator">&amp;&amp;</span> mkfs.ext2 hd2.img

phl@kernelnewbies:~$ tree <span class="token builtin class-name">.</span>
<span class="token builtin class-name">.</span>
├── hd1
├── hd1.img
├── hd2
└── hd2.img
<span class="token number">2</span> directories, <span class="token number">2</span> files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，我们在全局的 mount namespace 中挂载 hd1.img 到 hd1 目录，然后查看该 mount namespace 中的挂载点信息与 mount namespace id。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/hds$ <span class="token function">sudo</span> <span class="token function">mount</span> hd1.img hd1
phl@kernelnewbies:~/hds$ <span class="token function">cat</span> /proc/self/mountinfo <span class="token operator">|</span> <span class="token function">grep</span> hd
<span class="token number">556</span> <span class="token number">27</span> <span class="token number">7</span>:18 / /home/phl/hds/hd1 rw,relatime shared:372 - ext2 /dev/loop18 rw

phl@kernelnewbies:~/hds$ <span class="token function">sudo</span> readlink /proc/<span class="token variable">$$</span>/ns/mnt
mnt:<span class="token punctuation">[</span><span class="token number">4026531840</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，执行 unshare 命令创建一个新的 mount namespace 并查看该 mount namespace id 和挂载点信息。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/hds$ <span class="token function">sudo</span> unshare --uts --mount /bin/bash
root@kernelnewbies:~/hds<span class="token comment"># cat /proc/self/mountinfo | grep hd</span>
<span class="token number">739</span> <span class="token number">570</span> <span class="token number">7</span>:18 / /home/phl/hds/hd1 rw,relatime - ext2 /dev/loop18 rw

root@kernelnewbies:~/hds<span class="token comment"># readlink /proc/$$/ns/mnt</span>
mnt:<span class="token punctuation">[</span><span class="token number">4026532180</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从结果我们可以看到，新 mount namespace 中的挂载点信息与全局 mountnamespace 中的挂载点信息基本一致，一些挂载选项（如传播状态）变化了。新的 mount namespace id 与全局 mount namespace id 是不一样的。</p><p>然后，我们在新的 mount namespace 中挂载 hd2.img 到 hd2 目录，并查看挂载点信息。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@kernelnewbies:~/hds<span class="token comment"># mount hd2.img hd2</span>
root@kernelnewbies:~/hds<span class="token comment"># cat /proc/self/mountinfo | grep hd</span>
<span class="token number">739</span> <span class="token number">570</span> <span class="token number">7</span>:18 / /home/phl/hds/hd1 rw,relatime - ext2 /dev/loop18 rw
<span class="token number">740</span> <span class="token number">570</span> <span class="token number">7</span>:19 / /home/phl/hds/hd2 rw,relatime - ext2 /dev/loop19 rw<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>从结果我们可以看到，新 mount namespace 中有 hd1 和 hd2 这两个挂载点。现在启动一个新的 Shell 窗口，查看全局 mount namespace 中的挂载点信息。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/hds$ <span class="token function">cat</span> /proc/self/mountinfo <span class="token operator">|</span> <span class="token function">grep</span> hd
<span class="token number">556</span> <span class="token number">27</span> <span class="token number">7</span>:18 / /home/phl/hds/hd1 rw,relatime shared:372 - ext2 /dev/loop18 rw<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>从结果我们可以看到，全局 mount namespace 中的挂载点信息只有 hd1，而没有 hd2。这说明在新 mount namespace 中进行挂载 / 卸载操作不会影响其他 mount namespace 中的挂载点信息。</p><p>mount namespace 只隔离挂载点信息，并不隔离挂载点下面的文件信息。对于多个 mount namespace 都能看到的挂载点，如果在一个 namespace 中修改了挂载点下面的文件，其他 namespace 也能感知到。下面，我们在新建的 mount namespace 中创建一个文件，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@kernelnewbies:~/hds<span class="token comment"># echo hello from new mount namespace &gt; hd1/hello.txt</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在新启动的 Shell 中，查看 hd1 目录并读取 hd1/hello.txt 文件。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/hds$ tree hd1
hd1
├── hello.txt
└── lost+found <span class="token punctuation">[</span>error opening dir<span class="token punctuation">]</span>
<span class="token number">1</span> directory, <span class="token number">1</span> <span class="token function">file</span>

phl@kernelnewbies:~/hds$ <span class="token function">cat</span> hd1/hello.txt
hello from new <span class="token function">mount</span> namespace<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从结果我们可以看到，在全局 mount namespace 中，我们可以读取到在新建的 mount namespace 中创建的文件。</p><h4 id="1-3-5-docker-sh">1.3.5.docker.sh</h4><p>有了以上关于 mount namespace 的知识，我们就可以将 mount namespace 加入到 docker.sh 中了。mount namespace 将放在 docker.sh 中，带下划线的行是我们为实现 mount namespace 而修改的代码。修改后的 docker.sh 脚本如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">..</span>.
unshare --uts --mount ./container.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>从上述代码我们可以看到，我们仅仅是在调用 unshare 时加入 --mount 选项，就可为 docker.sh 引入了 mount namespace 功能。</p><h3 id="1-4-pid-namespace">1.4.pid namespace</h3><h4 id="1-4-1-unshare的-fork选项">1.4.1.unshare 的 --fork 选项</h4><p>unshare 有一个选项 --fork，当执行 unshare 时，如果没有这个选项，unshare 会直接 exec 新命令，也就是说 unshare 变成了新命令。如果带有 --fork 选项，unshare 会 fork 一个子进程，该子进程 exec 新命令，unshare 是该子进程的父进程。我们分别不带 --fork 和带 --fork 来执行 unshare，然后查看进程之间的关系。</p><p>首先，我们不带 --fork 选项执行 unshare，并查看当前 Shell 的进程 id。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">sudo</span> unshare --uts /bin/bash
root@kernelnewbies:~/hds<span class="token comment"># echo $$</span>
<span class="token number">11699</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此时 unshare 会创建一个新的 uts namespace，然后 exec /bin/bash。我们启动一个新 Shell，然后使用 pstree 查看进程间关系，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/hds$ pstree -p <span class="token operator">|</span> <span class="token function">grep</span> <span class="token number">11699</span>
sudo<span class="token punctuation">(</span><span class="token number">11698</span><span class="token punctuation">)</span>---bash<span class="token punctuation">(</span><span class="token number">11699</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>从结果我们可以看到，sudo fork 出一个子进程，该子进程执行 unshare。unshare 创建了新 uts namespace 后，exec 了 /bin/bash，也就是说 unshare 变成了 /bin/bash。</p><p>然后，我们带 --fork 选项执行 unshare，并查看当前 Shell 的进程 id。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/hds$ <span class="token function">sudo</span> unshare --uts --fork /bin/bash
root@kernelnewbies:~/hds<span class="token comment"># echo $$</span>
<span class="token number">11866</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此时 unshare 会创建一个新的 uts namespace，然后 fork 出一个子进程，该子进程 exec /bin/bash。我们启动一个新 Shell，然后使用 pstree 查看进程间关系，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/hds$ pstree -p <span class="token operator">|</span> <span class="token function">grep</span> <span class="token number">11866</span>
sudo<span class="token punctuation">(</span><span class="token number">11864</span><span class="token punctuation">)</span>---unshare<span class="token punctuation">(</span><span class="token number">11865</span><span class="token punctuation">)</span>---bash<span class="token punctuation">(</span><span class="token number">11866</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>从结果我们可以看到，sudo fork 出一个子进程，该子进程执行命令 unshare。unshare 创建了新 uts namespace 后，fork 出一个子进程，该子进程 exec /bin/bash，也就是说 unshare 变成了新的 /bin/bash 进程的父进程。</p><h4 id="1-4-2-pid-namespace简介">1.4.2.pid namespace 简介</h4><p>pid namespace 用来隔离进程 pid 空间，使得不同 pid namespace 里的进程 pid 可以重复且相互之间不影响。进程所属的 pid namespace 在创建的时候就确定了，无法更改，因此需要 --fork 选项来创建一个新进程，然后将该新进程加入新建的 pid namespace 中。pid namespace 在 unshare 中的选项为 --pid。</p><p>unshare 在创建 pid namespace 时需同时提供 --pid 与 --fork 选项。unshare 本身会加入全局的 pid namespace，其 fork 出的子进程会加入新建的 pid namespace。</p><p>首先，我们查看全局 pid namespace id，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">sudo</span> readlink /proc/<span class="token variable">$$</span>/ns/pid
pid:<span class="token punctuation">[</span><span class="token number">4026531836</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后，执行 unshare 命令创建一个新的 pid namespace 并查看该 pid namespace id。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">sudo</span> unshare --mount --pid --fork /bin/bash
root@kernelnewbies:~<span class="token comment"># readlink /proc/$$/ns/pid</span>
pid:<span class="token punctuation">[</span><span class="token number">4026531836</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>从结果我们可以看到，新创建的进程也处于全局 pid namespace 中，而不是新的 pid namespace。</p><p>出现这种情形是因为当前的 /proc 文件系统是老的。我们查看一下 $$ 的值，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@kernelnewbies:~<span class="token comment"># echo $$</span>
<span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>从结果我们可以看到，$$ 的值为 1，但是 /proc 文件系统却是老的，因此我们查看的实际是 init 进程所属的 pid namespace，当然是全局 pid namespace 了。</p><p>重新挂载 /proc 文件系统，这也是 unshare 执行时带 --mount 选项的原因，只有这样，重新挂载 /proc 文件系统时，不会搞乱整个系统。再次查看新进程所属的 pid namespace，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@kernelnewbies:~<span class="token comment"># mount -t proc proc /proc</span>
root@kernelnewbies:~<span class="token comment"># readlink /proc/$$/ns/pid</span>
pid:<span class="token punctuation">[</span><span class="token number">4026532182</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>从结果我们可以看到，新进程的 pid namespace 与全局 pid namespace 的 id 不同。</p><p>接下来，我们再来查看一下新 pid namespace 中的进程信息。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@kernelnewbies:~<span class="token comment"># ps -ef</span>
<span class="token environment constant">UID</span>        PID  <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMD
root         <span class="token number">1</span>     <span class="token number">0</span>  <span class="token number">0</span> <span class="token number">19</span>:03 pts/1    00:00:00 /bin/bash
root        <span class="token number">10</span>     <span class="token number">1</span>  <span class="token number">0</span> <span class="token number">19</span>:03 pts/1    00:00:00 <span class="token function">ps</span> -e<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>从结果我们可以看到，当前 pid namespace 中只有 2 个进程，看不到全局 pid namespace 里面的其他进程。我们通过 unshare 执行的进程 pid 为 1，也就是说该进程成了新 pid namespace 中的 init 进程。</p><h4 id="1-4-3-pid嵌套">1.4.3.pid 嵌套</h4><p>pid namespace 可以嵌套，也就是说有父子关系，在当前 pid namespace 里面创建的所有新的 pid namespace 都是当前 pid namespace 的子 pid namespace。</p><p>首先，我们创建 3 个嵌套的 pid namespace，并查看每个 pid namespace id。--mount-proc 选项用于自动挂载 /proc 文件系统，省去了手动挂载 /proc 文件系统的操作。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">sudo</span> readlink /proc/<span class="token variable">$$</span>/ns/pid
pid:<span class="token punctuation">[</span><span class="token number">4026531836</span><span class="token punctuation">]</span>

phl@kernelnewbies:~$ <span class="token function">sudo</span> unshare --uts --mount --pid --mount-proc --fork /bin/bash
root@kernelnewbies:~<span class="token comment"># readlink /proc/$$/ns/pid</span>
pid:<span class="token punctuation">[</span><span class="token number">4026532182</span><span class="token punctuation">]</span>

root@kernelnewbies:~<span class="token comment"># unshare --uts --mount --pid --mount-proc --fork /bin/bash</span>
root@kernelnewbies:~<span class="token comment"># readlink /proc/$$/ns/pid</span>
pid:<span class="token punctuation">[</span><span class="token number">4026532185</span><span class="token punctuation">]</span>

root@kernelnewbies:~<span class="token comment"># unshare --uts --mount --pid --mount-proc --fork /bin/bash</span>
root@kernelnewbies:~<span class="token comment"># readlink /proc/$$/ns/pid</span>
pid:<span class="token punctuation">[</span><span class="token number">4026532188</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，我们启动一个新 Shell，然后使用 pstree 查看进程间关系。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ pstree -lp <span class="token operator">|</span> <span class="token function">grep</span> unshare
sudo<span class="token punctuation">(</span><span class="token number">12547</span><span class="token punctuation">)</span>---unshare<span class="token punctuation">(</span><span class="token number">12548</span><span class="token punctuation">)</span>---bash<span class="token punctuation">(</span><span class="token number">12549</span><span class="token punctuation">)</span>---unshare<span class="token punctuation">(</span><span class="token number">12579</span><span class="token punctuation">)</span>---bash<span class="token punctuation">(</span><span class="token number">12580</span><span class="token punctuation">)</span>---unshare<span class="token punctuation">(</span><span class="token number">12593</span><span class="token punctuation">)</span>---bash<span class="token punctuation">(</span><span class="token number">12594</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使用 cat /proc/[pid]/status | grep NSpid 可查看某进程在当前 pid namespace 及子孙 pid namespace 中的 pid。我们在全局 pid namespace 中查看上述各进程在各 pid namespace 中的 pid，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">cat</span> /proc/12594/status <span class="token operator">|</span> <span class="token function">grep</span> NSpid
NSpid: <span class="token number">12594</span> <span class="token number">21</span> <span class="token number">11</span> <span class="token number">1</span>

phl@kernelnewbies:~$ <span class="token function">cat</span> /proc/12593/status <span class="token operator">|</span> <span class="token function">grep</span> NSpid
NSpid: <span class="token number">12593</span> <span class="token number">20</span> <span class="token number">10</span>

phl@kernelnewbies:~$ <span class="token function">cat</span> /proc/12580/status <span class="token operator">|</span> <span class="token function">grep</span> NSpid
NSpid: <span class="token number">12580</span> <span class="token number">11</span> <span class="token number">1</span>

phl@kernelnewbies:~$ <span class="token function">cat</span> /proc/12579/status <span class="token operator">|</span> <span class="token function">grep</span> NSpid
NSpid: <span class="token number">12579</span> <span class="token number">10</span>

phl@kernelnewbies:~$ <span class="token function">cat</span> /proc/12549/status <span class="token operator">|</span> <span class="token function">grep</span> NSpid
NSpid: <span class="token number">12549</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面我们将以上进程在各 pid namespace 中的 pid，整理成表格。表格信息如下：</p><p><img src="/medias_webp/loading.svg" data-original="https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2022/03/1820220318143156.png" alt="使用 Shell 脚本实现 Docker"></p><p>我们以最后一行为例进行介绍，最后一行有 4 个 pid，这 4 个 pid 其实是同一个进程。这个进程在 4 个 pid namespace 中都可以被看到，且其在 4 个 pid namespace 中的 pid 各不相同。</p><h4 id="1-4-4-docker-sh">1.4.4.docker.sh</h4><p>有了以上关于 pid namespace 的知识，我们就可以将 pid namespae 加入到 docker.sh 中了。pid namespace 将放在 docker.sh 中，带下划线的行是我们为实现 pid namespace 而修改的代码。修改后的 docker.sh 脚本如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">..</span>.
unshare --uts --mount --pid --fork ./container.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>从上述代码我们可以看到，我们仅仅是在调用 unshare 时加入 --pid 和 --fork 选项，就可为 docker.sh 引入了 pid namespace 功能。</p><p>然后，我们需要重新挂载 /proc 文件系统。重新挂载 /proc 文件系统的功能将放在 container.sh 中，带下划线的行是我们为重新挂载 /proc 文件系统而新添的代码。修改后的 container.sh 脚本如下如下所示：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">hostname</span> <span class="token variable">$container</span>
<span class="token function">mount</span> -t proc proc /proc
<span class="token builtin class-name">exec</span> <span class="token variable">$program</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>现在，我们运行 docker.sh，并查看当前的进程信息。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/docker.sh$ <span class="token function">sudo</span> ./docker.sh -c run -m 100M -C dreamland -I ubuntu1604 -V data1 -P /bin/bash
root@dreamland:~/docker.sh<span class="token comment"># ps -ef</span>
<span class="token environment constant">UID</span>        PID  <span class="token environment constant">PPID</span>  C STIME TTY          TIME CMD
root         <span class="token number">1</span>     <span class="token number">0</span>  <span class="token number">0</span> <span class="token number">17</span>:31 pts/1    00:00:00 /bin/bash
root        <span class="token number">16</span>     <span class="token number">1</span>  <span class="token number">0</span> <span class="token number">17</span>:31 pts/1    00:00:00 <span class="token function">ps</span> -ef<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从结果我们可看出，当前进程只有两个，不再有主机上的其他进程。</p><h2 id="2-CGroups">2.CGroups</h2><h3 id="2-1-CGroups简介">2.1.CGroups 简介</h3><p>CGroups 是一种将进程分组，并以组为单位对进程实施资源限制的技术。每个组都包含以下几类信息：</p><ul><li>进程列表</li><li>资源 A 限制</li><li>资源 B 限制</li><li>资源 C 限制</li><li>...</li></ul><p>我们将以常见的 CPU 资源及内存资源为例进行介绍。以下的信息将使进程号为 1001、1002、2008、3306 的四个进程总共只能使用一个 CPU 核心；总共最多使用 25% 的 CPU 资源；总共最多使用 100M 内存，这样的一个分组被称为 cgroup。</p><p><img src="/medias_webp/loading.svg" data-original="https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2022/03/1820220318143103.png" alt="使用 Shell 脚本实现 Docker"></p><p>上面的介绍只是说明了要将何种资源限制施加于哪些进程，并未说明资源限制是如何施加到进程上。具体施加资源限制的过程需要 subsystem 来帮忙。subsystem 读取 cgroup 中的资源限制和进程列表，然后将这些资源限制施加到这些进程上。常见的 subsystem 包括如下几种：</p><ul><li>cpu</li><li>memory</li><li>pids</li><li>devices</li><li>blkio</li><li>net_cls</li></ul><p>每个 subsystem 只读取与其相关的资源限制，然后施加到进程上。例如：memory 子系统只读取内存限制，而 cpu 子系统只读取 cpu 限制。</p><p>cgroup 被组织成树，如下图所示：</p><p><img src="/medias_webp/loading.svg" data-original="https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2022/03/1820220318143057.png" alt="使用 Shell 脚本实现 Docker"></p><p>采用树状结构可以方便地实现资源限制继承，一个 cgroup 中的资源限制将作用于该 cgroup 及其子孙 cgroup 中的进程。例如：图中 13001、10339、2999 受到 A、B、C、D 四个 cgroup 中的资源限制。这样的一个树状结构被称为 hierarchy。</p><p>hierarchy 中包含了系统中所有的进程，它们分布于各个 cgroup 中。在 hierarchy 中，一个进程必须属于且只属于一个 cgroup，这样才能保证对进程施加的资源限制不会遗漏也不会冲突。</p><p>要想让一个 subsystem 读取 hierarchy 中各 cgroup 的资源限制，并施加于其中的进程需要将 subsystem 和 hierarchy 关联起来。subsystem 与 hierarchy 的关系如下：</p><ul><li>系统中可以有多个 hierarchy</li><li> 一个 hierarchy 可以关联 0 个或多个 subsystem，当关联 0 个 subsystem 时，该 hierarchy 只是对进程进行分类</li><li>一个 subsystem 最多关联到一个 hierarchy，因为每个 hierarchy 都包含系统中所有的进程，若一个 subsystem 关联到了多个 hierarchy，对同一进程将有多种资源限制，这是不对的</li></ul><p>系统使用 CGroups 通常有两种形式：一种是创建一个 hierarchy，将所有的 subsystem 关联到其上，在这个 hierarchy 上配置各种资源限制；另一种是为每一个 subsystem 创建一个 hierarchy，并将该 subsystem 关联到其上，每个 hierarchy 只对一种资源进行限制。后一种比较清晰，得到了更普遍的采用。</p><p>CGroups 不像大多数的技术那样提供 API 或命令之类的用户接口，而是提供给用户一个虚拟文件系统，该虚拟文件系统类型为 cgroup。一个挂载后的 cgroup 文件系统就是一个 hierarchy，文件系统中的一个目录就是一个 cgroup，目录中的文件代表了进程列表或者资源限制信息。文件系统是树状结构，其各个目录之间的父子关系就代表了 cgroup 之间的继承关系。挂载 cgroup 虚拟文件系统后，通过在该文件系统上创建目录、写进程列表文件、写资源限制文件就可以操作 CGroups。</p><p>下面，我们通过实验学习一下 CGroups 的用法。首先，我们挂载一个 cgroup 虚拟文件系统，该文件系统不与任何 subsystem 关联，仅仅是将进程进行分类。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">mkdir</span> -p cg/test
<span class="token comment"># -o none,name=test 表示该cgroup文件系统不与任何子系统关联</span>
<span class="token comment"># 该文件系统用name=test来标识</span>
phl@kernelnewbies:~$ <span class="token function">sudo</span> <span class="token function">mount</span> -t cgroup -o none,name<span class="token operator">=</span>test <span class="token builtin class-name">test</span> cg/test
phl@kernelnewbies:~$ tree cg/test
cg/test
├── cgroup.clone_children
├── cgroup.procs
├── cgroup.sane_behavior
├── notify_on_release
├── release_agent
└── tasks
<span class="token number">0</span> directories, <span class="token number">6</span> files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>挂载 cgroup 文件系统后，该 cgroup 文件系统的根目录下会生成许多文件，该根目录被称为 root cgroup。cgroup.procs 里面存放的是当前 cgroup 中的所有进程 id，由于该 hierarchy 中只有一个 cgroup，所以这个文件包含了系统中所有的进程 id。其他的文件与 cgroups 基本功能关系不大，暂时可以忽略。</p><p>在 cgroup 文件系统中，创建一个目录就会创建一个 cgroup。下面我们将会演示如何创建下面这样的 hierarchy：</p><p><img src="/medias_webp/loading.svg" data-original="https://cdn.jsdelivr.net/gh/appotry/cloudimg@latest/data/2022/03/1820220318143054.png" alt="使用 Shell 脚本实现 Docker"></p><p>命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">sudo</span> <span class="token function">mkdir</span> -p cg/test/test1/test11
phl@kernelnewbies:~$ <span class="token function">sudo</span> <span class="token function">mkdir</span> -p cg/test/test2/test22
phl@kernelnewbies:~$ tree cg/test
cg/test
├── cgroup.clone_children
├── cgroup.procs
├── cgroup.sane_behavior
├── notify_on_release
├── release_agent
├── tasks
├── test1
│   ├── cgroup.clone_children
│   ├── cgroup.procs
│   ├── notify_on_release
│   ├── tasks
│   └── test11
│       ├── cgroup.clone_children
│       ├── cgroup.procs
│       ├── notify_on_release
│       └── tasks
└── test2
    ├── cgroup.clone_children
    ├── cgroup.procs
    ├── notify_on_release
    ├── tasks
    └── test22
        ├── cgroup.clone_children
        ├── cgroup.procs
        ├── notify_on_release
        └── tasks

<span class="token number">4</span> directories, <span class="token number">22</span> files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从结果我们可以看到，我们创建了相应的目录后，这些目录下自动出现了包含 cgroup 信息的目录及文件。</p><p>删除 cgroup 时只需删除该 cgroup 所在的目录即可。下面我们将删除 test11 cgroup，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">sudo</span> <span class="token function">rmdir</span> cg/test/test1/test11
phl@kernelnewbies:~$ tree cg/test
cg/test
├── cgroup.clone_children
├── cgroup.procs
├── cgroup.sane_behavior
├── notify_on_release
├── release_agent
├── tasks
├── test1
│   ├── cgroup.clone_children
│   ├── cgroup.procs
│   ├── notify_on_release
│   └── tasks
└── test2
    ├── cgroup.clone_children
    ├── cgroup.procs
    ├── notify_on_release
    ├── tasks
    └── test22
        ├── cgroup.clone_children
        ├── cgroup.procs
        ├── notify_on_release
        └── tasks

<span class="token number">3</span> directories, <span class="token number">18</span> files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每个 cgroup 下面都有一个 cgroup.procs 文件，该文件里面包含当前 cgroup 里面的所有进程 id。只要将某个进程的 id 写入该文件，即可将该进程加入到该 cgroup 中。下面，我们将当前的 bash 加入到 test22 cgroup 中，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token builtin class-name">echo</span> <span class="token variable">$$</span>
<span class="token number">3894</span>
phl@kernelnewbies:~$ <span class="token function">sudo</span> <span class="token function">sh</span> -c <span class="token string">"echo 3894 &gt; cg/test/test2/test22/cgroup.procs"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>/proc/[pid]/cgroup 包含了某个进程所在的 cgroup 信息。下面，我们查看一下当前 bash 进程所在的 cgroup 信息，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">cat</span> /proc/3894/cgroup
<span class="token number">13</span>:name<span class="token operator">=</span>test:/test2/test22
<span class="token number">12</span>:freezer:/
<span class="token number">11</span>:perf_event:/
<span class="token number">10</span>:blkio:/user.slice
<span class="token number">9</span>:devices:/user.slice
<span class="token number">8</span>:hugetlb:/
<span class="token number">7</span>:cpu,cpuacct:/user.slice
<span class="token number">6</span>:net_cls,net_prio:/
<span class="token number">5</span>:memory:/user.slice
<span class="token number">4</span>:rdma:/
<span class="token number">3</span>:pids:/user.slice/user-1001.slice/session-4.scope
<span class="token number">2</span>:cpuset:/
<span class="token number">1</span>:name<span class="token operator">=</span>systemd:/user.slice/user-1001.slice/session-4.scope
<span class="token number">0</span>::/user.slice/user-1001.slice/session-4.scope<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从结果我们可以看到，当前 bash 进程加入了多个 cgroup，其中带下划线的行为我们刚刚加入的 cgroup。</p><p>要想将 hierarchy 与子系统关联起来，需要在 - o 选项中指定子系统名称。下面演示了如何将 memory 子系统与新挂载的 cgroup 文件系统关联起来。代码如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">sudo</span> <span class="token function">mkdir</span> cg/memory
phl@kernelnewbies:~$ <span class="token function">sudo</span> <span class="token function">mount</span> -t cgroup -o memory memcg cg/memory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>由于很多发行版的操作系统已经为我们配置好了这些 cgroup 文件系统，我们应当直接使用这些已经挂在好的文件系统，不需要自己去挂载。</p><p>另外，当创建子进程时，子进程会自动加入父进程所在的 cgroup。</p><h3 id="2-2-限制内存">2.2. 限制内存</h3><h4 id="2-2-1-用CGroups限制内存">2.2.1. 用 CGroups 限制内存</h4><p>下面我们将介绍演示 CGroups 如何限制进程使用的内存资源，我们以内存为例进行讲解。</p><p>Ubuntu18.04 已经为我们挂载了一个关联 memory 子系统的 cgroup 虚拟文件系统。我们用 mount 命令查看一下该系统挂载到了何处，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">mount</span> <span class="token operator">|</span> <span class="token function">grep</span> cgroup
tmpfs on /sys/fs/cgroup <span class="token builtin class-name">type</span> tmpfs <span class="token punctuation">(</span>ro,nosuid,nodev,noexec,mode<span class="token operator">=</span><span class="token number">755</span><span class="token punctuation">)</span>
cgroup on /sys/fs/cgroup/unified <span class="token builtin class-name">type</span> cgroup2 <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,nsdelegate<span class="token punctuation">)</span>
cgroup on /sys/fs/cgroup/systemd <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,xattr,name<span class="token operator">=</span>systemd<span class="token punctuation">)</span>
cgroup on /sys/fs/cgroup/cpuset <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,cpuset<span class="token punctuation">)</span>
cgroup on /sys/fs/cgroup/pids <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,pids<span class="token punctuation">)</span>
cgroup on /sys/fs/cgroup/rdma <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,rdma<span class="token punctuation">)</span>
cgroup on /sys/fs/cgroup/memory <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,memory<span class="token punctuation">)</span>
cgroup on /sys/fs/cgroup/net_cls,net_prio <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,net_cls,net_prio<span class="token punctuation">)</span>
cgroup on /sys/fs/cgroup/cpu,cpuacct <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,cpu,cpuacct<span class="token punctuation">)</span>
cgroup on /sys/fs/cgroup/hugetlb <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,hugetlb<span class="token punctuation">)</span>
cgroup on /sys/fs/cgroup/devices <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,devices<span class="token punctuation">)</span>
cgroup on /sys/fs/cgroup/blkio <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,blkio<span class="token punctuation">)</span>
cgroup on /sys/fs/cgroup/perf_event <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,perf_event<span class="token punctuation">)</span>
cgroup on /sys/fs/cgroup/freezer <span class="token builtin class-name">type</span> cgroup <span class="token punctuation">(</span>rw,nosuid,nodev,noexec,relatime,freezer<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该系统挂载到了 /sys/fs/cgroup/memory 目录下。我们在该 hierarchy 中创建一个 test cgroup 并查看该 cgroup 的目录结构，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">sudo</span> <span class="token function">mkdir</span> /sys/fs/cgroup/memory/test
phl@kernelnewbies:~$ tree /sys/fs/cgroup/memory/test
/sys/fs/cgroup/memory/test
├── cgroup.clone_children
├── cgroup.event_control
├── cgroup.procs
├── memory.failcnt
├── memory.force_empty
├── memory.kmem.failcnt
├── memory.kmem.limit_in_bytes
├── memory.kmem.max_usage_in_bytes
├── memory.kmem.slabinfo
├── memory.kmem.tcp.failcnt
├── memory.kmem.tcp.limit_in_bytes
├── memory.kmem.tcp.max_usage_in_bytes
├── memory.kmem.tcp.usage_in_bytes
├── memory.kmem.usage_in_bytes
├── memory.limit_in_bytes
├── memory.max_usage_in_bytes
├── memory.move_charge_at_immigrate
├── memory.numa_stat
├── memory.oom_control
├── memory.pressure_level
├── memory.soft_limit_in_bytes
├── memory.stat
├── memory.swappiness
├── memory.usage_in_bytes
├── memory.use_hierarchy
├── notify_on_release
└── tasks
<span class="token number">0</span> directories, <span class="token number">27</span> files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从结果我们可以看到，新建的 test cgroup 中有许多文件，这些文件中存放着资源限制信息。其中 memory.limit_in_bytes 里面存放的是该 cgroup 中的进程能够使用的内存额度。</p><p>下面，我们将当前 bash 加入到 test cgroup 中并查看当前 bash 所属的 cgroup 信息。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token builtin class-name">echo</span> <span class="token variable">$$</span>
<span class="token number">2984</span>
phl@kernelnewbies:~$ <span class="token function">sudo</span> <span class="token function">sh</span> -c <span class="token string">"echo 2984 &gt; /sys/fs/cgroup/memory/test/cgroup.procs"</span>
phl@kernelnewbies:~$ <span class="token function">cat</span> /proc/2984/cgroup
<span class="token number">12</span>:devices:/user.slice
<span class="token number">11</span>:hugetlb:/
<span class="token number">10</span>:memory:/test
<span class="token number">9</span>:rdma:/
<span class="token number">8</span>:perf_event:/
<span class="token number">7</span>:blkio:/user.slice
<span class="token number">6</span>:cpu,cpuacct:/user.slice
<span class="token number">5</span>:pids:/user.slice/user-1001.slice/session-4.scope
<span class="token number">4</span>:freezer:/
<span class="token number">3</span>:cpuset:/
<span class="token number">2</span>:net_cls,net_prio:/
<span class="token number">1</span>:name<span class="token operator">=</span>systemd:/user.slice/user-1001.slice/session-4.scope
<span class="token number">0</span>::/user.slice/user-1001.slice/session-4.scope<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从结果我们可以看到，当前 bash 所属的 memory cgroup 变为了 /test，该目录为一个相对于 root cgroup 的相对路径。</p><p>然后，将 100M 写入 test cgroup 中的 memory.limit_in_bytes 文件中，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">sudo</span> <span class="token function">sh</span> -c <span class="token string">"echo 100M &gt; /sys/fs/cgroup/memory/test/memory.limit_in_bytes"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们在当前 bash 中启动一个占用 300M 进程的 stress 进程，该 stress 进程是 bash 的子进程，其与 bash 进程都在 test cgroup 中。命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ stress --vm <span class="token number">1</span> --vm-bytes 300M --vm-keep<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动一个新的 Shell 窗口，执行 top 命令查看 stress 进程占用的内存。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND
<span class="token number">14216</span> root      <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">315440</span> <span class="token number">101224</span>    <span class="token number">264</span> D <span class="token number">27.7</span>  <span class="token number">2.5</span>   <span class="token number">0</span>:02.66 stress<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>从结果我们可以看到，stress 进程占用了 2.5% 的内存。我的电脑的内存为 4G，4G * 2.5% = 100M，stress 进程确实受到了 cgroup 中设置的内存额度的限制。</p><h4 id="2-2-2-docker-sh">2.2.2.docker.sh</h4><p>下有了以上关于 CGroups 的知识，我们就可以将限制内存的功能加入到 docker.sh 中了。限制内存的功能将放在 container.sh 中，带下划线的行是我们为实现限制内存而新添的代码。修改后的 container.sh 脚本如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">hostname</span> <span class="token variable">$container</span>
<span class="token function">mkdir</span> -p /sys/fs/cgroup/memory/<span class="token variable">$container</span>
<span class="token builtin class-name">echo</span> <span class="token variable">$$</span> <span class="token operator">&gt;</span> /sys/fs/cgroup/memory/<span class="token variable">$container</span>/cgroup.procs
<span class="token builtin class-name">echo</span> <span class="token variable">$memory</span> <span class="token operator">&gt;</span> /sys/fs/cgroup/memory/<span class="token variable">$container</span>/memory.limit_in_bytes
<span class="token function">mount</span> -t proc proc /proc
<span class="token builtin class-name">exec</span> <span class="token variable">$program</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，我们根据容器的名字创建 cgroup，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> -p /sys/fs/cgroup/memory/<span class="token variable">$container</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后，我们将当前 bash 加入到我们创建的 cgroup 中，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token variable">$$</span> <span class="token operator">&gt;</span> /sys/fs/cgroup/memory/<span class="token variable">$container</span>/cgroup.procs<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后，我们将内存限制写入新 cgroup 的 memory.limit_in_bytes 文件中，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token variable">$memory</span> <span class="token operator">&gt;</span> /sys/fs/cgroup/memory/<span class="token variable">$container</span>/memory.limit_in_bytes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在，我们运行 docker.sh，并启动一个占用 300M 进程的 stress 进程。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/docker.sh$ <span class="token function">sudo</span> ./docker.sh -c run -m 100M -C dreamland -I ubuntu1604 -V data1 -P /bin/bash
root@dreamland:~/docker.sh<span class="token comment"># stress --vm 1 --vm-bytes 300M --vm-keep</span>
stress: info: <span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span> dispatching hogs: <span class="token number">0</span> cpu, <span class="token number">0</span> io, <span class="token number">1</span> vm, <span class="token number">0</span> hdd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>启动一个新的 Shell 窗口，执行 top 命令查看 stress 进程占用的内存。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PID <span class="token environment constant">USER</span>      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND
<span class="token number">14216</span> root      <span class="token number">20</span>   <span class="token number">0</span>  <span class="token number">315440</span> <span class="token number">101224</span>    <span class="token number">264</span> D <span class="token number">27.7</span>  <span class="token number">2.5</span>   <span class="token number">0</span>:02.66 stress<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>从结果我们可以看到，容器内的 stress 进程只使用了 100M 的内存。</p><h2 id="3-切换根文件系统">3. 切换根文件系统</h2><h3 id="3-1-根文件系统">3.1. 根文件系统</h3><p>在容器技术中，根文件系统可为容器进程提供一个与主机不一致的文件系统环境。举个例子，主机为 Ubuntu 18.04，创建的容器采用 Ubuntu 16.04 的根文件系统，那么容器运行时所用的软件及其依赖库、配置文件等都是 Ubuntu 16.04 的。尽管该容器使用的内核是仍旧是 Ubuntu 18.04 的，但应用软件的表现却与 Ubuntu 16.04 一致，从虚拟化的角度来说该容器就是一个 Ubuntu 16.04 系统。</p><p>debootstrap 是 Ubuntu 下的一个工具，用来构建根文件系统。生成的目录符合 Linux 文件系统标准，即包含了 /boot、/etc、/bin、/usr 等目录。debootstrap 的安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> <span class="token function">debootstrap</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面我们通过 debootstrap 构建 Ubuntu 16.04 的根文件系统。为了清晰，我们在 images 目录下生成根文件系统。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/docker.sh$ <span class="token function">mkdir</span> images
phl@kernelnewbies:~/docker.sh$ <span class="token builtin class-name">cd</span> images
phl@kernelnewbies:~/docker.sh/images$ <span class="token function">sudo</span> <span class="token function">debootstrap</span> --arch amd64 xenial ./ubuntu1604<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>制作根文件系统需要从服务器下载很多文件，很耗时，请耐心等待。当文件系统制作好后，可以使用 tree 命令查看生成的根文件系统。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/docker.sh/images$ tree -L <span class="token number">1</span> ubuntu1604/
ubuntu1604/
├── bin
├── boot
├── dev
├── etc
├── home
├── lib
├── lib64
├── media
├── mnt
├── old_root
├── opt
├── proc
├── root
├── run
├── sbin
├── srv
├── sys
├── tmp
├── usr
└── var
<span class="token number">20</span> directories, <span class="token number">0</span> files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个根文件系统与 Linux 系统目录很相近，我们后续的实验将使用该根文件系统。</p><h3 id="3-2-pivot-root">3.2.pivot_root</h3><p>pivot_root 命令用于切换根文件系统，其使用方式如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pivot_root new_root put_old<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>pivot_root 将当前进程的根文件系统移至 put_old 目录并使 new_root 目录成为新的根文件系统。</p><p>下面我们将通过实验学习 pivot_root 的使用方法。为了简单，我们在一个新的 mount namespace 下进行实验。首先，我们创建一个新的 mount namespace，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/docker.sh/images$ <span class="token function">sudo</span> unshare --mount /bin/bash
root@kernelnewbies:~/docker.sh/images<span class="token comment">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在我们的实验中，我们的根文件系统将挂载在 ubuntu1604 目录，而老的根文件系统将被移动到 ubuntu1604/old_root 目录下。我们先创建 old_root 目录，命令如下：</p><p>root@kernelnewbies:~/docker.sh/images# mkdir -p ubuntu1604/old_root/</p><p>由于 pivot_root 命令要求老的根目录和新的根目录不能在同一个挂载点下，因此我们通过 bind mount 将 ubuntu1604 目录变成一个挂载点。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@kernelnewbies:~/docker.sh/images<span class="token comment"># mount --bind ubuntu1604 ubuntu1604</span>
root@kernelnewbies:~/docker.sh/images<span class="token comment"># cat /proc/self/mountinfo | grep ubuntu1604</span>
<span class="token number">624</span> <span class="token number">382</span> <span class="token number">8</span>:1 /home/phl/docker.sh/images/ubuntu1604 /home/phl/docker.sh/images/ubuntu1604 rw,relatime - ext4 /dev/sda1 rw,errors<span class="token operator">=</span>remount-ro<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>准备好切换根文件系统所需要的条件后，我们调用 pivot_root 切换根文件系统。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@kernelnewbies:~/docker.sh/images<span class="token comment"># cd ubuntu1604/</span>
root@kernelnewbies:~/docker.sh/images/ubuntu1604<span class="token comment"># pivot_root . old_root/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此时，已完成根文件系统的切换，/proc 文件系统也被挪到了<br> /home/phl/docker.sh/images/ubuntu1604/old_root/proc，也就是说当前没有 /proc 文件系统，因此，我们无法查看挂载点信息，自然也无法执行一些依赖于 /proc 文件系统的操作。我们需要重新挂载 /proc 文件系统。命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@kernelnewbies:~/docker.sh/images/ubuntu1604<span class="token comment"># mount -t proc proc /proc</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>重新挂载 /proc 文件系统后，我们就可以查看当前的挂载点信息了。通过读取 /proc/self/mountinfo 文件来查看系统的挂载点信息。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@kernelnewbies:~/docker.sh/images/ubuntu1604<span class="token comment"># cat /proc/self/mountinfo</span>
<span class="token number">382</span> <span class="token number">624</span> <span class="token number">8</span>:1 / /old_root rw,relatime - ext4 /dev/sda1 rw,errors<span class="token operator">=</span>remount-ro
<span class="token punctuation">..</span>.
<span class="token number">624</span> <span class="token number">381</span> <span class="token number">8</span>:1 /home/phl/docker.sh/images/ubuntu1604 / rw,relatime - ext4 /dev/sda1 rw,errors<span class="token operator">=</span>remount-ro
<span class="token number">625</span> <span class="token number">624</span> <span class="token number">0</span>:5 / /proc rw,relatime - proc proc rw<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时的挂载点很多，为了方便查看，此处只保留了一些主要的挂载点信息。这些挂载点信息包括 /、/proc、/old_root。/old_root 为老的根文件系统，我们需要将其卸载。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@kernelnewbies:~/docker.sh/images/ubuntu1604<span class="token comment"># umount -l /old_root/</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>卸载掉老的根文件系统后，我们再查看系统的挂载点信息。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@kernelnewbies:~/docker.sh/images/ubuntu1604<span class="token comment"># cat /proc/self/mountinfo</span>
<span class="token number">624</span> <span class="token number">381</span> <span class="token number">8</span>:1 /home/phl/docker.sh/images/ubuntu1604 / rw,relatime - ext4 /dev/sda1 rw,errors<span class="token operator">=</span>remount-ro
<span class="token number">625</span> <span class="token number">624</span> <span class="token number">0</span>:5 / /proc rw,relatime - proc proc rw<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此时，挂载点信息中只有 /、/proc，不再有主机的挂载点信息。</p><h3 id="3-3-docker-sh">3.3.docker.sh</h3><p>有了以上关于切换根文件系统的知识，我们就可以将切换根文件系统的功能加入到 docker.sh 中了。切换根文件系统的功能将放在 container.sh 中，带下划线的行是我们为实现切换根文件系统而新添的代码。修改后的 container.sh 脚本如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token function">hostname</span> <span class="token variable">$container</span>

<span class="token function">mkdir</span> -p /sys/fs/cgroup/memory/<span class="token variable">$container</span>
<span class="token builtin class-name">echo</span> <span class="token variable">$$</span> <span class="token operator">&gt;</span> /sys/fs/cgroup/memory/<span class="token variable">$container</span>/cgroup.procs
<span class="token builtin class-name">echo</span> <span class="token variable">$memory</span> <span class="token operator">&gt;</span> /sys/fs/cgroup/memory/<span class="token variable">$container</span>/memory.limit_in_bytes

<span class="token function">mkdir</span> -p images/<span class="token variable">$image</span>/old_root
<span class="token function">mount</span> --bind images/<span class="token variable">$image</span> images/<span class="token variable">$image</span>

<span class="token builtin class-name">cd</span> images/<span class="token variable">$image</span>
pivot_root <span class="token builtin class-name">.</span> ./old_root

<span class="token function">mount</span> -t proc proc /proc
<span class="token function">umount</span> -l /old_root

<span class="token builtin class-name">exec</span> <span class="token variable">$program</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，我们在新的根文件系统目录中创建挂载老的根文件系统的目录。命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> -p images/<span class="token variable">$image</span>/old_root<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后，我们将新根文件系统目录 bind mount 成一个挂载点。命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mount</span> --bind images/<span class="token variable">$image</span> images/<span class="token variable">$image</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后，我们切换根文件系统。命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> images/<span class="token variable">$image</span>
pivot_root <span class="token builtin class-name">.</span> ./old_root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>最后，我们重新挂载 /proc 文件系统，然后卸载掉老的根文件系统。命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mount</span> -t proc proc /proc
<span class="token function">umount</span> -l /old_root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在，我们运行 docker.sh，并查看当前的发行版信息。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/docker.sh$ <span class="token function">sudo</span> ./docker.sh -c run -m 100M -C dreamland -I ubuntu1604 -V data1 -P /bin/bash
root@dreamland:/<span class="token comment"># cat /etc/issue</span>
Ubuntu <span class="token number">16.04</span> LTS <span class="token punctuation">\</span>n <span class="token punctuation">\</span>l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>从结果我们可以看出，读出的发行版信息是 Ubuntu 16.04 LTS \n \l，而非主机的 Ubuntu 18.04.3 LTS \n \l。这说明当前使用的根文件系统确实是 ubuntu16.04 目录下的根文件系统，而非主机的根文件系统。</p><p>我们再查看一下当前的挂载点信息，看看是否只有 / 与 /proc。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@dreamland:/<span class="token comment"># cat /proc/self/mountinfo</span>
<span class="token number">625</span> <span class="token number">381</span> <span class="token number">8</span>:1 /home/phl/docker.sh/images/ubuntu1604 / rw,relatime - ext4 /dev/sda1 rw,errors<span class="token operator">=</span>remount-ro
<span class="token number">626</span> <span class="token number">625</span> <span class="token number">0</span>:52 / /proc rw,relatime - proc proc rw<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>从结果我们可看出，当前挂载点信息中只有 /、/proc，不再有主机的挂载点信息。</p><p>通过根文件系统，我们实现了在容器中虚拟出与主机不一样的操作系统的功能。</p><h2 id="4-联合加载">4. 联合加载</h2><h3 id="4-1-联合加载简介">4.1. 联合加载简介</h3><p>联合加载指的是一次同时加载多个文件系统，但是在外面看起来只能看到 一个文件系统。联合加载会将各层文件系统叠加到一起，这样最终的文件系统会 包含所有底层的文件和目录。</p><p>联合加载的多个文件系统中有一个是可读写文件系统，称为读写层，其他文件系统是只读的，称为只读层。当联合加载的文件系统发生变化时，这些变化都应用到这个读写层。比如，如果想修改一个文件，这个文件首先会从只读层复制到读写层。原只读层中的文件依然存在，但是被读写层中的该文件副本所隐藏。我们以后读写该文件时，都是读写的该文件在读写层中的副本。这种机制被称为 写时复制。</p><p>我们之前实现的 docker.sh，有一个很大的缺陷。那就是，如果使用相同的根文件系统同时启动多个容器的实例，那么，这些容器实例使用的根文件系统位于同一个目录。我们在不同的容器实例对根文件系统所作的修改，这些容器彼此之间都可以看到，甚至一个容器可以覆覆盖另一个容器所作的修改。同时，容器实例退出时，对根文件系统所作的修改也直接作用于其所使用的根文件系统。当我们使用该根文件系统再次启动容器实例时，新启动的容器实例也可以看到以前的这些修改。例如，我们用 ubuntu1604 根文件系统启动两个容器实例，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/docker.sh$ <span class="token function">sudo</span> ./docker.sh -c run -m 100M -C dreamland -I ubuntu1604 -V data1 -P /bin/bash
phl@kernelnewbies:~/docker.sh$ <span class="token function">sudo</span> ./docker.sh -c run -m 100M -C dreamland2 -I ubuntu1604 -V data1 -P /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这两个容器实例对根文件系统做的修改彼此都可以看到。容器实例退出时，这些修改也被保存了下来，当用 ubuntu1604 根文件系统启动新的容器实例时，新实例也可看到以前实例所做的修改。</p><p>如果容器使用的根文件系统是一个联合加载的文件系统，原先的根文件系统作为一个只读层，再添加一个读写层，那么，在容器内所作的修改都将只作用于读写层。为了区分，我们以后称 ubuntu1604 目录下的根文件系统为镜像。而我们可以为每一个容器实例指定一个唯一的读写层目录，这样的话，多个容器实例就可以使用同一个镜像，容器内所作的修改不会影响彼此，也不会影响到以后启动的容器实例。例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/docker.sh$ <span class="token function">sudo</span> ./docker.sh -c run -m 100M -C dreamland -I ubuntu1604 -V data1 -P /bin/bash
phl@kernelnewbies:~/docker.sh$ <span class="token function">sudo</span> ./docker.sh -c run -m 100M -C dreamland2 -I ubuntu1604 -V data1 -P /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>我们使用 ubuntu1604 镜像启动了两个容器示例，并在容器实例里进行读写操作。这两个容器实例的读写层目录是不一样的，在容器实例中所作的修改只作用于各自的读写层，彼此之间不会影响，当然更不会影响到后续启动的容器实例。</p><h3 id="4-2-AUFS">4.2. AUFS</h3><p>AUFS 是一个实现了联合加载功能的文件系统。我们将采用 AUFS 实现 docker.sh 中的联合加载功能。</p><p>下面，我们将通过实验演示一下 AUFS 文件系统的用法。首先，我们准备需要用到的目录及文件。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~$ <span class="token function">mkdir</span> aufs
phl@kernelnewbies:~$ <span class="token builtin class-name">cd</span> aufs/
phl@kernelnewbies:~/aufs$ <span class="token function">mkdir</span> rw r1 r2 union
phl@kernelnewbies:~/aufs$ <span class="token builtin class-name">echo</span> hello r1 <span class="token operator">&gt;</span> r1/hellor1.txt
phl@kernelnewbies:~/aufs$ <span class="token builtin class-name">echo</span> hello r2 <span class="token operator">&gt;</span> r2/hellor2.txt
phl@kernelnewbies:~/aufs$ <span class="token builtin class-name">echo</span> hello rw <span class="token operator">&gt;</span> rw/hellorw.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下表列出了各个目录的作用。列表如下：</p><ul><li>rw 为 aufs 文件系统的读写层目录</li><li> r1 为 aufs 文件系统的只读层目录</li><li> r2 为 aufs 文件系统的只读层目录</li><li> union 为挂载点，联合加载的 aufs 文件系统挂载于此目录</li></ul><p>下面我们将 rw、r1、r2 联合加载到 union 目录。命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/aufs$ <span class="token function">sudo</span> <span class="token function">mount</span> -t aufs -o <span class="token assign-left variable">dirs</span><span class="token operator">=</span>rw:r1:r2 none union<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>-t aufs 表示要挂载的文件系统类型为 AUFS</li><li>-o dirs=rw:r1:r2 表示要将哪些目录加载到 afus 文件系统中，多个目录之间以：分隔。目录列表中的第一个目录表示读写层目录</li><li> union 表示 aufs 文件系统要挂载的目录</li></ul><p>挂载好 AUFS 文件系统后，我们进入该文件系统，查看其内容。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/aufs$ <span class="token builtin class-name">cd</span> union/
phl@kernelnewbies:~/aufs/union$ <span class="token function">ls</span>
hellor1.txt hellor2.txt hellorw.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>从输出结果来看，rw、r1、r2 目录下的内容全部出现在了 AUFS 文件系统中，该文件系统由 rw、r1、r2 目录叠加而成。</p><p>然后，我们修改这些文件，看看原始的 rw、r1、r2 目录下的文件是否更改。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/aufs/union$ <span class="token builtin class-name">echo</span> hello to r1 from union <span class="token operator">&gt;</span> hellor1.txt
phl@kernelnewbies:~/aufs/union$ <span class="token builtin class-name">echo</span> hello to r2 from union <span class="token operator">&gt;</span> hellor2.txt
phl@kernelnewbies:~/aufs/union$ <span class="token builtin class-name">echo</span> hello to rw from union <span class="token operator">&gt;</span> hellorw.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们返回到 aufs 目录，直接查看 aufs 目录下的内容。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/aufs$ tree <span class="token builtin class-name">.</span>
<span class="token builtin class-name">.</span>
├── r1
│   └── hellor1.txt
├── r2
│   └── hellor2.txt
├── rw
│   ├── hellor1.txt
│   ├── hellor2.txt
│   └── hellorw.txt
└── union
    ├── hellor1.txt
    ├── hellor2.txt
    └── hellorw.txt

<span class="token number">4</span> directories, <span class="token number">8</span> files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从输出结果我们可以看到，我们修改的 hellor1.txt 和 hellor2.txt 文件分别被拷贝了一份放在读写层目录 rw 中。我们查看一下这些文件的内容，命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/aufs$ <span class="token function">cat</span> r1/hellor1.txt
hello r1
phl@kernelnewbies:~/aufs$ <span class="token function">cat</span> r2/hellor2.txt
hello r2
phl@kernelnewbies:~/aufs$ <span class="token function">cat</span> rw/hellor1.txt
hello to r1 from union
phl@kernelnewbies:~/aufs$ <span class="token function">cat</span> rw/hellor2.txt
hello to r2 from union
phl@kernelnewbies:~/aufs$ <span class="token function">cat</span> rw/hellorw.txt
hello to rw from union<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从输出结果我们看到，用户修改只读层 r1、r2 中的文件时，这些文件被复制到了读写层，我们修改的是读写层的副本，原只读层中的文件没有变化。用户修改读写层 rw 中的文件时，修改直接作用于这些文件本身。</p><h3 id="4-3-docker-sh">4.3.docker.sh</h3><p>在继续之前，我们需要将上一章在 ubuntu1604 根文件系统中创建的 old_root 目录删除掉，以保证该根文件系统跟刚制作好时一样。命令及结果如下：</p><p>phl@kernelnewbies:~/docker.sh$ sudo rm -rf images/ubuntu1604/old_root</p><p>有了以上关于联合加载的介绍，我们就可以将联合加载功能加入到 docker.sh 中了。联合加载功能将放在 container.sh 脚本中，带下划线的行是我们为实现联合加载功能而新添的代码。修改后的 container.sh 如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token function">hostname</span> <span class="token variable">$container</span>

<span class="token function">mkdir</span> -p /sys/fs/cgroup/memory/<span class="token variable">$container</span>
<span class="token builtin class-name">echo</span> <span class="token variable">$$</span> <span class="token operator">&gt;</span> /sys/fs/cgroup/memory/<span class="token variable">$container</span>/cgroup.procs
<span class="token builtin class-name">echo</span> <span class="token variable">$memory</span> <span class="token operator">&gt;</span> /sys/fs/cgroup/memory/<span class="token variable">$container</span>/memory.limit_in_bytes

<span class="token function">mkdir</span> -p <span class="token variable">$container</span>/rwlayer
<span class="token function">mount</span> -t aufs -o <span class="token assign-left variable">dirs</span><span class="token operator">=</span><span class="token variable">$container</span>/rwlayer:./images/<span class="token variable">$image</span> none <span class="token variable">$container</span>

<span class="token function">mkdir</span> -p <span class="token variable">$container</span>/old_root
<span class="token builtin class-name">cd</span> <span class="token variable">$container</span>
pivot_root <span class="token builtin class-name">.</span> ./old_root

<span class="token function">mount</span> -t proc proc /proc
<span class="token function">umount</span> -l /old_root

<span class="token builtin class-name">exec</span> <span class="token variable">$program</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，我们根据容器的名字创建联合加载需要的读写层目录及文件系统挂载目录。命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> -p <span class="token variable">$container</span>/rwlayer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>假如我们传递的容器的名字为 dreamland，将创建以下目录：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/docker.sh$ tree dreamland/
dreamland/
└── rwlayer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中 dreamland/rwlayer 目录为创建的 AUFS 文件系统的读写层，dreamland 目录为 AUFS 文件系统的挂载点。</p><p>然后我们将镜像目录、读写层目录联合加载到挂载点目录。命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mount</span> -t aufs -o <span class="token assign-left variable">dirs</span><span class="token operator">=</span><span class="token variable">$container</span>/rwlayer:./images/<span class="token variable">$image</span> none <span class="token variable">$container</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>假如容器名字为 dreamland，使用的镜像为 ubuntu1604 根文件系统，dreamland/rwlayer、images/ubuntu1604 将被联合加载的 dreamland 目录。其中，dreamland/rwlayer 为 AUFS 文件系统的读写层，images/ubuntu1604 为 AUFS 文件系统的只读层。</p><p>之前我们将老的根文件系统挪到了 rootfs/old_root，rootfs 代表一个具体的镜像目录。创建 old_root 目录时直接修改了该镜像。下面我们将老的根文件系统的挂载点目录放在 AUFS 文件系统中，并将老的根文件系统挪到此处。命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> -p <span class="token variable">$container</span>/old_root
<span class="token builtin class-name">cd</span> <span class="token variable">$container</span>
pivot_root <span class="token builtin class-name">.</span> ./old_root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此时，$container 目录本身就是一个挂载点，挂载了 AUFS 文件系统。因此下面的代码就被移除了：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mount</span> --bind images/<span class="token variable">$image</span> images/<span class="token variable">$image</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在，我们运行 docker.sh，并在 /root 下创建一个文件。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/docker.sh$ <span class="token function">sudo</span> ./docker.sh -c run -m 100M -C dreamland -I ubuntu1604 -V data1 -P /bin/bash
root@dreamland:/<span class="token comment"># cd /root</span>
root@dreamland:/root<span class="token comment"># ls</span>
root@dreamland:/root<span class="token comment"># cat /etc/issue &gt; hello.txt</span>
root@dreamland:/root<span class="token comment"># cat hello.txt</span>
Ubuntu <span class="token number">16.04</span> LTS <span class="token punctuation">\</span>n <span class="token punctuation">\</span>l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动一个新的 Shell 窗口，查看一下该容器使用的 AUFS 文件系统。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/docker.sh$ <span class="token function">sudo</span> tree dreamland/
dreamland/
└── rwlayer
    ├── old_root
    └── root
        └── hello.txt

<span class="token number">2</span> directories, <span class="token number">1</span> <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从结果我们可以看到，我们新建的文件及创建的老根文件系统的挂载点目录都出现在了读写层。我们再查看一下新创建的文件。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/docker.sh$ <span class="token function">sudo</span> <span class="token function">cat</span> dreamland/rwlayer/root/hello.txt
Ubuntu <span class="token number">16.04</span> LTS <span class="token punctuation">\</span>n <span class="token punctuation">\</span>l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>文件内容是 Ubuntu 16.04 的发行版信息。</p><p>通过联合加载，我们实现了在容器中的读写不会影响使用的镜像。这样使用 ubuntu1604 镜像创建多个容器时，彼此之间就不会相互影响了。</p><h2 id="5-卷">5. 卷</h2><h3 id="5-1-卷简介">5.1. 卷简介</h3><p>卷是容器内的一个目录，这个目录可以绕过联合文件系统，提供数据共享（容器所使用的的联合文件系统不应该被主机或其他容器访问）与数据持久化的功能。</p><p>举个例子，假如容器有个目录为 /data 的卷，我们向这个卷写入的内容不会出现在联合文件系统的读写层，而是直接出现在这个目录里。主机与其他容器也可以访问该目录，从而达到数据共享与数据持久化的目的。</p><p>卷位于联合文件系统中，通常来说写入该目录的内容会被写入容器的读写层中，那么怎样才能是写入卷的目录直接出现在该目录中，而不是容器读写层呢？其实方法很简单，只要我们将该目录变成一个挂载点就行，变成挂载点后，这个目录中的内容就不属于联合文件系统了，写入该目录的内容自然会保存在挂载到该挂载点的设备中。</p><h3 id="5-2-docker-sh">5.2 docker.sh</h3><p>有了以上关于卷的介绍，我们就可以将卷功能加入到 docker.sh 中了。卷功能将放在 container.sh 脚本中，带下划线的行是我们为实现卷功能而新添的代码。修改后的 container.sh 脚本如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>

<span class="token function">hostname</span> <span class="token variable">$container</span>

<span class="token function">mkdir</span> -p /sys/fs/cgroup/memory/<span class="token variable">$container</span>
<span class="token builtin class-name">echo</span> <span class="token variable">$$</span> <span class="token operator">&gt;</span> /sys/fs/cgroup/memory/<span class="token variable">$container</span>/cgroup.procs
<span class="token builtin class-name">echo</span> <span class="token variable">$memory</span> <span class="token operator">&gt;</span> /sys/fs/cgroup/memory/<span class="token variable">$container</span>/memory.limit_in_bytes

<span class="token function">mkdir</span> -p <span class="token variable">$container</span>/rwlayer
<span class="token function">mount</span> -t aufs -o <span class="token assign-left variable">dirs</span><span class="token operator">=</span><span class="token variable">$container</span>/rwlayer:./images/<span class="token variable">$image</span> none <span class="token variable">$container</span>

<span class="token function">mkdir</span> -p <span class="token variable">$volume</span>
<span class="token function">mkdir</span> -p <span class="token variable">$container</span>/<span class="token variable">$volume</span>
<span class="token function">mount</span> --bind <span class="token variable">$volume</span> <span class="token variable">$container</span>/<span class="token variable">$volume</span>

<span class="token function">mkdir</span> -p <span class="token variable">$container</span>/old_root
<span class="token builtin class-name">cd</span> <span class="token variable">$container</span>
pivot_root <span class="token builtin class-name">.</span> ./old_root

<span class="token function">mount</span> -t proc proc /proc
<span class="token function">umount</span> -l /old_root

<span class="token builtin class-name">exec</span> <span class="token variable">$program</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，我们根据卷的名字创建主机卷目录，我们在容器内部对卷的修改，都将作用于此目录。命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> -p <span class="token variable">$volume</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后，我们在容器内部创建同名卷目录，该目录本身会出现在容器的读写层中，因为该目录是在 AUFS 文件系统中创建的。因为<img src="/medias_webp/loading.svg" data-original="https://math.now.sh?inline=container%E7%9B%AE%E5%BD%95%E4%B8%BA%E5%AE%B9%E5%99%A8%E7%9A%84%E6%A0%B9%E7%9B%AE%E5%BD%95%EF%BC%8C%E6%89%80%E4%BB%A5%E5%AE%B9%E5%99%A8%E5%86%85%E9%83%A8%E5%8D%B7%E7%9B%AE%E5%BD%95%E7%9A%84%E8%B7%AF%E5%BE%84%E4%B8%BA%2F" style="filter:opacity(90%);transform:scale(.85);text-align:center;display:inline-block;margin:0">volume。命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> -p <span class="token variable">$container</span>/<span class="token variable">$volume</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将主机上的卷目录 bind mount 到容器内部的卷目录上，这样容器内部对卷目录的修改，都将作用于主机卷目录。命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mount</span> --bind <span class="token variable">$volume</span> <span class="token variable">$container</span>/<span class="token variable">$volume</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在，我们运行 docker.sh，并在卷目录（/data1）中创建一个文件。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/docker.sh$ <span class="token function">sudo</span> ./docker.sh -c run -m 100M -C dreamland -I ubuntu1604 -V data1 -P /bin/bash
root@dreamland:/<span class="token comment"># cd /data1</span>
root@dreamland:/data1<span class="token comment"># echo "hello to data1 volume from ubuntu16.04" &gt;&gt; hello.txt</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>启动一个新的 Shell 窗口，查看一下该容器使用的 AUFS 文件系统中的内容。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/docker.sh$ <span class="token function">sudo</span> tree dreamland/
dreamland/
└── rwlayer
    ├── data1
    ├── old_root
    └── root
        └── hello.txt

<span class="token number">4</span> directories, <span class="token number">1</span> <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从结果我们可以看到，我们使用的卷目录被创建在了容器的读写层，但是我们在卷目录中新建的文件却没有出现在读写层中。</p><p>我们再来查看一下主机卷目录的内容。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/docker.sh$ <span class="token function">sudo</span> tree data1/
data1/
└── hello.txt

<span class="token number">0</span> directories, <span class="token number">1</span> <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从结果我们可以看到，在容器内部对卷目录的修改直接作用在了主机上的卷目录。我们再来查看一下主机卷目录下 hello.txt 中的内容。命令及结果如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">phl@kernelnewbies:~/docker.sh$ <span class="token function">sudo</span> <span class="token function">cat</span> data1/hello.txt
hello to data1 volume from ubuntu16.04<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>从结果我们可以看到，该文件的内容与我们在容器内部写入 hello.txt 的内容一致。</p><p>通过卷目录，我们实现了容器之间数据共享与数据持久化的功能。</p><h2 id="6-后记">6. 后记</h2><p>至此，我们通过一系列的实验对 docker 的底层技术有了一个感性的认识。我们在使用 docker 时，也能够对其是如何运作的有了一个大致的了解。当然，这对于掌握 docker 技术来说还远远不够，有很多知识我们没有涉及，例如 user namespace、容器安全、其他的 CGroups、虚拟网络等。</p><p>编辑整理 <a target="_blank" rel="noopener" href="https://www.toutiao.com/i6890898988879315468/?tt_from=weixin&amp;utm_campaign=client_share&amp;wxshare_count=1&amp;timestamp=1647576105&amp;app=news_article&amp;utm_source=weixin&amp;utm_medium=toutiao_android&amp;use_new_style=1&amp;req_id=202203181201440101511900790A2CBE46&amp;share_token=b2d9351e-4cb1-4a25-ae82-f70543ce2a3b&amp;group_id=6890898988879315468">ScratchLab</a></p><link rel="stylesheet" href="/css/bilicard.css" type="text/css"></div><hr><div class="reprint" id="reprint-statement"><div class="reprint__author"> <span class="reprint-meta" style="font-weight:700"><i class="fas fa-user">文章作者:</i></span> <span class="reprint-info"><a href="https://blog.17lai.site" rel="external nofollow noreferrer">夜法之书</a></span></div><div class="reprint__type"> <span class="reprint-meta" style="font-weight:700"><i class="fas fa-link">文章链接:</i></span> <span class="reprint-info"><a href="https://blog.17lai.site/posts/90e60aac/">https://blog.17lai.site/posts/90e60aac/</a></span></div><div class="reprint__notice"> <span class="reprint-meta" style="font-weight:700"><i class="fas fa-copyright">版权声明:</i></span> <span class="reprint-info">本博客所有文章除特別声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://blog.17lai.site" target="_blank">夜法之书</a> !</span></div></div><script async defer="defer">
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"> <a href="/tags/linux/"><span class="chip bg-color">linux</span></a> <a href="/tags/docker/"><span class="chip bg-color">docker</span></a> <a href="/tags/shell/"><span class="chip bg-color">shell</span></a></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/appotry/hexo@2.41/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="https://cdn.jsdelivr.net/gh/appotry/hexo@2.41/libs/share/js/social-share.min.js"></script></div></div></div><style>#reward{margin:40px 0;text-align:center}#reward .reward-link{font-size:1.4rem;line-height:38px}#reward .btn-floating:hover{box-shadow:0 6px 12px rgba(0,0,0,.2),0 5px 15px rgba(0,0,0,.2)}#rewardModal{width:320px;height:350px}#rewardModal .reward-title{margin:15px auto;padding-bottom:5px}#rewardModal .modal-content{padding:10px}#rewardModal .close{position:absolute;right:15px;top:15px;color:rgba(0,0,0,.5);font-size:1.3rem;line-height:20px;cursor:pointer}#rewardModal .close:hover{color:#ef5350;transform:scale(1.3);-moz-transform:scale(1.3);-webkit-transform:scale(1.3);-o-transform:scale(1.3)}#rewardModal .reward-tabs{margin:0 auto;width:210px}.reward-tabs .tabs{height:38px;margin:10px auto;padding-left:0}.reward-content ul{padding-left:0!important}.reward-tabs .tabs .tab{height:38px;line-height:38px}.reward-tabs .tab a{color:#fff;background-color:#ccc}.reward-tabs .tab a:hover{background-color:#ccc;color:#fff}.reward-tabs .wechat-tab .active{color:#fff!important;background-color:#22ab38!important}.reward-tabs .alipay-tab .active{color:#fff!important;background-color:#019fe8!important}.reward-tabs .reward-img{width:210px;height:210px}</style><div id="reward"> <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a><div id="rewardModal" class="modal"><div class="modal-content"><a class="close modal-close"><i class="fas fa-times"></i></a><h4 class="reward-title">码字辛苦，打赏作者！</h4><div class="reward-content"><div class="reward-tabs"><ul class="tabs row"><li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li><li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li></ul><div id="alipay"> <img src="/medias_webp/loading.svg" data-original="https://cdn.jsdelivr.net/gh/appotry/hexo@2.41/medias_webp/reward/alipay.webp" class="reward-img" alt="支付宝打赏二维码"></div><div id="wechat"> <img src="/medias_webp/loading.svg" data-original="https://cdn.jsdelivr.net/gh/appotry/hexo@2.41/medias_webp/reward/wechat.webp" class="reward-img" alt="微信打赏二维码"></div></div></div></div></div></div><script>$(function(){$(".tabs").tabs()})</script></div></div><style>.fa-chrome:before{color:#f14f05}.fa-windows:before{color:#3f8cd9}.fa-macos:before{color:#000}.fa-edge:before{color:#1a2bdc}.fa-safari:before{color:#26a69a}.fa-qq:before{content:"\f1d6"}.fa-android:before{content:"\f17b";color:#0c9850}.fa-wechat:before,.fa-weixin:before{content:"\f1d7"}.fa-firefox:before{color:#f53a3a}.valine-card{margin:1.5rem auto}.valine-card .card-content{padding:20px 20px 5px 20px}.v[data-class="v"] .vwrap .vheader .vinput{width:32%;border-bottom:1px dashed #dedede}#vcomments textarea{box-sizing:border-box;background:url(https://cdn.jsdelivr.net/gh/appotry/hexo@latest/medias_webp/hongmiaosi.webp) 100% 100% no-repeat;background-size:contain;background-position:right;background-color:rgba(255,255,255,0);resize:vertical;caret-color:red;color:#1a2bdc;white-space:pre-line}#vcomments p{margin:2px 2px 10px;font-size:1.05rem;line-height:1.78rem}#vcomments blockquote p{text-indent:.2rem}#vcomments a{padding:0 2px;color:#4cbf30;font-weight:500;text-decoration:none}#vcomments img{max-width:100%;height:auto;cursor:pointer}#vcomments ol li{list-style-type:decimal}#vcomments ol,ul{display:block;padding-left:2em;word-spacing:.05rem}#vcomments ul li,ol li{display:list-item;line-height:1.8rem;font-size:1rem}#vcomments ul li{list-style-type:disc}#vcomments ul ul li{list-style-type:circle}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}#vcomments table,td,th{border:0}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments h1{font-size:1.85rem;font-weight:700;line-height:2.2rem}#vcomments h2{font-size:1.65rem;font-weight:700;line-height:1.9rem}#vcomments h3{font-size:1.45rem;font-weight:700;line-height:1.7rem}#vcomments h4{font-size:1.25rem;font-weight:700;line-height:1.5rem}#vcomments h5{font-size:1.1rem;font-weight:700;line-height:1.4rem}#vcomments h6{font-size:1rem;line-height:1.3rem}#vcomments p{font-size:1rem;line-height:1.5rem}#vcomments hr{margin:12px 0;border:0;border-top:1px solid #ccc}#vcomments blockquote{margin:15px 0;border-left:5px solid #42b983;padding:1rem .8rem .3rem .8rem;color:#666;background-color:rgba(66,185,131,.1)}#vcomments pre{font-family:monospace,monospace;padding:1.2em;margin:.5em 0;background:#272822;overflow:auto;border-radius:.3em;tab-size:4}#vcomments code{font-family:monospace,monospace;padding:1px 3px;font-size:.92rem;color:#e96900;background-color:#f8f8f8;border-radius:2px}#vcomments pre code{font-family:monospace,monospace;padding:0;color:#e8eaf6;background-color:#272822}#vcomments pre[class*=language-]{padding:1.2em;margin:.5em 0}#vcomments code[class*=language-],pre[class*=language-]{color:#e8eaf6}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}#vcomments b,strong{font-weight:700}#vcomments dfn{font-style:italic}#vcomments small{font-size:85%}#vcomments cite{font-style:normal}#vcomments mark{background-color:#fcf8e3;padding:.2em}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}</style><div class="card valine-card" data-aos="fade-up"><div class="comment_headling" style="font-size:20px;font-weight:700;position:relative;padding-left:20px;top:15px;padding-bottom:5px"><i class="fas fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div id="vcomments" class="card-content" style="display:grid"></div></div><script src="https://cdn.jsdelivr.net/gh/appotry/hexo@2.41/libs/valine/av-min.js"></script><script src="https://cdn.jsdelivr.net/gh/appotry/hexo@2.41/libs/valine/Valine.min.js"></script><script>
    let metaPlaceholder = {"nick":"昵称/QQ号(必填)","mail":"邮箱(必填)","link":"网址(https://)"} ;

    new Valine({
        el: '#vcomments', 
        appId: 'v2hJTCLDHLnGF4iSJkBJ8mga-MdYXbMMI', 
        appKey: 'Hu4UNHLVERHkhfH6G5xqdqN3', 
        serverURLs: 'https://v2hjtcld.api.lncldglobal.com',
        notify: 'false' === 'true', 
        verify: 'false' === 'true', 
        visitor: 'true' === 'true', 
        avatar: 'monsterid', 
        pageSize: '10', 
        lang: 'zh-CN', 
        placeholder: '🤣一起来玩，留下你的足迹吧~。评论支持📧邮箱回复通知！\r\n 🚀昵称使用QQ号可以自动补全邮箱和显示头像昵称等信息呢 \r\n 💣请文明评论哦禁止恶意评论\r\n ⚠️公开网络空间，请不要发表任何包含个人或其他人的隐私信息', 
        meta: ["nick", "mail", "link"], 
        recordIP: 'true' === 'true', 
        enableQQ: 'monsterid', 
        requiredFields: ["034f6b6a1d9b52722c151726bcfd5ead"], 
        master: ["034f6b6a1d9b52722c151726bcfd5ead"], 
        friends: ["641A8095D4AA5757C24D7D06E97A6314", "901345d4c91ddfd8db0f175bbcfff0c8", "1512958e18378c98b498d5effe3e76ff"], 
        tagMeta: ["博主", "小伙伴", "访客"], 
        metaPlaceholder: metaPlaceholder,
    });

    document.body.addEventListener('click', function (e) {
        if (e.target.classList.contains('vsubmit')) {
            const email = document.querySelector('input[type=email]');
            const nick = document.querySelector('input[name=nick]');
            const reg = /^[A-Za-z0-9_-\u4e00-\u9fa5]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$/;
            if (!email.value || !nick.value || !reg.test(email.value)) {
                const str = `<div class="valert txt-center"><div class="vtext">请填写正确的昵称和邮箱！</div></div>`;
                const vmark = document.querySelector('.vmark');
                vmark.innerHTML = str;
                vmark.style.display = 'block';

                e.stopPropagation();

                setTimeout(function () {
                    vmark.style.display = 'none';
                    vmark.innerHTML = '';
                }, 2500);
            }
        }
    }, true);
</script><div id="to_comment" class="comment-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#vcomments" title="直达评论"><i class="fas fa-comments"></i></a></div><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fas fa-chevron-left"></i> &nbsp;上一篇</div><div class="card"><a href="/posts/3b296307/"><div class="card-image card-image-V"><div class="box-content"><h3 class="title">阅读全文</h3> <span class="post" style="width:180px">winrar 去广告和破解</span></div> <img src="/medias_webp/loading.svg" data-original="https://cdn.jsdelivr.net/gh/appotry/hexo@2.41/medias_webp/cover/winrar.webp" class="responsive-img" alt="winrar 去广告和破解"> <span class="card-title title-V">winrar 去广告和破解</span></div></a><div class="card-content article-content"><div class="summary block-with-text"> winrar国内版弹窗广告太讨人嫌了，如何去除广告了？本文一步一步教你如何破解winrar并且去除广告。还你一个清爽的使用体验</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i> 2022-03-19</span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/tools/" class="post-category">tools</a></span></div></div><div class="card-action article-tags"> <a href="/tags/tools/"><span class="chip bg-color">tools</span></a> <a href="/tags/winrar/"><span class="chip bg-color">winrar</span></a> <a href="/tags/crack/"><span class="chip bg-color">crack</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color"> 下一篇&nbsp;<i class="fas fa-chevron-right"></i></div><div class="card"><a href="/posts/68d3867d/"><div class="card-image card-image-V"><div class="box-content"><h3 class="title">阅读全文</h3> <span class="post" style="width:180px">node 项目从构建到使用 jenkins + docker + nginx + mysql + redis 自动化部署</span></div> <img src="/medias_webp/loading.svg" data-original="https://cdn.jsdelivr.net/gh/appotry/hexo@2.41/medias_webp/cover/web.webp" class="responsive-img" alt="node 项目从构建到使用 jenkins + docker + nginx + mysql + redis 自动化部署"> <span class="card-title title-V">node 项目从构建到使用 jenkins + docker + nginx + mysql + redis 自动化部署</span></div></a><div class="card-content article-content"><div class="summary block-with-text"> node 项目从构建到使用 jenkins + docker + nginx + mysql + redis CI/CD自动化部署全过程详解，一步一步教你完成自动化！</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i> 2022-03-16</span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/web/" class="post-category">web</a></span></div></div><div class="card-action article-tags"> <a href="/tags/web/"><span class="chip bg-color">web</span></a> <a href="/tags/docker/"><span class="chip bg-color">docker</span></a> <a href="/tags/ci-cd/"><span class="chip bg-color">CI/CD</span></a> <a href="/tags/node/"><span class="chip bg-color">node</span></a> <a href="/tags/jenkins/"><span class="chip bg-color">jenkins</span></a></div></div></div></div></article></div><script>$("#articleContent").on("copy",function(e){if(void 0!==window.getSelection){var n=window.getSelection();if(!((""+n).length<Number.parseInt("100"))){var t=document.getElementsByTagName("body")[0],o=document.createElement("div");o.style.position="absolute",o.style.left="-99999px",t.appendChild(o),o.appendChild(n.getRangeAt(0).cloneContents()),"PRE"!==n.getRangeAt(0).commonAncestorContainer.nodeName&&"CODE"!==n.getRangeAt(0).commonAncestorContainer.nodeName||(o.innerHTML="<pre>"+o.innerHTML+"</pre>");var i=document.location.href;o.innerHTML+='<br />来源: 夜法之书<br />文章作者: 夜法之书<br />文章链接: <a href="'+i+'">'+i+"</a><br />本文章著作权归作者所有，任何形式的转载都请注明出处。",n.selectAllChildren(o),window.setTimeout(function(){t.removeChild(o)},200)}}})</script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/appotry/hexo@2.41/libs/codeBlock/codeBlockFuction.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/appotry/hexo@2.41/libs/codeBlock/codeLang.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/appotry/hexo@2.41/libs/codeBlock/codeCopy.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/appotry/hexo@2.41/libs/codeBlock/codeShrink.js"></script></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget card" style="background-color:#fff"><div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color" title="显示/隐藏目录"><i class="fas fa-list-ul"></i></a></div><script src="https://cdn.jsdelivr.net/gh/appotry/hexo@2.41/libs/tocbot/tocbot.min.js"></script><script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4, h5, h6'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script></main><footer class="page-footer bg-color"><div class="container row center-align" style="margin-bottom:0!important"><div class="col s12 m8 l8 copy-right"> Copyright&nbsp;&copy; <span id="year">2020-2022</span> <a href="/about" target="_blank">夜法之书</a> |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a><br> &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span class="white-color">209.5k</span> <span id="busuanzi_container_site_pv">&nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv" class="white-color"></span></span> <span id="busuanzi_container_site_uv">&nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv" class="white-color"></span></span><br><br></div><div class="col s12 m4 l4 social-link social-statis"><a href="https://github.com/appotry" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fab fa-github"></i></a><a href="https://hub.docker.com/u/bloodstar" class="tooltipped" target="_blank" data-tooltip="访问我的DockerHub" data-position="top" data-delay="50"><i class="fab fa-docker"></i></a><a href="mailto:andycrusoe@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50"><i class="fas fa-envelope-open"></i></a><a href="https://twitter.com/firedingden" class="tooltipped" target="_blank" data-tooltip="关注我的Twitter: https://twitter.com/firedingden" data-position="top" data-delay="50"><i class="fab fa-twitter"></i></a><a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50"><i class="fas fa-rss"></i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fas fa-search"></i> &nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script type="text/javascript">$(function(){!function(t,s,a){"use strict";$.ajax({url:t,dataType:"xml",success:function(t){var e=$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),r=document.getElementById(s),n=document.getElementById(a);r.addEventListener("input",function(){var f='<ul class="search-result-list">',m=this.value.trim().toLowerCase().split(/[\s\-]+/);n.innerHTML="",this.value.trim().length<=0||(e.forEach(function(t){var r=!0,n=t.title.trim().toLowerCase(),s=t.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),e=t.url;e=0===e.indexOf("/")?t.url:"/"+e;var a=-1,i=-1,l=-1;if(""!==n&&""!==s&&m.forEach(function(t,e){a=n.indexOf(t),i=s.indexOf(t),a<0&&i<0?r=!1:(i<0&&(i=0),0===e&&(l=i))}),r){f+="<li><a href='"+e+"' class='search-result-title'>"+n+"</a>";var c=t.content.trim().replace(/<[^>]+>/g,"");if(0<=l){var u=l-20,o=l+80;u<0&&(u=0),0===u&&(o=100),o>c.length&&(o=c.length);var h=c.substr(u,o);m.forEach(function(t){var e=new RegExp(t,"gi");h=h.replace(e,'<em class="search-keyword">'+t+"</em>")}),f+='<p class="search-result">'+h+"...</p>"}f+="</li>"}}),f+="</ul>",n.innerHTML=f)})}})}("https://cdn.jsdelivr.net/gh/appotry/hexo@2.41/search.xml","searchInput","searchResult")})</script><div class="stars-con"><div id="stars"></div><div id="stars2"></div><div id="stars3"></div></div><script>function switchNightMode(){$('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($("body")),setTimeout(function(){$("body").hasClass("DarkMode")?($("body").removeClass("DarkMode"),localStorage.setItem("isDark","0"),$("#sum-moon-icon").removeClass("fa-sun").addClass("fa-moon")):($("body").addClass("DarkMode"),localStorage.setItem("isDark","1"),$("#sum-moon-icon").addClass("fa-sun").removeClass("fa-moon")),setTimeout(function(){$(".Cuteen_DarkSky").fadeOut(1e3,function(){$(this).remove()})},2e3)})}</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!" title="回到顶部"><i class="fas fa-arrow-up"></i></a></div><script>"1"===localStorage.getItem("isDark")?(document.body.classList.add("DarkMode"),$("#sum-moon-icon").addClass("fa-sun").removeClass("fa-moon")):(document.body.classList.remove("DarkMode"),$("#sum-moon-icon").removeleClass("fa-sun").addClass("fa-moon"))</script><script src="https://cdn.jsdelivr.net/gh/appotry/hexo@2.41/libs/materialize/materialize.min.js"></script><script src="https://cdn.jsdelivr.net/gh/appotry/hexo@2.41/libs/masonry/masonry.pkgd.min.js"></script><script src="https://cdn.jsdelivr.net/gh/appotry/hexo@2.41/libs/aos/aos.js"></script><script src="https://cdn.jsdelivr.net/gh/appotry/hexo@2.41/libs/scrollprogress/scrollProgress.min.js"></script><script src="https://cdn.jsdelivr.net/gh/appotry/hexo@2.41/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="https://cdn.jsdelivr.net/gh/appotry/hexo@2.41/js/matery.js"></script><script async src="https://cdn.jsdelivr.net/gh/appotry/hexo@2.41/libs/others/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/gh/appotry/hexo@2.41/libs/instantpage/instantpage.js" type="module"></script><script>
        // init PWA
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker
            .register('/sw.js')
            .then(function () {
                console.log("Service Worker Registered");
            });
        }
        
        let deferredPrompt;
        
        window.addEventListener('beforeinstallprompt', function (e) {
            // Prevent Chrome 67 and earlier from automatically showing the prompt
            e.preventDefault();
            // Stash the event so it can be triggered later.
            deferredPrompt = e;
            showAddToHomeScreen();
        });
        
        function showAddToHomeScreen() {
            let toastHTML = '<span>使<b> 夜法之书 </b>可以离线访问？</span><button class="btn-flat toast-action" onclick="addToHomeScreen()">Yes</button>';
            M.toast({html: toastHTML});
        }
        
        function addToHomeScreen() {
            deferredPrompt.prompt();  // Wait for the user to respond to the prompt
            deferredPrompt.userChoice
            .then(function (choiceResult) {
                if (choiceResult.outcome === 'accepted') {
                console.log('User accepted the A2HS prompt');
                } else {
                console.log('User dismissed the A2HS prompt');
                }
                deferredPrompt = null;
            });
        }
    </script><script src="https://cdn.jsdelivr.net/npm/hexo-tag-common@0.0.5/js/index.js"></script><script src="https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"https://cdn.jsdelivr.net/gh/appotry/hexo@2.30/live2d-lwet/14.json"},display:{superSample:2,position:"left",width:150,height:300,hOffset:35,vOffset:5},mobile:{show:!1,scale:.5},react:{opacity:.9},name:{canvas:"live2dcanvas",div:"live2d-widget"},dev:{border:!1},dialog:{enable:!1,hitokoto:!1}})</script><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:1,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e()},t.src!==i&&(n.src=i)}()}o(),n.addEventListener("scroll",function(){var t,e;t=o,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this)</script><script>!function(e,s,p,r){if(void 0===e.webpushr){e.webpushr=e.webpushr||function(){(e.webpushr.q=e.webpushr.q||[]).push(arguments)};var n,w=s.getElementsByTagName(p)[0];(n=s.createElement(p)).id="webpushr-jssdk",n.async=1,n.src="https://cdn.webpushr.com/app.min.js",w.parentNode.appendChild(n)}}(window,document,"script"),webpushr("setup",{key:"BDHamjevXR9yPJrttxl80MjCYEwm3CKzwsi3rwMXxq4Lnbzhr2fNQARqXJVhfBn_ucmy9QHixa3qps8eEFXBwmw"})</script></body></html>